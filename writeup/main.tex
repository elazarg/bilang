%% For double-blind review submission
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.

\usepackage[nounderscore]{syntax}
\usepackage{cleveref} % Must be loaded as last package

\input{macros}

\newtheorem{remark}{Remark}[section]

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PLDI'18]{ACM SIGPLAN Conference on Programming Language Design and Implementation}{\today}{\currenttime}
% \acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\input{abstract}

\begin{document}

\input{acm-title-info}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\section{Abstract Machine}
The abstract machine works in five steps.

The first step is joining: a map from open roles to agents is maintained, where new roles can be occupied and abandoned (by messages from the appropriate agents). At some point, when the map is full, the machine continues to the next step, and the roles are locked. Note that there is no progress guarantee at the joining step. Also note that joining messages carry an amount of gas (or other payment method) that must be enough for the rest of the protocol -- this is a commitment to the continuation of the protocol. Once a role has been committed to, it cannot be abandoned -- or to be precise, abandoning roles is not compensated for.

The second step is assigning a private variable whose value can be restricted by a \texttt{where} clause, and then publishing a cryptographic commitment. Again a map is maintained, and when the map is full or the progress condition is met, the machine continues to step 3.

The third step is publishing a private variable. The map is maintained as before, but published values are checked against the commitment and against the \texttt{where} clause; mismatches are simply dropped. The progress is as in step 2.

The forth step consists of folding the actions of role-sets, using a commotative-assiciative operation. Implementation-wise this fold happens at each publish step, but at the abstract level we regard it as a separate step. The fold operation should not have any side effect on the state of the machine. (FIX: this cannot be the case if participants can change their choices; fold in general does not handle properly a change of mind with non-cancellable operators such as $max$).

The fifth step is arbitrary (finite) computation on the published variables; as a side effect it binds values to fresh global variables, and sends them to every participant. Further computation can refer to these variables.

These five steps are performed repeatedly until the end of the program. Each step can also be empty, but there can be no actions without a joining operation before it.

Note that the maps are not ``in-flight messages'' in the underlying system. For this we define network semantics.

\section{Network Semantics}

We define the valid transitions on the entire system, assuming abstract specification of the clients and the (single) server. The network behavior is simple: a client can enqueue messages in its own queue. The miner dequeues a message from some arbitrary queue, executes it, and appends the resulting event (assumed to be a single item) to the list of events.

\begin{align*}
types &: State, Event, Msg; \;\; id \in \mathbb{N} \\
K &: \mathbb{N} \rightarrow State \; & \leadsto &: (State \times \overline{Event}) \times (State \times MSG) \\
Q &: \mathbb{N} \rightarrow \overline{Msg} \; & \Downarrow &: (State \times (\mathbb{N} \times Msg)) \rightarrow (State \times Event) \\
s &: State \\
e &: \text{list of Event} \\
\end{align*}

\begin{align*}
\judge{&Send}{
	(k, e) \leadsto (k', m)
}{
	(K[id \mapsto k], Q[id \mapsto q], s, e) \leadsto (K[id \mapsto k'], Q[id \mapsto m \cdot q], s, e)
}
\\
\\
\judge{&Perform}{
    (s, (id, m)) \Downarrow (s', e)
}{
	(K, Q[id \mapsto q \cdot m], s, e) \leadsto (K, Q[id \mapsto q], s', es \cdot e)
}
\end{align*}

\pagebreak

\setlength{\grammarindent }{2cm}

\section{Game Language}

\subsection{Syntax}

\begin{grammar}
	<Prog>      ::= <Role>+ <BigStep>+

	<Role>		::= <ID> [ "multiple" ]

	<BigStep>   ::= <Cell>+ "pre" <Stmt>* "post" <Stmt>*

	<Cell> 		::= <LocalStep> <Fold>

	<LocalStep> ::= "public" <ID>* "where" <Exp>
	
	<Fold>      ::= "fold" <Exp> <Exp>
\end{grammar}

Syntactically, we forbid assignment to global variables in the local steps;
we forbid reference to variables of other roles from the same big step;
assignments and bindings are always to a new variable.
fold expressions can only assign role-static variables, and must be commutative.

A state is a tuple 
\[
	(\Sigma: Var \mapsto Value, \overline{\sigma}: Agent \times Var \mapsto Value )
\].

Denote $\mathbb{S} = (Env \times Env)$


\newcommand{\G}{\Sigma}
\newcommand{\s}{\sigma}
\newcommand{\R}{\overline{\s}}

We assume $Exec: \texttt{Stmt*} \times \mathbb{S} \mapsto Env $, and $Eval: Exp \times \mathbb{S} \mapsto Value$.
$\mathcal{F} = abs(f)$ for the fold expression returns a function $\mathbb(S) \times Value^n \mapsto Value^n$.

We also define $fold(initial, \mathcal{F}, \R)= f(initial, \mathcal{F}(\R_0, \mathcal{F}(\R_1, ...)))$ but in no particular order and not necessarily exhaustively.
This is not uniquely defined - i.e. it's multifunction (if the operation is commutative the result is a singleton).

We omit timeout notation.

\begin{align*}
	\judge{&Local}{
		\s' = \s[\overline{s} \mapsto \overline{v}] \;\;\;
		Eval(cond, (\G, \s')) = \emph{tt}
	}{
		(\texttt{public }(\overline{s}) \texttt{ where } cond, (\G, \s)) \rightsquigarrow \s'
	}\\
	\\
	\judge{&Fold}{
		\forall a, (local, (\G, \R_a)) \rightsquigarrow \R'_a \;\;\;
		\G' \in fold(s, abs(f, \G), \R)
	}{
		(local \texttt{ fold } s \texttt{ } f, (\G, \R)) \Downarrow (\G', \R')
	}\\
	\\
	\judge{&Global}{
		\forall r \in \overline{r}, (s, (Exec(pre, (\G, \emptyset)), \R)) \longrightarrow (\G'_r, \R'_r)
	}{
		(\overline{r} \texttt{ pre } pre \texttt{ post } post, (\G, \R))
		\Downarrow (Exec(post, (\G', \emptyset)), \bigcup_{r\in \overline{r}} \R'_r)
	}
\end{align*}

\vfill 
\pagebreak

\begin{align*}
	\judge{&Local}{
		exp \text{ evaluates to true under assignment of values to variables on a process/object T of role R}
	}{
		\text{variables of T are updated to these values and fold statements are executed, updating the static variables for role R}
	}\\
	\\
	\judge{&Global}{
		\text{after execution of "pre", each of the local steps can transition from }
		\sigma_i \text{ to } \sigma'_i \text{ and timeout passed}
	}{
		\text{ "pre" is executed, } \sigma_i \text{ transition to } \sigma'_i \text{ and "post" is executed}
	}
\end{align*}


For \lit{join role[n]} the fold expression \texttt{let (\_, n) := fold 0 ($\lambda$ x.x)} is added. 
\lit{join role} is a syntactic sugar for \lit{join role[1]}.

The syntax for combining the languages above is best described in a tabular form, demonstrating a $2$-player games:

\begin{table}[h]
		\begin{tabular}[t]{|c|c|c|}
			\hline
			\synt{Join} & \synt{Join}  & \synt{Progress} \\
			\hline
			\multicolumn{2}{ |c| }{\synt{Global}} &  \\
			\hline
			\synt{S}    & \synt{S}     & \synt{Progress} \\
			\synt{Fold} & \synt{Fold}  &                 \\
			\hline
			\multicolumn{2}{ |c| }{\synt{Global}} &  \\
			\hline
			\synt{S}    & \synt{S}     & \synt{Progress} \\
			\synt{Fold} & \synt{Fold}  &                 \\
			\hline
			\multicolumn{2}{ |c| }{\synt{Global}} &  \\
			\hline
		\end{tabular}
	\hfill
		\begin{tabular}[t]{|c|c|c|}
			\hline
			\texttt{join Even[1]}		& \texttt{join Odd[1]}		&  \\
			\hline
			\multicolumn{2}{ |c| }{-} &  \\
			\hline
			\texttt{private c: bool}	& \texttt{private c: bool}	& \texttt{timeout(1 day)} \\
			- 							& -							&                		  \\
			\hline
			\multicolumn{2}{ |c| }{-} &  \\
			\hline
			\texttt{publish c}			& \texttt{publish c}		& \texttt{timeout(1 day)} \\
			- 							& -							&                		  \\
			\hline
			\multicolumn{2}{ |c| }{\texttt{W := winner(Even.c, Odd.c)}} &  \\
			\hline
		\end{tabular}
\end{table}

Information (e.g. by scoping rules), like time, flows downwards, never upwards, and is not intended to flow sideways.
The latter is not enforced against malicious client (that can inspect in-flight messages or watch the blockchain),
and \lit{private} should be used when important.
Note that even then, the mere action of sending a message leaks information; this is probably unavoidable in current systems.

\subsubsection{Names and Scopes}

Variables are accessible from the point of definition downwards.
Local variables start with lower-case letters; they are accessible only from the same role or from global scope.
Global variables start with capital letters; they are readable everywhere.
Role variables are global variables.

Unless proven to be initialized, variables declared as being of type T are of type Option[T].

\subsubsection{Table}
Programs are parametrized by the number of roles $k$. \emph{$k$-role program} is defined as:

\begin{grammar}
	<Table> ::= <Row>$^n$

	<Row> ::= (<S> <Fold>? "&")$^k$ % adding fold to st will make the language cleaner, but the programs more verbose
			  "progress" <Progress>? "then" <Global> "$" % if we'll have retry semantics, maybe we want ":-" instead of "then"? :)
		\alt  (<Join>? "&")$^k$  <Progress>? "$"
\end{grammar}

The first non-empty item for each column must be an appropriate $join$.

Transposing the program, the syntax is:

\begin{grammar}
	<Prog> ::= <Sn>$^k$ <P> <G>

	<Sn> ::= ("-" "$")$^x$ <Join> "$" (<S> <Fold> "$")$^{n-x-1}$ "&"

	<P> ::= (<Progress> "$")$^n$ "&"

	<G> ::= (<Global> "$")$^n$ "&"
\end{grammar}

\vfill
\pagebreak

\subsection{Semantics}


We define two semantic functions: join semantics and message semantics.

The meaning of a join step is a function from $2^{Msg} \rightarrow 2^{Agent}$ whose result is the new joiners.
For now we don't consider further state changes at the join step, although they might be crucial for certain applications.

The semantics of a full communication step is a function $\Sigma \times 2^{P} \rightarrow \Sigma \times E $ where $P$ is a packet -- a message from 
client to server -- and $E$ is a broadcast message. $\Sigma$ is the type of complete server state (local and shared).

Each full communcation step consists of 3 (possibly empty) phases: send, fold and progress-execute.
The fold step happens (observationally) as a single step, but operationally each step executes immediately following the receiving of the message.
The values of the global variables at the end of the third phase are the contents of the broadcast message.

Event handler semantics - different kind of \texttt{let} declarations:

\newcommand{\owner}{\mathbb{R}}
\begin{align*}
	\judge{&Join}{
		i = \#(role) \;\;\; \texttt{m is variable or } i < \semfunc[m]
	}{
		\semfunc[{join role[m]}](sender, \_) = ((role, i) \mapsto (sender, \emptyset), i+1, ("accept", n, i)])
	}
\end{align*}

In the following, the messages are always from the owner of the session; otherwise they are dropped:

\begin{align*}
	\judge{&Public}{
		msg \in T \; \; \; exp \leadsto^* true
	}{
		\semfunc[public (n: T) where exp](msg, \sigma) = \sigma [n \mapsto msg]
	}\\	\\
	\judge{&Private}{
		\texttt{thunk(n, s) = (hash(n, s, sender)=msg \& exp)}
	}{
		\semfunc[private (n: T) where exp](msg, \sigma) = \sigma [@n \mapsto thunk]
	}\\	\\
	\judge{&Publish}{
		\Gamma \vdash n : T \;\;\; msg = (v, s) \in (T \times int) \;\;\; \sigma(@n)(v, s) \leadsto* true
	}{
		\semfunc[publish n](msg, \sigma) = \sigma [n \mapsto msg]
	}
\end{align*}

A \lit{private}-\lit{publish} pair is implemented as a simple commitment scheme, that is also non-replayable.

Let $\mathbb{M}$ be the set of messages accepted in the sessions;
let $\mathbb{F}$ be the left-folding of the operation $f$ over $\mathbb{M}$ with $v$ as initial value,
Then

\begin{align*}
	\judge{&Fold}{
		e \Downarrow v
	}{
		\semfunc[let (m, n) := fold e f](\Sigma, \sigma) = \Sigma [m \mapsto \mathbb{F}, n \mapsto |\mathbb{M}| ]
	}
\end{align*}


\begin{align*}
	\judge{&Global}{
		exp \Downarrow v
	}{
		\semfunc[let N := exp;](\Sigma) = \Sigma [N \mapsto v]
	}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: abstraction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{acks}
% \end{acks}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

%\bibliography{biblio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

%\appendix

% \input{notations}

%\input{sem-formal}

\end{document}
