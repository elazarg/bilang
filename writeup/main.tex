%% For double-blind review submission
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{amsfonts}
\usepackage[all]{xy}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage[T1]{fontenc}
\usepackage{extarrows}
\usepackage[noend,noline]{algorithm2e}
\usepackage{arydshln}
\usepackage{centernot}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{cleveref} % Must be loaded as last package
\usepackage[nodayofweek]{datetime}
\usepackage{todonotes}
\usepackage{comment}

\usepackage{bussproofs}
\usepackage[nounderscore]{syntax}
\usepackage{cmll}



%\usepackage[caption=false]{subfig}
% \usepackage[hidelinks]{hyperref}
% \usepackage{hyperref}
% \usepackage[super]{nth}
% \usepackage{makeidx}  % allows for indexgeneration
% \usepackage{cite}
%\usepackage{boisik}
%\usepackage{mathabx}
% \usepackage{fdsymbol}
% \usepackage{MnSymbol}
%\usepackage{fourier}
% \usepackage{MnSymbol} % for \powerset
% \usepackage{thm-restate}


\input{macros}

\newtheorem{remark}{Remark}[section]

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PLDI'18]{ACM SIGPLAN Conference on Programming Language Design and Implementation}{\today}{\currenttime}
% \acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\input{abstract}

\begin{document}

\input{acm-title-info}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\section{Network Semantics}

We define the valid transitions on the entire system, assuming abstract specification of the clients and the (single) server. The network behavior is simple: a client can enqueue messages in its own queue. The miner dequeues a message from some arbitrary queue, executes it, and appends the resulting event (assumed to be a single item) to the list of events.

\begin{align*}
types &: State, Event, Msg; \;\; id \in \mathbb{N} \\
K &: \mathbb{N} \rightarrow State \; & \leadsto &: (State \times \overline{Event}) \times (State \times MSG) \\
Q &: \mathbb{N} \rightarrow \overline{Msg} \; & \Downarrow &: (State \times (\mathbb{N} \times Msg)) \rightarrow (State \times Event) \\
s &: State \\
e &: \text{list of Event} \\
\end{align*}

\begin{align*}
\judge{&Send}{
	(k, e) \leadsto (k', m)
}{
	(K[id \mapsto k], Q[id \mapsto q], s, e) \leadsto (K[id \mapsto k'], Q[id \mapsto m \cdot q], s, e)
}
\\
\\
\judge{&Perform}{
    (s, (id, m)) \Downarrow (s', e)
}{
	(K, Q[id \mapsto q \cdot m], s, e) \leadsto (K, Q[id \mapsto q], s', es \cdot e)
}
\end{align*}

\pagebreak

\setlength{\grammarindent }{2cm}

\subsection{Spreadsheet-Language}

Session-step grammar:

\begin{grammar}
	<St> ::= join <roleDef> % first in column only
		\alt <S>

	<Sn> ::= join <roleDef>[<globalVarDef>] % first in column only  % TODO: N becomes irrelevant when some bail out
		\alt <S>
	
	<S>  ::= -
		\alt private (<localVarDef>:<type>)+
        \alt public (<localVarDef>:<type>)+ <Where>
		\alt publish <localVar>+ <Where>
	
	<Where> ::= where <boolExp>
	
	<roleDef> ::= <globalVarDef>
\end{grammar}

Fold-step grammar:

\begin{grammar}
	<F> ::= -
		\alt let (<globalVarDef>, <globalVarDef>) = fold <exp> (<localVarDef> this => <exp>)  % second globalVarDecl for counting active participants
\end{grammar}

Global-step grammar:
\begin{grammar}
	<G> ::= -
		\alt let <globalVarDef> := <Exp>; <G>?
\end{grammar}

Progress condition grammar:
\begin{grammar}
	<P> ::= -
		\alt timeout(<TimeExpr>)
\end{grammar}

Scoping: variables are accessible from the point of definition downwards.
Local variables are accessible only from the same role or from global scope.
Global variables are readable everywhere.

Unless proven to be initialized, variables declared as being of type T are of type Option[T].

\subsubsection{Table}
Programs are parametrized by the number of roles $K$. \emph{$(K+R)$-role program step} is defined as:

\begin{grammar}
	<P> ::= <St_1> | ... | <St_K> | <Sn_1> <F> | ... | <Sn_R> <F> progress <P> then <G>
\end{grammar}

A \emph{$K+R$-role program} is a sequence of \emph{$K+R$-role program step}s.
The first non-empty item for each $<St_i>$ or $<Sn_i>$ must be an approprite $join$.

\begin{comment}

\subsection{Server Language}

We define a language $SL$ whose programs $p\in SL$ has meaning \[\semfunc[p] \in State \times (\mathbb{N} \times Msg) \rightarrow (State \times Event)\]

\begin{grammar}
    <prog> ::= done
         \alt receive <case list> end   % external choice by owner endpoint
         % \alt receive (label from <BindId>) <case list> end   % external choice: race
         \alt par <prog> and <pid> <prog> end
         \alt <prog>; <prog>

	<cmd> ::= yield <ev: E>; <prog>                 % yield + external choice
         \alt if <E> then <cmd> else <cmd> end   % internal choice
         \alt while <E> do <cmd>; yield <ev: E>; <prog>; end    % limited recursion
         % \alt tell <pid> <E>
         % \alt ask <pid> <E> <case list>
         \alt <var> = <E>; <cmd>
         \alt fail;
         \alt require *; <cmd>

    <case list> ::= \_ => end
        \alt <pat> => <cmd>; <case list>
\end{grammar}

The intention is that \texttt{yield} expressions will be the only suspension points, and evaluation of such an expression always translates to the sequence:
\begin{enumerate}
\item finish execution with $ev$ as an output event
\item wait for the network to send a request
\item inspect the request and continue execution
\end{enumerate}

We use a function $\semfunc[p] \in State \rightarrow (State \times Event)$ to define the internal state change, without explicitly referring to the input $(i, Msg)$ after its binding in the \texttt{match} construct.

\begin{align*}
\judge{&Receive}{
	-
}{
	\semfunc[\text{match (i, Msg) Cs end}, (i', Msg')] = \semfunc[\text{Cs[i/i', Msg/Msg']}]  % receiving MSG
}\\
\\
\judge{&Yield}{
	-
}{
	\semfunc[\text{yield ev; p}] = (p, ev)  % waiting for MSG
}\\
\\
\judge{&ParallelLeft\text{ and symmetrically for p2}}{  % decision: fork a new address? this will be visible to the client
	\semfunc[p1, (i, Msg)] = (p1', ev)
}{
	\semfunc[\text{par p1 and p2 end}, (i, Msg)] = (\text{par p1' and p2 end}, ev)
}\\
\\
\judge{&ParallelDone}{
    -
}{
	\semfunc[\text{par done and done end}] = (done, ev)
}
\end{align*}
\begin{align*}
\judge{&Then}{
	-
}{
	\semfunc[\text{if * then C1 else C2}] = \semfunc[C1]
}& \;\;\;\;
\judge{&CaseGo}{
	- % TODO: \text{match receive Cs end} and simply dispatch to the first successful match
}{
	\semfunc[\text{(i, *) => p; Cs}] = \semfunc[p]
}\\
\\
\judge{&Else}{
	-
}{
	\semfunc[\text{if * then C1 else C2}] = \semfunc[C2]
}& \;\;\;\;
\judge{&CaseDrop}{
	-
}{
	\semfunc[\text{(i, *) => p; Cs}] = \semfunc[Cs]
}\\
\\
\judge{&WhileDone}{
	-
}{
	\semfunc[\text{while * do p end; p'}] = \semfunc[p']
}& \;\;\;\;
\judge{&While}{
	\semfunc[p] = (p', ev)
}{
	\semfunc[\text{while * do p end}] = (\text{p'; while * do p end}, ev)
}
\end{align*}

\end{comment}
\vfill
\pagebreak




\begin{align*}
	E :& \text{ Append-only list} \\
    R_i :& \text{ A Queue for actor } i
\end{align*}

\begin{grammar}
	<cmd> ::= publish <V>
         \alt yield; take <T>
         \alt if * then <cmdList> else <cmdList>
         \alt while * do <cmdList>
\end{grammar}


\begin{align*}
\judge{TAKE}{
	-
}{
	(E, (i, L, M)::R, \Sigma, \text{take L}.P) \reduce (E, R, \Sigma, P)
}& \;\;\;\;
\judge{PUB}{
	\Sigma \vdash v \reduce x
}{
	(E, R, \Sigma, \text{publish v}.P)\reduce (x::E, R, \Sigma, P)
}\\
\\
\judge{DROP}{
	L' \neq L
}{
	(E, (i, L', M)::R, \Sigma, \text{take L}.P) \reduce (E, R, \Sigma, \text{take L}.P)
} & \;\;\;\;
\judge{YIELD}{
	 \;
}{
	(E, R, \Sigma, \text{yield; take T}.P) \reduce (E, R, \Sigma, \text{takes T}.P)
}
\end{align*}

\subsection{Client Language}

We define a language $CL$ whose programs $p\in CL$ has meaning \[\semfunc[p] \in State \times \text{list of Event} \times (State \times MSG)\]

\begin{grammar}
	<cmd> ::= send <V>: <T>
         \alt read latest <T>
         \alt deq <T>
         \alt if * then <cmdList> else <cmdList>
         \alt while * do <cmdList>
\end{grammar}

\begin{align*}
\judge{RL}{
	\forall M', (L, M') \notin E'
}{
	(E'.(L, M).E, R_i, \Phi, \text{read latest L}.P) \reduce (E, R_i, \Phi, P)
}& \;\;\;\;
\judge{SEND}{
	\Sigma \vdash v \reduce x
}{
	(E, R_i, \Phi, \text{send v: L}.P)\reduce (E, (i, L, x)::R_i, \Phi, P)
}\\
\\
\judge{DEQ}{
	\;
}{
	((T, M)::E, R_i, \Phi, \text{deq T}.P) \reduce (E, R_i, \Phi, P)
} & \;\;\;\;
\judge{YIELD}{
	 -
}{
	-
}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{notations}


% \input{reentrancy}
% \input{dfa}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{acks}
% We would like to thank the teams at Validity Labs and Ambisafe that assisted us in analyzing their contracts, and to Validity Labs for referring us to the web Oyente tool.
% \end{acks}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\bibliography{biblio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\appendix

% \input{notations}

%\input{sem-formal}

\end{document}
