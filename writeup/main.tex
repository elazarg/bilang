%% For double-blind review submission
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.

\usepackage{bussproofs}
\usepackage[nounderscore]{syntax}
\usepackage{cleveref} % Must be loaded as last package

\input{macros}

\newtheorem{remark}{Remark}[section]

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PLDI'18]{ACM SIGPLAN Conference on Programming Language Design and Implementation}{\today}{\currenttime}
% \acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\input{abstract}

\begin{document}

\input{acm-title-info}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\section{Network Semantics}

We define the valid transitions on the entire system, assuming abstract specification of the clients and the (single) server. The network behavior is simple: a client can enqueue messages in its own queue. The miner dequeues a message from some arbitrary queue, executes it, and appends the resulting event (assumed to be a single item) to the list of events.

\begin{align*}
types &: State, Event, Msg; \;\; id \in \mathbb{N} \\
K &: \mathbb{N} \rightarrow State \; & \leadsto &: (State \times \overline{Event}) \times (State \times MSG) \\
Q &: \mathbb{N} \rightarrow \overline{Msg} \; & \Downarrow &: (State \times (\mathbb{N} \times Msg)) \rightarrow (State \times Event) \\
s &: State \\
e &: \text{list of Event} \\
\end{align*}

\begin{align*}
\judge{&Send}{
	(k, e) \leadsto (k', m)
}{
	(K[id \mapsto k], Q[id \mapsto q], s, e) \leadsto (K[id \mapsto k'], Q[id \mapsto m \cdot q], s, e)
}
\\
\\
\judge{&Perform}{
    (s, (id, m)) \Downarrow (s', e)
}{
	(K, Q[id \mapsto q \cdot m], s, e) \leadsto (K, Q[id \mapsto q], s', es \cdot e)
}
\end{align*}

\pagebreak

\setlength{\grammarindent }{2cm}

\section{Spreadsheet-Language}

\subsection{Syntax}

\begin{grammar}
	<Join>	::= "join" <gVar> "[" (<num>|<gVar>) "]" % first in column only  % TODO: N becomes irrelevant when some bail out

	<S>		::= ( "private" | "public" ) (<lVar> ":" <type>)+ "where" <BoolExp>  % "private" too since it doesn't make sense to have "where" using newer variables
			\alt "publish" <lVar>+
			\alt "-"
\end{grammar}

\begin{grammar}
	<Fold> ::= "let" "(" <gVar> "," <gVar> ")" ":=" "fold" <Exp> "(" <lVar> "this" "=>" <Exp> ")"  % second globalVarDef for counting active participants
\end{grammar}

\begin{grammar}
	<Global> ::= ( "let" <gVar> ":=" <Exp> ";")*
\end{grammar}

\begin{grammar}
	<Progress> ::= "timeout" "(" <TimeExpr> ")"
\end{grammar}

For \lit{join role[n]} the fold expression \texttt{let (\_, n) := fold 0 ($\lambda$ x.x)} is added. 
\lit{join n} is a syntactic sugar for \lit{join n[1]}.

The syntax for combining the languages above is best described in a tabular form,
demonstrating the intended information flow for $2$-player games:

\begin{table}[h]
		\begin{tabular}[t]{|c|c|c|}
			\hline
			\synt{Join} & \synt{Join}  & \synt{Progress} \\
			\hline
			\multicolumn{2}{ |c| }{\synt{Global}} &  \\
			\hline
			\synt{S}    & \synt{S}     & \synt{Progress} \\
			\synt{Fold} & \synt{Fold}  &                 \\
			\hline
			\multicolumn{2}{ |c| }{\synt{Global}} &  \\
			\hline
			\synt{S}    & \synt{S}     & \synt{Progress} \\
			\synt{Fold} & \synt{Fold}  &                 \\
			\hline
			\multicolumn{2}{ |c| }{\synt{Global}} &  \\
			\hline
		\end{tabular}
	\hfill
		\begin{tabular}[t]{|c|c|c|}
			\hline
			\texttt{join Even[1]}		& \texttt{join Odd[1]}		&  \\
			\hline
			\multicolumn{2}{ |c| }{-} &  \\
			\hline
			\texttt{private c: bool}	& \texttt{private c: bool}	& \texttt{timeout(1 day)} \\
			- 							& -							&                		  \\
			\hline
			\multicolumn{2}{ |c| }{-} &  \\
			\hline
			\texttt{publish c}			& \texttt{publish c}		& \texttt{timeout(1 day)} \\
			- 							& -							&                		  \\
			\hline
			\multicolumn{2}{ |c| }{\texttt{W := winner(Even.c, Odd.c)}} &  \\
			\hline
		\end{tabular}
\end{table}

Information (e.g. by scoping rules), like time, flows downwards, never upwards, and is not intended to flow sideways.
The latter is not enforced against malicious client (that can inspect in-flight messages or watch the blockchain),
and \lit{private} should be used when important.

\subsubsection{Names and Scopes}

Variables are accessible from the point of definition downwards.
Local variables start with lower-case letters; they are accessible only from the same role or from global scope.
Global variables start with capital letters; they are readable everywhere.
Role variables are global variables.

Unless proven to be initialized, variables declared as being of type T are of type Option[T].

\subsubsection{Table}
Programs are parametrized by the number of roles $k$. \emph{$k$-role program} is defined as:

\begin{grammar}
	<Table> ::= <Row>$^n$

	<Row> ::= (<S> <Fold>? "&")$^k$ % adding fold to st will make the language cleaner, but the programs more verbose
			  "progress" <Progress>? "then" <Global> "$" % if we'll have retry semantics, maybe we want ":-" instead of "then"? :)
\end{grammar}

The first non-empty item for each \synt{S} must be an appropriate $join$.

Transposing the program, the syntax is:

\begin{grammar}
	<Prog> ::= <Sn>$^k$ <P> <G>

	<Sn> ::= ("-" "$")$^x$ <Join> "$" (<S> <Fold> "$")$^{n-x-1}$ "&"

	<P> ::= (<Progress> "$")$^n$ "&"

	<G> ::= (<Global> "$")$^n$ "&"
\end{grammar}

\vfill
\pagebreak

\subsection{Semantics}

Event handler semantics - different kind of \texttt{let} declarations:

\newcommand{\owner}{\mathbb{R}}
\begin{align*}
	\judge{&Join}{
		i = \#(role) \;\;\; \texttt{m is variable or } i < \semfunc[m]
	}{
		\semfunc[{join role[m]}](sender, \_) = ((role, i) \mapsto (sender, \emptyset), i+1, ("accept", n, i)])
	}
\end{align*}

In the following, the messages are always from the owner of the session; otherwise they are dropped:

\begin{align*}
	\judge{&Public}{
		msg \in T \; \; \; exp \leadsto^* true
	}{
		\semfunc[public (n: T) where exp](msg, \sigma) = \sigma [n \mapsto msg]
	}\\	\\
	\judge{&Private}{
		\texttt{thunk(n, s) = (hash(n, s, sender)=msg \& exp)}
	}{
		\semfunc[private (n: T) where exp](msg, \sigma) = \sigma [@n \mapsto thunk]
	}\\	\\
	\judge{&Publish}{
		\Gamma \vdash n : T \;\;\; msg = (v, s) \in (T \times int) \;\;\; \sigma(@n)(v, s) \leadsto* true
	}{
		\semfunc[publish n](msg, \sigma) = \sigma [n \mapsto msg]
	}
\end{align*}

A \lit{private}-\lit{publish} pair is implemented as a simple commitment scheme, that is also non-replayable.

\begin{align*}
	\judge{&Fold}{
		e2 \leadsto^* v1 \;\;\; rs = \{ role | \text{role sent message} \} \;\;\; m' = \texttt{fold } v1 \texttt{ f } rs
	}{
		\semfunc[let (m, n) := fold e2 f](\Sigma, \sigma) = \sigma [m \mapsto m', n \mapsto \#(msg) ]
	}
\end{align*}


\begin{align*}
	\judge{&Global}{
		exp \leadsto^* v
	}{
		\semfunc[let N := exp;](\Sigma) = \Sigma [N \mapsto v]
	}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: abstraction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{acks}
% \end{acks}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

%\bibliography{biblio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

%\appendix

% \input{notations}

%\input{sem-formal}

\end{document}
