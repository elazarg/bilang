%% For double-blind review submission
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


\usepackage{booktabs}
\usepackage{subcaption}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{amsfonts}
\usepackage[all]{xy}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage[T1]{fontenc}
\usepackage{extarrows}
\usepackage[noend,noline]{algorithm2e}
\usepackage{arydshln}
\usepackage{centernot}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{cleveref} % Must be loaded as last package
\usepackage[nodayofweek]{datetime}
\usepackage{todonotes}

\usepackage{bussproofs}
\usepackage[nounderscore]{syntax}
\usepackage{cmll}



%\usepackage[caption=false]{subfig}
% \usepackage[hidelinks]{hyperref}
% \usepackage{hyperref}
% \usepackage[super]{nth}
% \usepackage{makeidx}  % allows for indexgeneration
% \usepackage{cite}
%\usepackage{boisik}
%\usepackage{mathabx}
% \usepackage{fdsymbol}
% \usepackage{MnSymbol}
%\usepackage{fourier}
% \usepackage{MnSymbol} % for \powerset
% \usepackage{thm-restate}


\input{macros}

\newtheorem{remark}{Remark}[section]

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PLDI'18]{ACM SIGPLAN Conference on Programming Language Design and Implementation}{\today}{\currenttime}
% \acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\input{abstract}

\begin{document}

\input{acm-title-info}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

\section{Network Semantics}

We define the valid transitions on the entire system, assuming abstract specification of the clients and the (single) server.

\begin{align*}
types &: State, Event, TX; \;\; i \in Agent \\
c_i &: State \; & \Sigma^{c}_{i} &: State \times \text{list of Event} \times (State \times TX) \\
q_i &: \text{queue of TX} \; & \Sigma^{s} &: State \times (Agent \times TX) \rightarrow (State \times Event) \\
\sigma &: State \\
e &: \text{list of Event} \\
\end{align*}

\begin{align*}
\judge{&Send}{
	(c_i, e, (c'_i, tx)) \in \Sigma^{c}_i \;\;\; \forall i\neq j, c_j=c'_j
}{
	(c, q, \sigma, e) \leadsto (c', enque_i(q, tx), \sigma, e)
}
\\
\\
\judge{&Perform}{
    \Sigma^{s}(\sigma, (i, peek(q_i) ) = (\sigma', e')
}{
	(c, q, \sigma, e) \leadsto (c, deque_i(q), \sigma', e'::e)
}
\end{align*}

\pagebreak

\setlength{\grammarindent }{2cm}

\subsection{Server Language}

We define a language $SL$ whose programs $p\in SL$ has meaning \[\semfunc[p] \in State \times (Agent \times TX) \rightarrow (State \times Event)\]

\begin{grammar}
	<cmd> ::= match yield ev <case list> end   % external choice
         \alt if * then <cmd> else <cmd> end   % internal choice
         \alt while * do <cmd> end             % recursion
         \alt proc(); <cmd>
         \alt fail
         \alt require *; <cmd>

    <case list> ::= \_ => end
        \alt (i, *) => <cmd>; <case list>
\end{grammar}

The intention is that \texttt{yield} expressions will be the only entry points, and evaluation of such an expression always translates to the sequence:
\begin{enumerate}
\item finish execution with $ev$ as an output event
\item wait for the network to send a request 
\item inspect the request and continue execution
\end{enumerate}

\[
\judge{Yield}{
	-
}{
	\semfunc[\text{match yield ev Cs end}] = (\text{match receive Cs end}, ev)  % waiting for TX
}
\]
\begin{align*}
\judge{&Then}{
	-
}{
	\semfunc[\text{if * then C1 else C2}] = \semfunc[C1]
}& \;\;\;\;
\judge{&CaseGo}{
	- % TODO: \text{match receive Cs end} and simply dispatch to the first successful match
}{
	\semfunc[\text{(i, *) => p; Cs}] = \semfunc[p]
}\\
\\
\judge{&Else}{
	-
}{
	\semfunc[\text{if * then C1 else C2}] = \semfunc[C2]
}& \;\;\;\;
\judge{&CaseDrop}{
	-
}{
	\semfunc[\text{(i, *) => p; Cs}] = \semfunc[Cs]
}\\
\\
\judge{&WhileDone}{
	-
}{
	\semfunc[\text{while * do p end; p'}] = \semfunc[p']
}& \;\;\;\;
\judge{&While}{
	\semfunc[p] = (p', ev)
}{
	\semfunc[\text{while * do p end}] = (\text{p'; while * do p end}, ev)
}
\end{align*}

\vfill
\pagebreak




\begin{align*}
	E :& \text{ Append-only list} \\
    R_i :& \text{ A Queue for actor } i
\end{align*}

\begin{grammar}
	<cmd> ::= publish <V>
         \alt yield; take <T>
         \alt if * then <cmdList> else <cmdList>
         \alt while * do <cmdList>
\end{grammar}


\begin{align*}
\judge{TAKE}{
	-
}{
	(E, (i, L, M)::R, \Sigma, \text{take L}.P) \reduce (E, R, \Sigma, P)
}& \;\;\;\;
\judge{PUB}{
	\Sigma \vdash v \reduce x
}{
	(E, R, \Sigma, \text{publish v}.P)\reduce (x::E, R, \Sigma, P)
}\\
\\
\judge{DROP}{
	L' \neq L
}{
	(E, (i, L', M)::R, \Sigma, \text{take L}.P) \reduce (E, R, \Sigma, \text{take L}.P)
} & \;\;\;\;
\judge{YIELD}{
	 \;
}{
	(E, R, \Sigma, \text{yield; take T}.P) \reduce (E, R, \Sigma, \text{takes T}.P)
}
\end{align*}

\subsection{Client Language}

We define a language $CL$ whose programs $p\in CL$ has meaning \[\semfunc[p] \in State \times \text{list of Event} \times (State \times TX)\]

\begin{grammar}
	<cmd> ::= send <V>: <T>
         \alt read latest <T>
         \alt deq <T>
         \alt if * then <cmdList> else <cmdList>
         \alt while * do <cmdList>
\end{grammar}

\begin{align*}
\judge{RL}{
	\forall M', (L, M') \notin E'
}{
	(E'.(L, M).E, R_i, \Phi, \text{read latest L}.P) \reduce (E, R_i, \Phi, P)
}& \;\;\;\;
\judge{SEND}{
	\Sigma \vdash v \reduce x
}{
	(E, R_i, \Phi, \text{send v: L}.P)\reduce (E, (i, L, x)::R_i, \Phi, P)
}\\
\\
\judge{DEQ}{
	\;
}{
	((T, M)::E, R_i, \Phi, \text{deq T}.P) \reduce (E, R_i, \Phi, P)
} & \;\;\;\;
\judge{YIELD}{
	 -
}{
	-
}
\end{align*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Paper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{notations}


% \input{reentrancy}
% \input{dfa}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{acks}
% We would like to thank the teams at Validity Labs and Ambisafe that assisted us in analyzing their contracts, and to Validity Labs for referring us to the web Oyente tool.
% \end{acks}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\bibliography{biblio}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\appendix

% \input{notations}

%\input{sem-formal}

\end{document}
