%!TEX root = ./recycling.tex
%
% setting.tex

\subsection{Preliminaries\label{sec:setting}}

\paragraph{Programming language.}
We formalise our results for a simple % concurrent programming
language:
$$
C  \;::=\;  \alpha
 \mid C;C
 \mid C+C 
 \mid C^* \mid \langle C \rangle
\qquad
\cp \;::=\; C_1 \parallel \ldots \parallel C_\nthreads
$$ 
A program $\cp$ is a parallel composition of $\nthreads$ threads, which can
contain primitive commands $\alpha \in \PComm$, %meant to be executed atomically,
sequential composition $C;C'$, nondeterministic choice $C+C'$, iteration
$C^*$ and atomic execution $\langle C \rangle$ of $C$.
% We use $+$ and ${}^*$ instead of conditionals and while loops for
% theoretical simplicity: given appropriate primitive commands, conditionals and
% loops can be easily defined. 
% The form $\langle C \rangle$ executes a composite
% command $C$ atomically, and is used to express commands such as
% compare-and-swap. 
We forbid nested atomic blocks. Even though we present our logic for programs in
the above language, for readability we use a C-like notation in our examples,
which can be easily desugared \tra{\ref{app:formal}}{\nformal}.

\paragraph{Separation algebras.} To reason about concurrent algorithms, we often use
{\em permissions}~\cite{boyland},
%---a form of auxiliary state
describing ways in which threads can operate on an area of memory.  We present
our logic in an abstract form~\cite{asl} that is parametric in the kind of
permissions used.
%This abstract logic can then be instantiated as needed.
A {\em separation algebra} is a set $\Sigma$, together with a partial
commutative, associative and cancellative operation $*$ on $\Sigma$ and a unit element
$\varepsilon \in \Sigma$. 
%Here unity, commutativity and associativity hold for
%the equality that means both sides are defined and equal, or both are undefined.
The property of cancellativity says that for each $\theta \in \Sigma$, the
function $\theta * \cdot : \Sigma \rightharpoonup \Sigma$ is injective.
In the rest of the paper we assume a separation algebra $\State$ with
the operation $*$. We think of elements $\theta \in \State$ as {\em
  portions} of program states and the $*$ operation as combining such
portions.

% For example, a typical separation 

% $\RAM = \mathbb{N} \rightharpoonup_{\it fin} \mathbb{N}$
% is a

% A (partial) state in this model consists of a finite partial function from
% memory locations allocated in the heap to the values they store.

% The $*$ operation on $\RAM$ is defined as the disjoint function union $\uplus$,
% with the everywhere-undefined function %$[\,]$ 
% as its unit.


% \paragraph{Example.}
% An example of a separation algebra is the following set $\RAM$, often used to give
% semantics to heap-manipulating programs:
% $$
% \Loc = \{1, 2, \ldots\};
% \qquad
% \Val = \mathbb{Z};
% \qquad
% \RAM 
% = \Loc \rightharpoonup_{\it fin} \Val.
% $$ 
% A (partial) state in this model consists of a finite partial function from
% memory locations allocated in the heap to the values they store.  The $*$ operation
% on $\RAM$ is defined as the disjoint function union $\uplus$, with the
% everywhere-undefined function $[\,]$ as its unit.

 
\paragraph{Primitive commands.}
We assume that the semantics of every primitive command $\alpha\in\PComm$,
executed by thread $t$, is given by a transformer $f_\alpha^t:\State \to
\power(\State)^\top$. Here $\power(\State)^\top$ is the set of subsets of
$\State$ with a special element $\top$ used to denote an error state, resulting,
e.g., from dereferencing an invalid pointer.  
%The transformer $f_\alpha^t$ maps pre-states to states obtained when $\alpha$ is
%atomically executed from a pre-state.
%We assume that $\PComm$ always contains the {\sf skip} command such that $f_{\sf
%skip}(\theta) = \{\theta\}$.
For our logic to be sound, we need to place certain standard restrictions on 
$f_\alpha^t$, deferred to \tr{\ref{app:formal}}{\nformal}.  

%Elements of separation algebras are often defined using partial functions. 
%We use the following notation: 

\paragraph{Notation.}
We write $g(x)\fdef$ to mean that the function $g$ is defined
on $x$, and $g(x)\fundef$ that it is undefined on $x$.
We also write $\_$ for an expression whose value is irrelevant.

%$g[x:y]$ denotes the function that has the same value as $g$ everywhere, except
%for $x$, where it has the value $y$.


% \longonly{
% \sparagraph{Example.} Consider the algebra $\RAM$ and ${\tt x}, {\tt y} \in
% \Loc$. Then the transformer $f_\alpha^t$ for the assignment command $*{\tt x} = {\tt
%   tid}$ is defined as follows: $f_\alpha^t(\theta) = \theta[{\tt x} : t]$, if
% ${\theta({\tt x})} \fdef$; and $f_\alpha^t(\theta) = \top$, otherwise.
% }

%%% Local Variables:
%%% TeX-master: "recycling"
%%% mode: latex
%%% End:  
