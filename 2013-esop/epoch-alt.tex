%!TEX root = ./recycling.tex
%
% epoch-alt.tex

\newcommand{\nmapsto}{\stackrel{{\scriptscriptstyle\neq}}{\mapsto}}

\clearpage
\subsection{Alternative Invariants for the Epoch Algorithm}


We will be using the shorthand
\[
\cc \nmapsto x \iff \exists y.\, y \neq x \land \cc \mapsto y
\]
to denote that $\cc$ points to a node in the heap, but the node does not contain the value $x$.

We show that the reclamation in Line~\ref{pce-neg-contradiction} of \texttt{reclaim()}
is safe, by deriving the following lemma:
\begin{multline}
\forall g,x,t,A,p.\, 
\shareds{\rlist[t] \nmapsto \emptyset * \true} \implies \mbox{}
\\
\shareds{\GE\mapsto g * \forall s.\,\LE[s] \mapsto g * \true} \implies \mbox{} 
\\
\shareds{\rlist[t][g \oplus 1]\mapsto A \land x \in A * \true} \implies \mbox{}
\\
\neg (\shared{\LE[p] \mapsto g * \true} \since \shared{\cc \mapsto x * \true})
\end{multline}

To do so, we use the following invariant, which says that a thread $t$ places a node $x$ that it
detaches when its \emph{local} epoch is $g \oplus 1$ into the $g \oplus 1$ set
at the $t$ entry of the $\rlist$ array, and does not put $x$ back into the shared state
since being in that local epoch.

\begin{multline}
\Upsilon_{2}= \forall t,x,g,A .\, 
\shareds{\rlist[t][g \oplus 1] \mapsto A  \land x \in A * \true})
\\
\mbox{} \implies 
(\shareds{\cc\nmapsto x * \true}  
\since
\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
\end{multline}
and the tautologies
\begin{equation}
(\neg B \since \neg A) \implies \neg (A \since B)
\end{equation}


We establish the above by showing that
\begin{multline}
\forall g,x,t,A,p.\, 
\shareds{\rlist[t] \nmapsto \emptyset * \true} \implies \mbox{}
\\
\shareds{\GE\mapsto g * \forall s.\,\LE[s] \mapsto g * \true} \implies \mbox{} \\
(\shareds{\cc\nmapsto x * \true}  
\since
\shareds{\LE[t] \mapsto  g \oplus 1 * \true}) \implies \mbox{}\\
\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true}
\end{multline}

We now use the following invariant, which is key. 
The invariant holds because of the cyclic lock-step 
way the counter is incremented
(action $\textsf{NextEpoch}_t$).  We use the non-emptyness of the 
detached sets to exclude the first time a thread goes into an epoch--Otherwise, the $\since$ clause 
does not hold.
\begin{multline}
\Upsilon_3 = \forall g,t.\, 
\shareds{\rlist[t] \nmapsto \emptyset * \true} 
\implies \mbox{}\\
\shareds{\LE[t] \mapsto g * \true} \implies 
\mbox{}\\
(\shareds{\LE[t] \nmapsto g \oplus 1 * \true} 
\mbox{} 
\since \shared{ \forall j.\, \LE[j] \mapsto g \oplus 2 * \true}) 
\end{multline}
to establish the above by instantiating $s$ with $t$ and $j$ with $p$, getting:

\begin{multline}
\forall g,x,t,A,p.\, 
\shareds{\rlist[t] \nmapsto \emptyset * \true} \implies \mbox{}
\\
\shareds{\LE[t] \mapsto g * \true} \implies \mbox{} \\
(\shareds{\cc\nmapsto x * \true}  
\since
\shareds{\LE[t] \mapsto  g \oplus 1 * \true}) \implies \mbox{}\\
\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true}
\end{multline}
and
\begin{multline}
\Upsilon'_3 = \forall g,t.\, 
\shareds{\rlist[t] \nmapsto \emptyset * \true} 
\implies \mbox{}\\
\shareds{\LE[t] \mapsto g * \true} \implies 
\mbox{}\\
(\shareds{\LE[t] \nmapsto g \oplus 1 * \true} 
\mbox{} 
\since \shared{\LE[p] \mapsto g \oplus 2 * \true}) 
\end{multline}
which together give us that to show the above we need to establish
\begin{multline}
\forall g,x,t,p.\, 
(\shareds{\LE[t] \nmapsto g \oplus 1 * \true} 
\mbox{} 
\since \shared{\LE[p] \mapsto g \oplus 2 * \true}) 
\implies \mbox{} \\
(\shareds{\cc\nmapsto x * \true}  
\since
\shareds{\LE[t] \mapsto  g \oplus 1 * \true}) \implies \mbox{}\\
\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true}
\end{multline}
for which it suffices to who that
\begin{multline}
\forall g,x,t,p.\, 
(\neg{\shareds{\LE[t] \mapsto g \oplus 1 * \true}} 
\since \shared{\LE[p] \mapsto g \oplus 2 * \true}) 
\implies \mbox{} \\
(\shareds{\cc\nmapsto x * \true}  
\since
\shareds{\LE[t] \mapsto  g \oplus 1 * \true}) \implies \mbox{}\\
\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true}
\end{multline}


At this point, we take advantage of the following temporal tautology
\begin{equation}
((A \since B) \land (\neg B \since C)) \implies (A \since C)
\end{equation}
To establish the above by showing that 
\begin{multline}
\forall g,x,p.\, 
(\shareds{\cc\nmapsto x * \true}  
\since
\shared{\LE[p] \mapsto g \oplus 2 * \true})
\implies \mbox{}\\
\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true}
\end{multline}
which is always true as $\oplus$ is $+$ modulo $3$.



%
%
%
%
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%We now use the following temporal tautology
%\begin{multline}
%x \not\in \textsf{FV}(A) \implies \mbox{}\\
%(A \since \forall x.\,B) \implies \forall x.\,(A \since B))\,,
%\end{multline}
%where $x \not\in \textsf{FV}(A)$ says that $x$ is not a free variable in $A$, to establish 
%the above using 
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x.\, (\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall p.\, \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%From here, we get that 
%
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\land \\
%(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%
%At this point, we take advantage of the following temporal tautology
%\begin{equation}
%((A \since B) \land (\neg B \since C)) \implies (A \since C)
%\end{equation}
%To establish the above by showing that 
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall j.\, \shared{\LE[j] \mapsto g \oplus 2}\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%which is always true as $\oplus$ is $+$ modulo $3$.








%\nr{It seems the global epoch is not actually needed in the reasoning below at all...}

%We will be using the shorthand
%\[
%\cc \nmapsto x \iff \exists y.\, y \neq x \land \cc \mapsto y
%\]
%to denote that $\cc$ points to a node in the heap, but the node does not contain the value $x$.
%
%We show that the reclamation in Line~\ref{pce-neg-contradiction} of \texttt{reclaim()}
%is safe, by deriving the following lemma:
%\begin{multline}
%\forall g,x,t,A,p.\, \shareds{\GE\mapsto g * \forall s.\, \LE[s] \mapsto g * \true} \implies \mbox{} \\
%\shareds{\rlist[t][g \oplus 1]\mapsto A * \true} \implies  
%\shareds{x \in A * \true} \implies \mbox{}\\
% \neg (\shared{\LE[p] \mapsto g * \true} \since \shared{\cc \mapsto x * \true})
%\end{multline}
%
%To do so, we use the following invariant, which says that a thread $t$ places a node $x$ that it
%detaches when its \emph{local} epoch is $g \oplus 1$ into the $g \oplus 1$ set
%at the $t$ entry of the $\rlist$ array, and does not put $x$ back into the shared state
%since being in that local epoch.
%
%\begin{multline}
%\Upsilon_2= \forall g,x,t,A .\, 
%\shareds{\rlist[t][g \oplus 1] \mapsto A  * \true} \implies \mbox{}
%\\
%\shareds{ x \in A * \true} \implies \mbox{} 
%\\ 
%(\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\end{multline}
%and the tautology
%\begin{equation}
%(\neg B \since \neg A) \implies \neg (A \since B)
%\end{equation}
%
%
%We establish the above by showing that
%
%\begin{multline}
%\forall g,x,t,A,p.\, \shareds{\GE\mapsto g * \forall s.\,\LE[s] \mapsto g * \true} 
%\implies \mbox{} \\
%(\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%(\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%We now use the following invariant, which is key. 
%The invariant holds because of the cyclic lock-step 
%way the counter is incremented
%(action $\textsf{NextEpoch}_t$). We use the non-emptyness of the 
%detached sets to exclude the first time a thread goes into an epoch.
%\begin{multline}
%\Upsilon_3 = \forall g,t.\, 
%\shareds{\LE[t] \mapsto g * \true} \implies 
%\mbox{}\\
%\shareds{\rlist[t] \nmapsto  \emptyset * \true} \implies \mbox{}
%\mbox{}\\ 
%(\shareds{\LE[t] \nmapsto g \oplus 1 * \true} 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}) 
%\end{multline}
%to establish the above by showing that
%
%\begin{multline}
%\forall g,x,t,A,p.\, 
%\Big(\shareds{\GE\mapsto g * \true} \land  \forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%We now use the following temporal tautology
%\begin{multline}
%x \not\in \textsf{FV}(A) \implies \mbox{}\\
%(A \since \forall x.\,B) \implies \forall x.\,(A \since B))\,,
%\end{multline}
%where $x \not\in \textsf{FV}(A)$ says that $x$ is not a free variable in $A$, to establish 
%the above using 
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x.\, (\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall p.\, \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%From here, we get that 
%
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\land \\
%(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%
%At this point, we take advantage of the following temporal tautology
%\begin{equation}
%((A \since B) \land (\neg B \since C)) \implies (A \since C)
%\end{equation}
%To establish the above by showing that 
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall j.\, \shared{\LE[j] \mapsto g \oplus 2}\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%which is always true as $\oplus$ is $+$ modulo $3$.
%

%
%We now use the following invariant, which is key. 
%The invariant holds because of the cyclic lock-step 
%way the counter is incremented
%(action $\textsf{NextEpoch}_t$). We use the non-emptyness of the 
%detached sets to exclude the first time a thread goes into an epoch.


%!TEX root = ./recycling.tex
%
% epoch-alt.tex
%
%\newcommand{\nmapsto}{\nmapsto}
%
%\cleardoublepage
%\subsection{Alternative Invariants for the Epoch Algorithm}
%
%\nr{It seems the global epoch is not actually needed in the reasoning below at all...}
%
%
%We will be using the shorthand
%\[
%\cc \nmapsto x \iff \exists y.\, y \neq x \land \cc \mapsto y
%\]
%to denote that $\cc$ points to a node in the heap, but the node does not contain the value $x$.
%
%We show that the reclamation in Line~\ref{pce-neg-contradiction} of \texttt{reclaim()}
%is safe, by deriving the following lemma:
%\begin{multline}
%\forall g,s.\, \shareds{\GE\mapsto g * \LE[s] \mapsto g * \true} \implies \mbox{} \\
%\forall x,t,A.\, \shareds{\rlist[t][g \oplus 1]\mapsto A \land x \in A * \true} \implies \mbox{}\\
%\forall p.\, \neg (\shared{\LE[p] \mapsto g * \true} \since \shared{\cc \mapsto x * \true})
%\end{multline}
%
%To do so, we use the following invariant, which says that a thread $t$ places a node $x$ that it
%detaches when its \emph{local} epoch is $g \oplus 1$ into the $g \oplus 1$ set
%at the $t$ entry of the $\rlist$ array, and does not put $x$ back into the shared state
%since being in that local epoch.
%
%\begin{multline}
%\Upsilon_{2}= \forall t,x,g,A .\, 
%\shareds{\rlist[t][g \oplus 1] \mapsto A  \land x \in A * \true})
%\\
%\mbox{} \implies 
%(\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[s] \mapsto  g \oplus 1 * \true})  
%\end{multline}
%and the tautologies
%\begin{equation}
%(\neg B \since \neg A) \implies \neg (A \since B)
%\end{equation}
%
%
%We establish the above by showing that
%
%\begin{multline}
%\forall g,s.\, \shareds{\GE\mapsto g * \LE[s] \mapsto g * \true} 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%We now use the following invariant, which is key. 
%The invariant holds because of the cyclic lock-step 
%way the counter is incremented
%(action $\textsf{NextEpoch}_t$):
%\begin{multline}
%\Upsilon_3 = \forall g,s.\, 
%\LE[s] \mapsto g \implies 
%\mbox{}
%(\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}) 
%\end{multline}
%to establish the above by showing that
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%We now use the following temporal tautology
%\begin{multline}
%x \not\in \textsf{FV}(A) \implies \mbox{}\\
%(A \since \forall x.\,B) \implies \forall x.\,(A \since B))\,,
%\end{multline}
%where $x \not\in \textsf{FV}(A)$ says that $x$ is not a free variable in $A$, to establish 
%the above using 
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x.\, (\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall p.\, \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%From here, we get that 
%
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\land \\
%(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%
%At this point, we take advantage of the following temporal tautology
%\begin{equation}
%((A \since B) \land (\neg B \since C)) \implies (A \since C)
%\end{equation}
%To establish the above by showing that 
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall j.\, \shared{\LE[j] \mapsto g \oplus 2}\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%which is always true as $\oplus$ is $+$ modulo $3$.
%
%

%
%\begin{figure*}
%\newcommand{\LE}{\textsf{LE}}
%\[
%\begin{array}{l}
%\Upsilon_{1} = 
%\forall t,x,l .\, 
%\shareds{\LE[t] \mapsto l * \true} \since \shareds{\cc \mapsto x * \true} 
%\implies 
%\shareds{x \mapsto_{\se} \_ * \true}
%\\
%\\
%\Upsilon_{2}=  
%\forall s,x,l,A .\, 
%(x \in A \land 
%\shareds{\textsf{detached}_{l}[s]\mapsto A * \detached(A) * \true})
%\implies 
%(\shareds{\exists y.\, y \neq x \land \cc\mapsto y * y \mapsto \_ * \true}  
%\since
%\shareds{\LE[s] \mapsto  l * \true})  
%\\
%\\
%\Upsilon_{3}=
%\forall m,n,s,t .\,
% (\shareds{\LE[t] \mapsto n * \true} 
%  \since 
%  \shareds{\LE[s] \mapsto m * \true}) 
%\implies
%(\shareds{\LE[s] \mapsto n * \true} \implies n = m \lor n = m \oplus 1)
%\\
%\\
%1.\ \shareds{\LE[t] \mapsto k * \true} \since \shareds{\cc \mapsto x * \true}
%     \land x \in \detached_{k \oplus 1}[s]  \land  \Upsilon_{2} 
%\implies 
%\shareds{\LE[t] \mapsto k * \true} \since  \shareds{\LE[s] \mapsto k\oplus1 * \true}
%\\
%\\
%2.\ \Upsilon_{3} \land \shareds{\LE[t] \mapsto k * \true} \since  \shareds{\LE[s] \mapsto k\oplus1 * \true}
%\implies 
%\false
%\\
%\\
%1.\ 
%x \in A \land 
%\shareds{\textsf{detached}_{k \oplus 1}[s]\mapsto A * \detached(A) * \true}, 
%\Upsilon_{2} 
%\vdash\\
%\qquad\qquad
%\shareds{\exists y.\, y \neq x \land \cc\mapsto y * y \mapsto \_ * \true}  
%\since
%\shareds{\LE[s] \mapsto  k \oplus 1 * \true}
%\\
%\\
%2.\
%\shareds{\LE[t] \mapsto k * \true} \since \shareds{\cc \mapsto x * \true} ,
%\shareds{\exists y.\, y \neq x \land \cc\mapsto y * y \mapsto \_ * \true}  
%\since
%\shareds{\LE[s] \mapsto  k \oplus 1 * \true}
%\vdash\\
%\qquad\qquad
%\shareds{\LE[t] \mapsto k * \true} \since 
%(\shareds{\LE[s] \mapsto  k \oplus 1 * \true} \land
%(\shareds{\LE[t] \mapsto k * \true} \since \shareds{C \mapsto x * \true})) 
%\vdash
%\\
%\qquad\qquad
%\shareds{\LE[t] \mapsto k * \true} 
%\since 
%\shareds{\LE[s] \mapsto  k \oplus 1 * \true} 
%\\
%\\
%3.\
%\shareds{\LE[t] \mapsto k * \true} \since \shareds{\LE[s] \mapsto  k \oplus 1 * \true}, \Upsilon_{3}
%\vdash 
%\false
%\end{array}
%\]
%\caption{Alternative assertions for EPOCH}
%\end{figure*} 

%%!TEX root = ./recycling.tex
%%
%% epoch-alt.tex
%
%\newcommand{\nmapsto}{\stackrel{{\scriptsize\neq}}{\mapsto}}
%
%\cleardoublepage
%\subsection{Alternative Invariants for the Epoch Algorithm}
%
%
%We will be using the shorthand
%\[
%\cc \nmapsto x \iff \exists y.\, y \neq x \land \cc \mapsto y
%\]
%to denote that $\cc$ points to a node in the heap, but the node does not contain the value $x$.
%
%We show that the reclamation in Line~\ref{pce-neg-contradiction} of \texttt{reclaim()}
%is safe, by deriving the following lemma:
%\begin{multline}
%\forall g,s.\, \shareds{\GE\mapsto g * \LE[s] \mapsto g * \true} \implies \mbox{} \\
%\forall x,t,A.\, \shareds{\rlist[t][g \oplus 1]\mapsto A \land x \in A * \true} \implies \mbox{}\\
%\forall p.\, \neg (\shared{\LE[p] \mapsto g * \true} \since \shared{\cc \mapsto x * \true})
%\end{multline}
%
%To do so, we use the following invariant, which says that a thread $t$ places a node $x$ that it
%detaches when its \emph{local} epoch is $g \oplus 1$ into the $g \oplus 1$ set
%at the $t$ entry of the $\rlist$ array, and does not put $x$ back into the shared state
%since being in that local epoch.
%
%\begin{multline}
%\Upsilon_{2}= \forall t,x,g,A .\, 
%\shareds{\rlist[t][g \oplus 1] \mapsto A  \land x \in A * \true})
%\\
%\mbox{} \implies 
%(\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[s] \mapsto  g \oplus 1 * \true})  
%\end{multline}
%and the tautologies
%\begin{equation}
%(\neg B \since \neg A) \implies \neg (A \since B)
%\end{equation}
%
%
%We establish the above by showing that
%
%\begin{multline}
%\forall g,s.\, \shareds{\GE\mapsto g * \LE[s] \mapsto g * \true} 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%We now use the following invariant, which is key. 
%The invariant holds because of the cyclic lock-step 
%way the counter is incremented
%(action $\textsf{NextEpoch}_t$).  We use the non-emptyness of the 
%detached sets to exclude the first time a thread goes into an epoch--Otherwise, the $\since$ clause 
%does not hold.
%\begin{multline}
%\Upsilon_3 = \forall g,s.\, 
%\shareds{\rlist[s] \nmapsto \emptyset * \true} \implies 
%\shareds{\LE[s] \mapsto g * \true} \implies 
%\mbox{}\\
%(\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{} 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}) 
%\end{multline}
%to establish the above by showing that
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%\since
%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%We now use the following temporal tautology
%\begin{multline}
%x \not\in \textsf{FV}(A) \implies \mbox{}\\
%(A \since \forall x.\,B) \implies \forall x.\,(A \since B))\,,
%\end{multline}
%where $x \not\in \textsf{FV}(A)$ says that $x$ is not a free variable in $A$, to establish 
%the above using 
%
%\begin{multline}
%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\implies \mbox{} \\
%\forall x.\, (\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall p.\, \shared{\LE[p] \nmapsto g * \true})
%\end{multline}
%
%From here, we get that 
%
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\Big(\shareds{\GE\mapsto g * \true} \land 
%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%\mbox{}\\ 
%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%\land \\
%(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%
%At this point, we take advantage of the following temporal tautology
%\begin{equation}
%((A \since B) \land (\neg B \since C)) \implies (A \since C)
%\end{equation}
%To establish the above by showing that 
%\begin{multline}
%\forall g.\, \forall x.\,\Big(\shareds{\cc\nmapsto x * \true}  
%\since  
%\forall j.\, \shared{\LE[j] \mapsto g \oplus 2}\Big)  
%\implies \mbox{}\\
%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%\end{multline}
%which is always true as $\oplus$ is $+$ modulo $3$.
%
%
%
%
%
%
%
%
%%\nr{It seems the global epoch is not actually needed in the reasoning below at all...}
%
%%We will be using the shorthand
%%\[
%%\cc \nmapsto x \iff \exists y.\, y \neq x \land \cc \mapsto y
%%\]
%%to denote that $\cc$ points to a node in the heap, but the node does not contain the value $x$.
%%
%%We show that the reclamation in Line~\ref{pce-neg-contradiction} of \texttt{reclaim()}
%%is safe, by deriving the following lemma:
%%\begin{multline}
%%\forall g,x,t,A,p.\, \shareds{\GE\mapsto g * \forall s.\, \LE[s] \mapsto g * \true} \implies \mbox{} \\
%%\shareds{\rlist[t][g \oplus 1]\mapsto A * \true} \implies  
%%\shareds{x \in A * \true} \implies \mbox{}\\
%% \neg (\shared{\LE[p] \mapsto g * \true} \since \shared{\cc \mapsto x * \true})
%%\end{multline}
%%
%%To do so, we use the following invariant, which says that a thread $t$ places a node $x$ that it
%%detaches when its \emph{local} epoch is $g \oplus 1$ into the $g \oplus 1$ set
%%at the $t$ entry of the $\rlist$ array, and does not put $x$ back into the shared state
%%since being in that local epoch.
%%
%%\begin{multline}
%%\Upsilon_2= \forall g,x,t,A .\, 
%%\shareds{\rlist[t][g \oplus 1] \mapsto A  * \true} \implies \mbox{}
%%\\
%%\shareds{ x \in A * \true} \implies \mbox{} 
%%\\ 
%%(\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\end{multline}
%%and the tautology
%%\begin{equation}
%%(\neg B \since \neg A) \implies \neg (A \since B)
%%\end{equation}
%%
%%
%%We establish the above by showing that
%%
%%\begin{multline}
%%\forall g,x,t,A,p.\, \shareds{\GE\mapsto g * \forall s.\,\LE[s] \mapsto g * \true} 
%%\implies \mbox{} \\
%%(\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%(\shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%We now use the following invariant, which is key. 
%%The invariant holds because of the cyclic lock-step 
%%way the counter is incremented
%%(action $\textsf{NextEpoch}_t$). We use the non-emptyness of the 
%%detached sets to exclude the first time a thread goes into an epoch.
%%\begin{multline}
%%\Upsilon_3 = \forall g,t.\, 
%%\shareds{\LE[t] \mapsto g * \true} \implies 
%%\mbox{}\\
%%\shareds{\rlist[t] \nmapsto  \emptyset * \true} \implies \mbox{}
%%\mbox{}\\ 
%%(\shareds{\LE[t] \nmapsto g \oplus 1 * \true} 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}) 
%%\end{multline}
%%to establish the above by showing that
%%
%%\begin{multline}
%%\forall g,x,t,A,p.\, 
%%\Big(\shareds{\GE\mapsto g * \true} \land  \forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\implies \mbox{} \\
%%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%
%%
%%\begin{multline}
%%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\implies \mbox{} \\
%%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%We now use the following temporal tautology
%%\begin{multline}
%%x \not\in \textsf{FV}(A) \implies \mbox{}\\
%%(A \since \forall x.\,B) \implies \forall x.\,(A \since B))\,,
%%\end{multline}
%%where $x \not\in \textsf{FV}(A)$ says that $x$ is not a free variable in $A$, to establish 
%%the above using 
%%
%%\begin{multline}
%%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\implies \mbox{} \\
%%\forall x.\, (\shareds{\cc\nmapsto x * \true}  
%%\since  
%%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%\shared{\cc \nmapsto x * \true} \since \forall p.\, \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%From here, we get that 
%%
%%\begin{multline}
%%\forall g.\, \forall x.\,\Big(\Big(\shareds{\GE\mapsto g * \true} \land 
%%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\land \\
%%(\shareds{\cc\nmapsto x * \true}  
%%\since  
%%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})\Big)  
%%\implies \mbox{}\\
%%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%%\end{multline}
%%
%%At this point, we take advantage of the following temporal tautology
%%\begin{equation}
%%((A \since B) \land (\neg B \since C)) \implies (A \since C)
%%\end{equation}
%%To establish the above by showing that 
%%\begin{multline}
%%\forall g.\, \forall x.\,\Big(\shareds{\cc\nmapsto x * \true}  
%%\since  
%%\forall j.\, \shared{\LE[j] \mapsto g \oplus 2}\Big)  
%%\implies \mbox{}\\
%%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%%\end{multline}
%%which is always true as $\oplus$ is $+$ modulo $3$.
%%
%
%%
%%We now use the following invariant, which is key. 
%%The invariant holds because of the cyclic lock-step 
%%way the counter is incremented
%%(action $\textsf{NextEpoch}_t$). We use the non-emptyness of the 
%%detached sets to exclude the first time a thread goes into an epoch.
%
%
%%!TEX root = ./recycling.tex
%%
%% epoch-alt.tex
%%
%%\newcommand{\nmapsto}{\nmapsto}
%%
%%\cleardoublepage
%%\subsection{Alternative Invariants for the Epoch Algorithm}
%%
%%\nr{It seems the global epoch is not actually needed in the reasoning below at all...}
%%
%%
%%We will be using the shorthand
%%\[
%%\cc \nmapsto x \iff \exists y.\, y \neq x \land \cc \mapsto y
%%\]
%%to denote that $\cc$ points to a node in the heap, but the node does not contain the value $x$.
%%
%%We show that the reclamation in Line~\ref{pce-neg-contradiction} of \texttt{reclaim()}
%%is safe, by deriving the following lemma:
%%\begin{multline}
%%\forall g,s.\, \shareds{\GE\mapsto g * \LE[s] \mapsto g * \true} \implies \mbox{} \\
%%\forall x,t,A.\, \shareds{\rlist[t][g \oplus 1]\mapsto A \land x \in A * \true} \implies \mbox{}\\
%%\forall p.\, \neg (\shared{\LE[p] \mapsto g * \true} \since \shared{\cc \mapsto x * \true})
%%\end{multline}
%%
%%To do so, we use the following invariant, which says that a thread $t$ places a node $x$ that it
%%detaches when its \emph{local} epoch is $g \oplus 1$ into the $g \oplus 1$ set
%%at the $t$ entry of the $\rlist$ array, and does not put $x$ back into the shared state
%%since being in that local epoch.
%%
%%\begin{multline}
%%\Upsilon_{2}= \forall t,x,g,A .\, 
%%\shareds{\rlist[t][g \oplus 1] \mapsto A  \land x \in A * \true})
%%\\
%%\mbox{} \implies 
%%(\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[s] \mapsto  g \oplus 1 * \true})  
%%\end{multline}
%%and the tautologies
%%\begin{equation}
%%(\neg B \since \neg A) \implies \neg (A \since B)
%%\end{equation}
%%
%%
%%We establish the above by showing that
%%
%%\begin{multline}
%%\forall g,s.\, \shareds{\GE\mapsto g * \LE[s] \mapsto g * \true} 
%%\implies \mbox{} \\
%%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%We now use the following invariant, which is key. 
%%The invariant holds because of the cyclic lock-step 
%%way the counter is incremented
%%(action $\textsf{NextEpoch}_t$):
%%\begin{multline}
%%\Upsilon_3 = \forall g,s.\, 
%%\LE[s] \mapsto g \implies 
%%\mbox{}
%%(\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}) 
%%\end{multline}
%%to establish the above by showing that
%%
%%\begin{multline}
%%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\implies \mbox{} \\
%%\forall x,t.\, (\shareds{\cc\nmapsto x * \true}  
%%\since
%%\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%\forall p.\, \shared{\cc \nmapsto x * \true} \since \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%We now use the following temporal tautology
%%\begin{multline}
%%x \not\in \textsf{FV}(A) \implies \mbox{}\\
%%(A \since \forall x.\,B) \implies \forall x.\,(A \since B))\,,
%%\end{multline}
%%where $x \not\in \textsf{FV}(A)$ says that $x$ is not a free variable in $A$, to establish 
%%the above using 
%%
%%\begin{multline}
%%\forall g.\, \Big(\shareds{\GE\mapsto g * \true} \land 
%%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\implies \mbox{} \\
%%\forall x.\, (\shareds{\cc\nmapsto x * \true}  
%%\since  
%%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})  
%%\implies \mbox{}\\
%%\shared{\cc \nmapsto x * \true} \since \forall p.\, \shared{\LE[p] \nmapsto g * \true})
%%\end{multline}
%%
%%From here, we get that 
%%
%%\begin{multline}
%%\forall g.\, \forall x.\,\Big(\Big(\shareds{\GE\mapsto g * \true} \land 
%%\forall s.\,\shareds{\LE[s] \nmapsto g \oplus 1 * \true} 
%%\mbox{}\\ 
%%\since \forall j.\, \shared{\LE[j] \mapsto g \oplus 2 * \true}\Big) 
%%\land \\
%%(\shareds{\cc\nmapsto x * \true}  
%%\since  
%%\forall t.\shareds{\LE[t] \mapsto  g \oplus 1 * \true})\Big)  
%%\implies \mbox{}\\
%%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%%\end{multline}
%%
%%At this point, we take advantage of the following temporal tautology
%%\begin{equation}
%%((A \since B) \land (\neg B \since C)) \implies (A \since C)
%%\end{equation}
%%To establish the above by showing that 
%%\begin{multline}
%%\forall g.\, \forall x.\,\Big(\shareds{\cc\nmapsto x * \true}  
%%\since  
%%\forall j.\, \shared{\LE[j] \mapsto g \oplus 2}\Big)  
%%\implies \mbox{}\\
%%\shared{\cc \nmapsto x * \true} \since \forall s.\, \shared{\LE[s] \nmapsto g * \true})
%%\end{multline}
%%which is always true as $\oplus$ is $+$ modulo $3$.
%%
%%
%
%%
%%\begin{figure*}
%%\newcommand{\LE}{\textsf{LE}}
%%\[
%%\begin{array}{l}
%%\Upsilon_{1} = 
%%\forall t,x,l .\, 
%%\shareds{\LE[t] \mapsto l * \true} \since \shareds{\cc \mapsto x * \true} 
%%\implies 
%%\shareds{x \mapsto_{\se} \_ * \true}
%%\\
%%\\
%%\Upsilon_{2}=  
%%\forall s,x,l,A .\, 
%%(x \in A \land 
%%\shareds{\textsf{detached}_{l}[s]\mapsto A * \detached(A) * \true})
%%\implies 
%%(\shareds{\exists y.\, y \neq x \land \cc\mapsto y * y \mapsto \_ * \true}  
%%\since
%%\shareds{\LE[s] \mapsto  l * \true})  
%%\\
%%\\
%%\Upsilon_{3}=
%%\forall m,n,s,t .\,
%% (\shareds{\LE[t] \mapsto n * \true} 
%%  \since 
%%  \shareds{\LE[s] \mapsto m * \true}) 
%%\implies
%%(\shareds{\LE[s] \mapsto n * \true} \implies n = m \lor n = m \oplus 1)
%%\\
%%\\
%%1.\ \shareds{\LE[t] \mapsto k * \true} \since \shareds{\cc \mapsto x * \true}
%%     \land x \in \detached_{k \oplus 1}[s]  \land  \Upsilon_{2} 
%%\implies 
%%\shareds{\LE[t] \mapsto k * \true} \since  \shareds{\LE[s] \mapsto k\oplus1 * \true}
%%\\
%%\\
%%2.\ \Upsilon_{3} \land \shareds{\LE[t] \mapsto k * \true} \since  \shareds{\LE[s] \mapsto k\oplus1 * \true}
%%\implies 
%%\false
%%\\
%%\\
%%1.\ 
%%x \in A \land 
%%\shareds{\textsf{detached}_{k \oplus 1}[s]\mapsto A * \detached(A) * \true}, 
%%\Upsilon_{2} 
%%\vdash\\
%%\qquad\qquad
%%\shareds{\exists y.\, y \neq x \land \cc\mapsto y * y \mapsto \_ * \true}  
%%\since
%%\shareds{\LE[s] \mapsto  k \oplus 1 * \true}
%%\\
%%\\
%%2.\
%%\shareds{\LE[t] \mapsto k * \true} \since \shareds{\cc \mapsto x * \true} ,
%%\shareds{\exists y.\, y \neq x \land \cc\mapsto y * y \mapsto \_ * \true}  
%%\since
%%\shareds{\LE[s] \mapsto  k \oplus 1 * \true}
%%\vdash\\
%%\qquad\qquad
%%\shareds{\LE[t] \mapsto k * \true} \since 
%%(\shareds{\LE[s] \mapsto  k \oplus 1 * \true} \land
%%(\shareds{\LE[t] \mapsto k * \true} \since \shareds{C \mapsto x * \true})) 
%%\vdash
%%\\
%%\qquad\qquad
%%\shareds{\LE[t] \mapsto k * \true} 
%%\since 
%%\shareds{\LE[s] \mapsto  k \oplus 1 * \true} 
%%\\
%%\\
%%3.\
%%\shareds{\LE[t] \mapsto k * \true} \since \shareds{\LE[s] \mapsto  k \oplus 1 * \true}, \Upsilon_{3}
%%\vdash 
%%\false
%%\end{array}
%%\]
%%\caption{Alternative assertions for EPOCH}
%%\end{figure*} 