\section{Related Work\label{sec:relwork}}

Out of the three techniques for memory reclamation that we consider in this
paper, only restricted versions of the non-blocking stack with hazard pointers
that we handle in \tr{\ref{sec:ProofsHazard}}{\nhazard} have been verified: in
concurrent separation logic~\cite{parkinson-hazard}, a combination of separation
logic and temporal logic~\cite{hazard-feng}, a reduction-based
tool~\cite{turkish} and interval temporal logic~\cite{kiv}. These papers use
different reasoning methods from the one we propose, none of which has been
grounded in a pattern common to different algorithms.

%As a consequence, the resulting proofs do not illuminate the main idea of the
%algorithms. In contrast, we have been able to explicate the fundamental pattern
%in the design of different reclamation algorithms and to exploit it to achieve
%simple proofs.

Among the above-mentioned verification efforts, the closest to us technically
is the work by Fu et al.~\cite{hazard-feng}, which proposed a combination of
separation logic and temporal logic very similar to the one we use for
formalising our method.
%(in particular, their logic includes the {\sf since} connective, among many
%other temporal ones).
We emphasise that we do not consider the logic we present in \S\ref{sec:logic}
as the main contribution of this paper, but merely as a {\em tool} for
formalising our reasoning method.
%It is the cleanness and generality
%of this method that distinguishes this paper from prior proposals. 
%In contrast,
It is this method that is the main difference of our work in comparison to Fu et
al.  The method used by Fu et al. to verify a non-blocking stack with hazard
pointers leads to a complicated proof that embeds a lot of implementation detail
into its invariants and rely/guarantee conditions. In contrast, our proofs are
conceptually simple and technically straightforward, due to the use of a strategy
that captures the essence of the algorithms considered. Fu et al. also handle
only an idealistic implementation of hazard pointers, where deallocations are
not batched, and many assertions in the proof inherently rely on this
simplification. We do not think that their proof would scale easily to the
implementation that batches deallocations (\S\ref{sec:informal}), let alone
other extensions we consider \tr{\ref{sec:ProofsHazard}}{\nhazard}.
 
Having said that, we fully acknowledge the influence of the work by Fu et al.
In particular, we agree that a combination of temporal and separation logics
provides a useful means of reasoning about non-blocking algorithms. We hope that
our %identification and 
formalisation of powerful proof patterns in such a
combined logic will motivate verification researchers to adopt the pattern-based
approach in verifying other complex concurrent algorithms.

%We also hope that our general approach of explicating synchronisation patterns
%by identifying forms of key assertions in the proofs of algorithms can be reused
%in the design and verification of other 

%A limitation of our results is that our proofs are only sound with respect to an
%interleaving semantics, which is inadequate for modern multiprocessors with weak
%memory models. Lifting it presents an interesting direction of future work.

%An interesting research direction is to integrate our logic with
%the existing ones for reasoning on weak memory~\cite{ridge,josh}.

%We believe that it should be possible to integrate our logic with
%the existing ones for reasoning on weak memory~\cite{ridge,josh} without
%major problems.

%Our preliminary investigations show that the reasoning principle we proposed is
%applicable to algorithms using grace periods for purposes other than memory
%reclamation. For example, we already have semi-formal proofs of algorithms that
%use RCU to ensure linearizability of operations on concurrent hash
%tables~\cite{hashtable} and concurrent red-black trees~\cite{rbtree}.

%%% Local Variables:
%%% TeX-master: "recycling"
%%% End:  
%!TEX root = ./recycling.tex
