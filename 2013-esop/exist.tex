\subsection{Existential permissions\label{sec:exist}} 

In our examples we use a particular instantiation of the abstract logic
presented in Section~\ref{sec:logic}, choosing separation algebras $\State$ with
appropriate kinds of permissions. As we explained in Section~\ref{sec:informal},
in algorithms using RCU for memory reclamation, a reader can be viewed as taking
out permissions from the shared state preventing certain memory cells from being
deallocated during a read section. In this section we present a variant of the
well-known existential counting permissions used in this case.

We define the following separation algebra $\RAM_{\sf e}$, extending the $\RAM$
algebra of Section~\ref{sec:setting}:
$$
\Loc = \{1, 2, \ldots\};
\quad 
\Val = \mathbb{Z};
\quad
\RAM_{\sf e} = \Loc \rightharpoonup_{\it fin} (\{0, 1, \ldots\} \times \Val) \uplus
\{-1, -2, \ldots\}.
$$
States from $\RAM_{\sf e}$ have allocated memory locations annotated not only
with their values in $\Val$, but with permissions, which restrict the types of
operations that a thread can perform on the given location in the state. The
permission $0$ is the {\em full} permission: it allows a thread to read, write
and deallocate the corresponding cell. A full permission can be split into a
{\em master} permission and several {\em existential} ones, each of which can be
given to a separate thread. The master permission gives the right to read and
write the cell, but not to deallocate it. In the model it is represented by a
positive number, equal to the number of existential permissions issued.  An
existential permission guarantees that the cell is not going to be deallocated
and gives the right to read it, but does not guarantee its value, since another
thread can be concurrently writing to the cell using its master permission. A
single existential permission is represented in the model as $-1$, and several
such permissions combined together, with negative numbers; the value component is
missing in this case.

Informally, the full permission $0$ can be split into two existential permissions $-1$
and one master permission $2$. The former ones can be used by two readers to
access the cell while guaranteeing safety, and the latter one by a single writer
to write to the cell. The two existential permissions can later be recombined
into a single one $-2$, which can finally be combined with the master permission
$2$ to yield a full permission $0$, allowing the cell to be deallocated. The $*$
operation on $\RAM_{\sf e}$ is defined following this intuition. First, we
define it on $(\{0, 1, \ldots\} \times \Val) \uplus
\{-1, -2, \ldots\}$:
$$
\begin{array}{c@{\quad}l}
{-\pi_1} * {-\pi_2} = -(\pi_1+\pi_2), &\mbox{if } \pi_1, \pi_2 > 0;
\\
(\pi_1, u) * {-\pi_2} = {-\pi_2} * (\pi_1, u) = (\pi_1-\pi_2, u), &
\mbox{if } \pi_1, \pi_2 > 0, \pi_1 \ge \pi_2;
\end{array}
$$
undefined in all other cases. We then define a relation $\sharp$ on states in
$\RAM_{\sf e}$ showing when two states are compatible:
$$
\theta_0 \mathop{\sharp} \theta_1 \Longleftrightarrow
\forall i \in \{0, 1\}.\, {\theta_i(x) \fdef} \Rightarrow 
{\theta_{1-i}(x) \fundef} \vee {(\theta_i(x) * \theta_{1-i}(x)) \fdef}.
$$
Two states are compatible if they do not make contradictory permissions claims
on some memory location. Finally, the $*$ operation on states just adds up
permissions for corresponding locations:
\begin{multline*}
\theta_0 * \theta_1 = \{(x, w) \mid 
\exists i \in \{0, 1\}.\, {\theta_i(x) \fdef} \wedge{}\\
(({\theta_{1-i}(x) \fundef} \wedge w = \theta_i(x)) \vee 
({\theta_{1-i}(x) \fdef} \wedge w = \theta_i(x) * \theta_{1-i}(x)))
\},
\end{multline*}
if $\theta_0 \mathrel{\sharp} \theta_1$; undefined otherwise. Thus, the unit
element of the algebra is the nowhere-defined function $[\,]$.

To denote elements of $\RAM_{\sf e}$, we extend the assertion
language for predicates over states given in Section~\ref{sec:logic} as follows:
$
p ::=  \ldots \mid E \xmapsto{G}_{\sf e} F \mid E \xhookrightarrow{G}_{\sf e} \_
$,
where $E, F, G$ range over expressions.  Here $E \xmapsto{0}_{\sf e} F$ denotes a full
permission, $E \xmapsto{G}_{\sf e} F$ for $G>0$, a master permission, and $E
\xhookrightarrow{G}_{\sf e} \_$, several existential permissions:
$$
\begin{array}{lcl@{\qquad}l}
(\theta, \intp) \models E \xmapsto{G}_{\sf e} F &\Longleftrightarrow &\theta =
[\db{E}_{\intp} : (\db{G}_\intp, \db{F}_{\intp})],&\db{G}_\intp \ge 0;\\
(\theta, \intp) \models E \xhookrightarrow{G}_{\sf e} \_ &\Longleftrightarrow & \theta =
[\db{E}_{\intp} : -\db{G}_\intp],&\db{G}_\intp > 0;\\
(\theta, \intp) \models E \xhookrightarrow{0}_{\sf e} \_ &\Longleftrightarrow
& \theta = [\,],
\end{array}
$$
where $\db{E}_{\intp}$ denotes the result of evaluating the expression
$E$ with respect to an interpretation $\intp$. For uniformity, we allow the
assertion $E \xhookrightarrow{0}_{\sf e} \_$, which denotes an empty state.
% We also use an iterated $*$ operation: $\bigast_{i=1}^n P_i = P_1 * \ldots *
% P_n$, so that $\bigast_{i=1}^n E \hookrightarrow_{\sf e} \_$ represents $n$ existential
% permissions for the cell at the address $E$.
Let $E \mapsto F$ be syntactic sugar for $E \xmapsto{0}_{\sf e} F$ and $E
\hookrightarrow_{\sf e} \_$ for $E \xhookrightarrow{1}_{\sf e} \_$.  In the case
of a structure taking two adjacent memory cells, we write $E \mapsto F, F'$ for
$E \mapsto F * (E+\textit{off}) \mapsto F'$, where {\it off} is the offset of
the second field in the structure. We use the same notation for other kinds
predicates introduced above.

Due to space constraints, transformers and axioms for standard primitive
commands over $\RAM_{\sf e}$ are given in Appendix~\ref{app:formal}. Informally,
disposing a cell requires the full permission, reading it, a master or an
existential permission, and writing to it, a master permission. When a thread
allocates a cell, it gets it with the full permission. Reading from a cell with
an existential permission produces an arbitrary value.

%%% Local Variables:
%%% TeX-master: "rcu"
%%% End:  
