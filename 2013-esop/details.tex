
\begin{figure*}
\begin{small}  
\[
\begin{array}{c}
\begin{array}{l}
\tau_{\Upsilon}(z,t)
=
((\shared{\HP[t]\mapsto z * \true} \since \shared{\cc\mapsto z * \true}) 
\implies 
\shared{z \mapsto_{\se} \_ * \true})
%
\\[2pt]
%  
H = \exists y.\,\cc \mapsto y * y \mapsto \_ *  \bigast\nolimits_{i=0}^\nthreads \HP[i] \mapsto \_ * \true
\\[2pt]
%
I = \exists y.\,\cc \mapsto y * y \mapsto \_ * H * \true
\end{array}

\\[20pt]

\infer[\textsc{Disj}]
{
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  *
  ( 
  I
  \land
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  )
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p = y 
  \land
  p \mapsto_m \_  
  * 
  (
  I
  \land
  (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
  \land
  (\neg \parans{\cc \mapsto z * \true} \lor \parans{z \mapsto_{\se} \_ * \true})
  )
  \}
\end{array}
}
{
\begin{array}{c}
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  z = x 
  \land
  x \mapsto \_  
  *
  ( 
  I
  \land
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  )
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p = y 
  \land
  p \mapsto_m \_  
  * 
  (
  I
  \land
  (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
  \land
  \parans{z \mapsto_{\se} \_ * \true}
  )
  \}
\end{array}
\\[10pt]
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  z \neq x 
  \land
  x \mapsto \_  
  *
  ( 
  I
  \land
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  )
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p = y 
  \land
  p \mapsto_m \_  
  * 
  (
  I
  \land
  (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
  \land
  \neg \parans{\cc \mapsto z * \true} 
  )
  \}
\end{array}
\end{array}
}


\\[20pt]

\infer[\textsc{Disj, Conseq}]
{
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  *
  ( 
  I
  \land
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (\neg\parans{\HP[t]\mapsto z * \true} 
   \lor (\parans{\HP[t]\mapsto z*\true} \land \neg\parans{\cc \mapsto z * \true}))
  )
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p = y 
  \land
  p \mapsto_m \_  
  * 
  (
  I
  \land
  (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
  \land
  ((\parans{\HP[t]\mapsto z * \true} \land  \parans{\cc \mapsto z * \true}) \implies \parans{z \mapsto_{\se} \_ * \true})
  )
  \}
\end{array}
}
{
\begin{array}{c}
\begin{array}{c}
    \emptyset,\emptyset,\true \vdash \{
    V \Vdash 
    x \mapsto \_  
    *
    ( 
    I
    \land
    \parans{\cc \mapsto y * y \mapsto \_ * X}
    \land
    \neg\parans{\HP[t]\mapsto z * \true} 
    )
    \}
    \\
    \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
    %\qquad\qquad\qquad\qquad
    \{
    V \Vdash 
    p = y 
    \land
    p \mapsto_m \_  
    * 
    (
    I
    \land
    (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
    \land
    \neg\parans{\HP[t]\mapsto z * \true}
    )
    \}
\end{array}
\\[10pt]
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  *
  ( 
  I
  \land
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  )
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p = y 
  \land
  p \mapsto_m \_  
  * 
  (
  I
  \land
  (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
  \land
  (\neg \parans{\cc \mapsto z * \true} \lor \parans{z \mapsto_{\se} \_ * \true})
  )
  \}
\end{array}
\end{array}
}
\\[20pt]

\infer[\textsc{Conseq}]
{
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  * 
  (
  I
  \land 
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (z \mapsto_{\se} \_ * \true)
  ) 
  \}
  \\
  \,\mathtt{CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash
  p = y
  \land
  p \mapsto_m \_   
  * 
  (
  I
  \land 
  \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
  \land
  \parans{z \mapsto_{\se} \_ * \true}
  )
  \}
\end{array}
}
{
\infer[\textsc{Disj, Conseq}]
{
\begin{array}{c}
y \mapsto \_ \implies y\mapsto_{\se}\_ * y\mapsto_{\sm}\_  
\\[2pt]
\begin{array}{c}
    \emptyset,\emptyset,\true \vdash \{
    V \Vdash 
    x \mapsto \_  
    * 
    (
    I
    \land 
    \parans{\cc \mapsto y * y \mapsto \_ * X}
    \land
    (z \mapsto_{\se} \_ * \true)
    ) 
    \}
    \\
    \,\mathtt{CAS(\&C, p, x)}\,\\
    %\qquad\qquad\qquad\qquad
    \{
    V \Vdash
    p = y
    \land
    p \mapsto_m \_   
    * 
    (
    I
    \land 
    \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
    \land
    \parans{z \mapsto_{\se} \_ * \true}
    )
    \}
\end{array}
\end{array}
}
{
\begin{array}{c}
\begin{array}{c}
    \emptyset,\emptyset,\true \vdash \{
    V \Vdash 
    z = y
    \land
    x \mapsto \_  
    * 
    (
    I
    \land
    \parans{\cc \mapsto y * (y \mapsto \_ \land (z \mapsto_{\se} \_ * z \mapsto_{\sm} \_)) * X}
    ) 
    \}
    \\
    \,\mathtt{CAS(\&C, p, x)}\,\\
    %\qquad\qquad\qquad\qquad
    \{
    V \Vdash
    p = y
    \land
    p \mapsto_m \_   
    * 
    (
    I
    \land 
    \parans{\cc \mapsto x * x \mapsto \_ * (y \mapsto_{\se} \_ \land z \mapsto_{\se} \_) * X}
    )
    \}
\end{array}
\\[10pt] 
\begin{array}{c}
    \emptyset,\emptyset,\true \vdash \{
    V \Vdash 
    z \neq y 
    \land
    x \mapsto \_  
    * 
    (
    I
    \land
    \parans{\cc \mapsto y * y \mapsto \_ * (X \land (z \mapsto_{\se} \_ * \true))}
    ) 
    \}
    \\
    \,\mathtt{CAS(\&C, p, x)}\,\\
    %\qquad\qquad\qquad\qquad
    \{
    V \Vdash
    p = y
    \land
    p \mapsto_m \_   
    * 
    (
    I
    \land 
    \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * (X \land (z \mapsto_{\se} \_ * \true))}
    )
    \}
\end{array}
\end{array}
}
}
\\[20pt]

\infer[\textsc{Conseq}]
{
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  * 
  (
  I
  \land 
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (\HP[t] \mapsto z * \true) 
  \land
  (z \mapsto_{\se} \_ * \true)
  ) 
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash
  p = y
  \land
  p \mapsto_m \_   
  * 
  (
  I
  \land 
  \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
  \land
  (\neg\parans{\HP[t]\mapsto z * \true} \lor \parans{z \mapsto_{\se} \_ * \true})
  )
  \}
\end{array}
}
{
\infer[\textsc{Frame, Seq}]
{
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  * 
  (
  I
  \land 
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (z \mapsto_{\se} \_ * \true)
  ) 
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash
  p = y
  \land
  p \mapsto_m \_   
  * 
  (
  I
  \land 
  \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
  \land
  \parans{z \mapsto_{\se} \_ * \true}
  )
  \}
\end{array}
}
{
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{ V \Vdash \cc \mapsto y \} 
  \,\mathtt{assume(C=p)}\, 
  \emptyset,\emptyset,\true \vdash\{ V \Vdash \cc \mapsto y \land p = y\}
\\[2pt]
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  * 
  (
  I
  \land 
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (z \mapsto_{\se} \_ * \true)
  ) 
  \}
  \\
  \,\mathtt{CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash
  p = y
  \land
  p \mapsto_m \_   
  * 
  (
  I
  \land 
  \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
  \land
  \parans{z \mapsto_{\se} \_ * \true}
  )
  \}
\end{array}
\end{array}
}
}
\\[20pt]

\infer[\textsc{Inv, Shared-R, Conseq}]
{
\begin{array}{l}
R,G,\Upsilon \vdash 
\{
V \Vdash x \mapsto \_  \land \shareds{I}
\}
\,\langle\mathtt{assume(C=p); CAS(\&C, p, x)}\rangle_{\textsf{Inc}}\, 
\{
V \Vdash p \mapsto_m \_  \land \shared{I} \land \shared{p \mapsto_{\se} * \true}
\}
\end{array}
}
{
\infer[\textsc{Exists}_{1,2}]
{
\begin{array}{l}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash x \mapsto \_  
  \land 
  \shareds{I}
  \land
  \shareds{\exists X,x.\, \cc \mapsto y * y \mapsto \_ * X}
  \land
  \forall z,t.\,\tau_{\Upsilon}(z,t) 
  \}
  \,\langle\mathtt{assume(C=p); CAS(\&C, p, x)}\rangle_{\textsf{Inc}}\,\\
  \qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p \mapsto_m \_  
  \land 
  \shareds{I}
  \land
  \shareds{\exists X,x.\, \cc \mapsto x * x \mapsto \_ * p \mapsto_{\se} \_ * X}
  \land
  \forall z,t.\,\tau_{\Upsilon}(z,t) 
  \}
\end{array}
}
{
\infer[\textsc{Conseq}]
{
\begin{array}{l}
  \emptyset,\emptyset,\true \vdash \{
   V \Vdash 
   x \mapsto \_  
   \land 
   \shareds{I}
   \land
   \shareds{\cc \mapsto y * y \mapsto \_ * X}
   \land
   \tau_{\Upsilon}(z,t) 
   \}
   \,\langle\mathtt{assume(C=p); CAS(\&C, p, x)}\rangle_{\textsf{Inc}}\,\\
   \qquad\qquad\qquad\qquad
   \{
   V \Vdash 
   p \mapsto_m \_  
   \land 
   \shareds{I}
   \land
   \shareds{\cc \mapsto x * x \mapsto \_ * p \mapsto_{\se} \_ * X}
   \land
   \tau_{\Upsilon}(z,t) 
   \}
\end{array}
}
{
\infer[\textsc{Shared-I}]
{
\begin{array}{l}
  \emptyset,\emptyset,\true \vdash \{
   V \Vdash x \mapsto \_  
   \land 
   \shareds{I}
   \land
   \shareds{\cc \mapsto y * y \mapsto \_ * X}
   \land
   \tau_{\Upsilon}(z,t) 
   \}
   \,\langle\mathtt{assume(C=p); CAS(\&C, p, x)}\rangle_{\textsf{Inc}}\,\\
   \qquad\qquad\qquad\qquad
   \{
   V \Vdash 
   p \mapsto_m \_     
   \land 
   \shareds{I}
   \land
   p = y 
   \land    
   \shareds{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
   \land
   \tau_{\Upsilon}(z,t) 
   \}
\end{array}
}
{
\begin{array}{c}
\textsc{Inc} = 
\cc \mapsto y * y \mapsto \_ * X
\leadsto 
\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X  
\\[2pt]  
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  *
  ( 
  I
  \land
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (\neg\parans{\HP[t]\mapsto z * \true} 
   \lor (\parans{\HP[t]\mapsto z*\true} \land \neg\parans{\cc \mapsto z * \true}))
  )
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash 
  p = y 
  \land
  p \mapsto_m \_  
  * 
  (
  I
  \land
  (\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X)
  \land
  ((\parans{\HP[t]\mapsto z * \true} \land  \parans{\cc \mapsto z * \true}) \implies \parans{z \mapsto_{\se} \_ * \true})
  )
  \}
\end{array}
\\[6pt]
\begin{array}{c}
  \emptyset,\emptyset,\true \vdash \{
  V \Vdash 
  x \mapsto \_  
  * 
  (
  I
  \land 
  \parans{\cc \mapsto y * y \mapsto \_ * X}
  \land
  (\HP[t] \mapsto z * \true) 
  \land
  (z \mapsto_{\se} \_ * \true)
  ) 
  \}
  \\
  \,\mathtt{assume(C=p); CAS(\&C, p, x)}\,\\
  %\qquad\qquad\qquad\qquad
  \{
  V \Vdash
  p = y
  \land
  p \mapsto_m \_   
  * 
  (
  I
  \land 
  \parans{\cc \mapsto x * x \mapsto \_ * y \mapsto_{\se} \_ * X}
  \land
  (\neg\parans{\HP[t]\mapsto z * \true} \lor \parans{z \mapsto_{\se} \_ * \true})
  )
  \}
\end{array}
\end{array}
}}}}

\end{array}
\]
\end{small}
\caption{\label{fig:hazard:inc}Formal derivation of the proof of the \texttt{inc()} action.
Note that we prove the assertion without the since clause.
We need the since clause only for showing linearizability.}
\end{figure*}

%     (*$\{V \Vdash x \mapsto \_ * F_{\tid} \land \shareds{H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true} \land {}$*)             
%     (*$\quad (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\cc \mapsto p * p \mapsto \_ * \true}) \land {}$*)
%     (*$\quad \shareds{p \mapsto_e \_ * \true} \}$*)
%   } while ((*$\langle$*)CAS(&C, p, x)(*$\rangle_{\textsf{Inc}}$*));
%   (*$\{V \Vdash p \mapsto_m \_ * F_{\tid} \land {} $*)
%   (*$\quad 
% \shareds{H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true} \land \shareds{p \mapsto_e \_ * \true} \}$*)


\begin{figure}
\Tree 
[.{$I \land \neg (\HP[t]\mapsto x * \true)$} 
  [.{$t \neq tid$} 
    {$\HP[t]\mapsto h_t \neq x$} 
  ] 
  [.{$t = tid$} 
    [.{$p \neq x$}
        {$\HP[t] \mapsto p \neq x$}
    ]
    [.{$p=x$}
      [.{$y \neq x$}
        {$\cc \mapsto y \neq x$}
      ]
      [.{$y = x$}
        {$\cc \mapsto y = x$}
      ]
    ]
  ]
]
\caption{The  case analysis done in action HP - first premise.}
\end{figure}

\begin{figure*}
\begin{small}  
\[
\begin{array}{c}
\begin{array}{l}
\tau_{\Upsilon}(x,t)
=
((\shared{\HP[t]\mapsto x * \true} \since \shared{\cc\mapsto x * \true}) 
\implies 
\shared{x \mapsto_{\se} \_ * \true})
%
\\[2pt]
%  
H = \exists y.\,\cc \mapsto y * y \mapsto \_ *  \bigast\nolimits_{i=0}^\nthreads \HP[i] \mapsto \_ * \true
\\[2pt]
%
I = \exists y.\,\cc \mapsto y * y \mapsto \_ * H * \true
\end{array}

\\[20pt]

\infer[\textsc{Conseq, Exists}_1]
{
\begin{array}{c}
\emptyset,\emptyset,\true \vdash 
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land  \neg\parans{\HP[t]\mapsto x * \true}  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto p * X)  \land 
((\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true}) 
 \implies 
 \parans{x \mapsto_{\se} \_ * \true})
\}
\end{array}
}
{
\infer[\textsc{Disj, Conseq}]
{
\begin{array}{c}
\emptyset,\emptyset,\true \vdash 
\{ 
(\cc \mapsto y * y \mapsto \_ * H * \true) \land (\HP[\tid] \mapsto \_ * X) \land  \parans{h_t \neq x \land \HP[t]\mapsto h_t * \true}  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto p * X)  \land 
((\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true}) 
 \implies 
 \parans{x \mapsto_{\se} \_ * \true})
\}
\end{array}
}
{
\begin{array}{l}
%
% t != tid
%
\begin{array}{c}
\emptyset,\emptyset,\true \vdash 
\{ 
t \neq \tid \land (\cc \mapsto y * y \mapsto \_ * H * \true) \land (\HP[\tid] \mapsto \_ * X) \land  
 \parans{h_t \neq x \land \HP[t]\mapsto h_t * \true}  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto p * X)  \land \neg \parans{\HP[t]\mapsto x * \true} 
\}
\end{array}
%
% t = tid & p \neq x 
%
\\[2pt]
\begin{array}{c}
\emptyset,\emptyset,\true \vdash 
\{ 
t = \tid \land p \neq x \land
(\cc \mapsto y * y \mapsto \_ * H * \true) \land (\HP[\tid] \mapsto \_ * X)   
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto p * X)   \land \neg \parans{\HP[t]\mapsto x * \true} 
\}
\end{array}
%
% t = tid & p = x & y \neq x 
%
\\[2pt]
\begin{array}{c}
\emptyset,\emptyset,\true \vdash 
\{ 
t = \tid \land p = x \land y \neq x \land 
(\cc \mapsto y * y \mapsto \_ * H * \true) \land (\land \HP[\tid] \mapsto \_ * X)   
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
(\cc \mapsto y * y \mapsto \_ * H * \true) \land (\HP[\tid] \mapsto p * X)   \land \neg \parans{\cc \mapsto x * \true} 
\}
\end{array}
%
% t = tid & p = x & y = x 
%
\\[2pt]
\begin{array}{c}
\emptyset,\emptyset,\true \vdash 
\{ 
t = \tid \land p = x \land y = x \land 
(\cc \mapsto y * y \mapsto \_ * H * \true) \land (\HP[\tid] \mapsto \_ * X)  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
(\cc \mapsto y * y \mapsto \_ * H * \true) \land (\HP[\tid] \mapsto p * X)  \land 
\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true} 
 \land
 \parans{x \mapsto_{\se} \_ * \true} 
\}
\end{array}\end{array}
}}
\\[20pt]

\infer[\textsc{Conseq, Disj}]
{
\begin{array}{l}
  \emptyset,\emptyset,\true \vdash 
  \{ 
  I \land (\HP[\tid] \mapsto \_ * X) \land (\neg\parans{\HP[t]\mapsto x * \true} \lor (\parans{\HP[t]\mapsto x * \true} \land \neg\parans{\cc\mapsto x * \true}))  
  \} 
  \, \mathtt{HP[tid()] =p } 
  \\[2pt]
  \qquad\qquad\qquad\qquad
  \{ 
  I \land (\HP[\tid] \mapsto \_ * X) \land \parans{\HP[\tid]\mapsto p * \true} \land 
  ((\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true}) 
   \implies 
   \parans{x \mapsto_{\se} \_ * \true})
  \}
\end{array}
}
{
\begin{array}{l}
\emptyset,\emptyset,\true \vdash 
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land  \neg\parans{\HP[t]\mapsto x * \true}  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto p * X)  \land 
((\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true}) 
 \implies 
 \parans{x \mapsto_{\se} \_ * \true})
\}
\\[4pt]
\emptyset,\emptyset,\true \vdash 
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land  \parans{\HP[t]\mapsto x * \true} \land \neg \parans{\cc\mapsto x * \true}  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto p * X) \land   
\neg \parans{\cc\mapsto x * \true}
% ((\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true}) 
%  \implies 
%  \parans{x \mapsto_{\se} \_ * \true})
\}
\\
\end{array}
}

\\[20pt]

% Second proof obligation 
\infer[\textsc{Conseq}]
{
\begin{array}{l}
  \emptyset,\emptyset,\true \vdash 
  \{ 
  I \land (\HP[\tid] \mapsto \_ * X) \land \parans{\HP[t]\mapsto x * \true} \land \parans{x\mapsto_{\se} \_ * \true}))  
  \} 
  \, \mathtt{HP[tid()] =p } 
  \\[2pt]
  \qquad\qquad\qquad\qquad
  \{ 
  I \land (\HP[\tid] \mapsto \_ * X) \land \parans{\HP[\tid]\mapsto p * \true} \land 
  (\neg\parans{\HP[t]\mapsto x * \true} \lor \parans{x \mapsto_{\se} \_ * \true})
  \}
\end{array}
}
% {
% \infer[\textsc{Disj}]
{
\begin{array}{l}
  \emptyset,\emptyset,\true \vdash 
  \{ 
  I \land (\HP[\tid] \mapsto \_ * X) \land \parans{x\mapsto_{\se} \_ * \true}))  
  \} 
  \, \mathtt{HP[tid()] =p } \,
  \{ 
  I \land (\HP[\tid] \mapsto p * X) \land 
  \parans{x \mapsto_{\se} \_ * \true}
  \}
\end{array}
}
% {
% \begin{array}{l}
% \begin{array}{l}
%   \emptyset,\emptyset,\true \vdash 
%   \{ 
%   x = \HP+\tid \land I \land (\HP[\tid] \mapsto \_ * X) \land \parans{x\mapsto_{\se} \_ * \true}))  
%   \} 
%   \, \mathtt{HP[tid()] =p } \,
%   \{ 
%   I \land (\HP[\tid] \mapsto p * X) \land 
%   \parans{x \mapsto_{\se} \_ * \true}
%   \}
% \end{array}\\
% \begin{array}{l}
%   \emptyset,\emptyset,\true \vdash 
%   \{ 
%   x \neq \HP+\tid \land I \land (\HP[\tid] \mapsto \_ * X) \land \parans{x\mapsto_{\se} \_ * \true}))  
%   \} 
%   \, \mathtt{HP[tid()] =p } \,
%   \{ 
%   I \land (\HP[\tid] \mapsto p * X) \land 
%   \parans{x \mapsto_{\se} \_ * \true}
%   \}
% \end{array}
% \end{array}
% }}

\\[20pt]

\infer[\textsc{Inv},\textsc{Shared-R},\textsc{Conseq},\textsc{Forall}_1]
{
R,G,\Upsilon \vdash \{ \shared{I} \} \langle \mathtt{HP[tid()] =p}\rangle_{\textsc{HP}_t} \{ \shared{I} \land \shared{\HP[\tid]\mapsto p * \true} \}
}
{ 
\infer[\textsc{Conseq},\textsc{Exist}_2] 
{
\emptyset,\emptyset,\true \vdash 
  \{ \shared{I \land I} \land \tau_{\Upsilon}(x,t) \} 
  \, \langle \mathtt{HP[tid()] =p}\rangle_{\textsc{HP}_t} \,
  \{ \shared{I \land I} \land \shared{\HP[\tid]\mapsto p * \true} \land \tau_{\Upsilon}(x,t) \}
}
{ 
\infer[\textsc{Shared-I}] 
{
\begin{array}{c}
I \iff I \land I \iff (I \land (\HP[\tid] \mapsto \_ * \true)) \iff  (I \land (\HP[\tid] \mapsto \_ * \exists X.\, X))
\\[2pt] 
\emptyset,\emptyset,\true \vdash 
  \{ \shared{I \land (\HP[\tid] \mapsto \_ * X)} \land \tau_{\Upsilon}(x,t) \} 
  \, \langle \mathtt{HP[tid()] =p}\rangle_{\textsc{HP}_t} \,
  \{ \shared{I \land (\HP[\tid] \mapsto \_ * X)} \land \shared{\HP[\tid]\mapsto p * \true} \land \tau_{\Upsilon}(x,t) \}
\end{array}
}
{
\begin{array}{l}
\textsc{HP}_t = \HP[t]\mapsto\_ * X \leadsto \HP[t]\mapsto \_
\\[4pt]
\emptyset,\emptyset,\true \vdash 
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land (\neg\parans{\HP[t]\mapsto x * \true} \lor (\parans{\HP[t]\mapsto x * \true} \land \neg\parans{\cc\mapsto x * \true}))  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land \parans{\HP[\tid]\mapsto p * \true} \land 
((\parans{\HP[t]\mapsto x * \true} \land \parans{\cc\mapsto x * \true}) 
 \implies 
 \parans{x \mapsto_{\se} \_ * \true})
\}
\\[4pt]
\emptyset,\emptyset,\true \vdash 
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land \parans{\HP[t]\mapsto x * \true} \land \parans{x\mapsto_{\se} \_ * \true}))  
\} 
\, \mathtt{HP[tid()] =p } 
\\[2pt]
\qquad\qquad\qquad\qquad
\{ 
I \land (\HP[\tid] \mapsto \_ * X) \land \parans{\HP[\tid]\mapsto p * \true} \land 
(\neg\parans{\HP[t]\mapsto x * \true} \lor \parans{x \mapsto_{\se} \_ * \true})
\}
\end{array}
}}}
\end{array}  
\]
\end{small}
\caption{\label{fig:hazard:hp}Formal derivation of the proof of $\textsc{hp}_t$ action. We ommit $V \Vdash$ for clarity.}
\end{figure*}

\begin{figure*}
\begin{small}  
\[
\begin{array}{c}
\begin{array}{l}
  \tau(j,n)= \shareds{(\exists y.\, \cc \mapsto y \land y \neq n) * \true} 
             \since 
             \shareds{(\exists z.\, \HP[j] \mapsto z \land z \neq n) * \true})
  \\[2pt]
  \tau_{\Upsilon}(x,t)
  =
  ((\shared{\HP[t]\mapsto x * \true} \since \shared{\cc\mapsto x * \true}) 
  \implies 
  \shared{x \mapsto_{\se} \_ * \true})
  \\[2pt]
  I
  =
  \exists y.\,\cc \mapsto y * y \mapsto \_ *  \bigast\nolimits_{i=0}^\nthreads \HP[i] \mapsto \_ * \true
\end{array}

\\[20pt]

\infer[\textsc{Conseq}]
{
\begin{array}{c}
\{ 
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  ((n \mapsto_{\se} * X) \land I \land (\neg (\HP[t]\mapsto x * \true) \lor ((\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true))))
 \} \, 
\mathbf{skip} \, \\
\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
\{ 
 V \Vdash n \neq x \land n  \_
 *
  (X \land I \land  (((\HP[t]\mapsto x * \true) \land (\cc \mapsto x * \true)) \implies (x \mapsto_{\se} * \true)))
 \} 
\end{array}
}
{
\begin{array}{lc}
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  \big((n \mapsto_{\se} * X) \land I \land \big(\neg (\HP[t]\mapsto x * \true) 
  \lor 
  ((\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true))\big)\big)
  &
  \implies
  \\
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  \big((n \mapsto_{\se} * X) \land I \land ((\exists z.\, z \neq x \land \HP[t]\mapsto z * \true) 
  \lor 
 ((\HP[t]\mapsto x * \true) \land (\exists c.\, c \neq x \land \cc \mapsto c * \true)))\big)  
 & 
 \implies
 \\
 (V \Vdash n \neq x \land n \mapsto_{\sm} \_
 *
 (n \mapsto_{\se} * X) \land I \land (\exists z.\, z \neq x \land \HP[t]\mapsto z * \true)) 
 \lor \mbox{} \\
 \qquad 
 (V \Vdash n \neq x \land n \mapsto_{\sm} \_
 *
 (n \mapsto_{\se} * X) \land I \land  (\HP[t]\mapsto x * \true) \land (\exists c.\, c \neq x \land \cc \mapsto c * \true))
 &
 \implies
 \\
 (V \Vdash n \neq x \land n \mapsto_{\sm} \_ * n \mapsto_{\se} \_
 *
 (X \land I \land (\exists z.\, z \neq x \land \HP[t]\mapsto z * \true)))
 \lor \mbox{} \\
 \qquad 
 (V \Vdash n \neq x \land n \mapsto_{\sm} \_ * n \mapsto_{\se} \_
 *
 (X \land I \land  (\HP[t]\mapsto x * \true) \land (\exists c.\, c \neq x \land \cc \mapsto c * \true)))
 &
\implies
\\
%  (V \Vdash n \neq x \land n \mapsto{\sm} \_ * n \mapsto_{\se} \_
%  *
%  (X \land I \land \neg(\HP[t]\mapsto x * \true)))
%  \lor \mbox{} \\
%  \qquad 
%  (V \Vdash n \neq x \land n \mapsto{\sm} \_ * n \mapsto_{\se} \_
%  *
%  (X \land I \land  (\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true)))
% &
% \implies
% \\
V \Vdash n \neq x \land n \mapsto \_
*
(X \land I \land \big(((\neg(\HP[t]\mapsto x * \true) \lor (\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true)))\big))
&
\implies
\\
V \Vdash n \neq x \land n \mapsto \_
*
\big(X \land I \land \neg\big((\HP[t]\mapsto x * \true) \lor (\cc \mapsto x * \true)\big)\big) 
&
\implies
\\
V \Vdash n \neq x \land n \mapsto \_
*
\big(X \land I \land \big(((\HP[t]\mapsto x * \true) \lor (\cc \mapsto x * \true)) \implies (x \mapsto_{\se} \_ * \true)\big)\big)
\\[4pt]
\multicolumn{2}{l}{
\begin{array}{@{}l}
\{ 
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  ((n \mapsto_{\se} * X) \land I \land (\neg (\HP[t]\mapsto x * \true) \lor ((\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true))))
 \} \, 
\mathbf{skip} \, \\
\qquad\qquad\qquad\qquad\qquad
\{ 
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  ((n \mapsto_{\se} * X) \land I \land (\neg (\HP[t]\mapsto x * \true) \lor ((\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true))))
 \} 
\end{array}
}
\end{array}
}

\\[20pt]

\infer[\textsc{Conseq}]
{
\begin{array}{l}
  \{
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  ((n \mapsto_{\se} \_  * X) \land I  \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
  \}
  \, \mathbf{skip} \,\\
  \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
  \{ 
   n \mapsto \_
   *
   (X \land I \land (\neg(\HP[t] \mapsto x * \true) \lor (x \mapsto_e \_ * \true)))
  \}
  \end{array}
}
{
\begin{array}{lc}
V \Vdash n \neq x \land n \mapsto_{\sm} \_
*
((n \mapsto_{\se} \_  * X) \land I  \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
& 
\implies
\\
V \Vdash n \neq x \land n \mapsto \_
*
(X \land I  \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
&
\implies
\\
V \Vdash n \neq x \land n \mapsto \_
*
(X \land I  \land (\neg(\HP[t] \mapsto x * \true) \lor (x \mapsto_{\se} \_ * \true)))
\\[4pt]
%
\multicolumn{2}{l}{
  \begin{array}{@{}l}
  \{
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  ((n \mapsto_{\se} \_  * X) \land I  \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
  \}
  \, \mathbf{skip} \,\\
  \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
  \{ 
  V \Vdash n \neq x \land n \mapsto_{\sm} \_
  *
  ((n \mapsto_{\se} \_  * X) \land I  \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
  \}
  \end{array}
}
\end{array}
}

\\[20pt]

\infer[\textsc{Conseq}]
{
\begin{array}{l}  
  \emptyset,G,\true \vdash \{V \Vdash n \neq x \land n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  \tau_{\Upsilon}(x,t) \}
\end{array}
}
{
\infer[\textsc{Conseq, Exist}_2]
{
\begin{array}{l}  
  \emptyset,G,\true \vdash \{
  V \Vdash n \neq x \land n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I * \true} \land   
  \tau_{\Upsilon}(x,t) \}
\end{array}
}
{
\infer[\textsc{Shared-I}]
{
\begin{array}{l}   
  \emptyset,G,\true \vdash \{V \Vdash n \neq x \land n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * X} \land \shareds{I} \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I * X} \land   
  \tau_{\Upsilon}(x,t) \}
\end{array}
}
{
\begin{array}{c}
\textsf{Take} =  n \mapsto_{\sm}  \mid n \mapsto_{\se} \_  * X \leadsto X
\\[2pt]
\{ 
 V \Vdash n \neq x \land n \mapsto_{\sm} \_
 *
 ((n \mapsto_{\se} * X) \land I \land (\neg (\HP[t]\mapsto x * \true) \lor ((\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true))))
\} \, 
\mathbf{skip} \, \\
\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
\{ 
 V \Vdash n \neq x \land n \_
 *
 (X \land I \land  (((\HP[t]\mapsto x * \true) \land (\cc \mapsto x * \true)) \implies (x \mapsto_{\se} * \true)))
\} 
\\[2pt]
\{
V \Vdash n \neq x \land n \mapsto_{\sm} \_
*
((n \mapsto_{\se} \_  * X) \land I  \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
\}
\, \mathbf{skip} \,\\
\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
\{ 
 n \mapsto \_
 *
 (X \land I \land (\neg(\HP[t] \mapsto x * \true) \lor (x \mapsto_e * \true)))
\}
\end{array}
}}}


\\[20pt]

\infer[\textsc{Conseq}]
{
\begin{array}{l}  
  \emptyset,G,\true \vdash \{V \Vdash n = x \land n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  \tau_{\Upsilon}(x,t) \}
\end{array}
}
{
\infer[\textsc{Conseq}]
{
\begin{array}{l}  
  \emptyset,G,\true \vdash 
  \{V \Vdash n \mapsto_{\sm} \_ \land 
  \shared{(n \mapsto_{\se} \_  * \true) \land I} \land (\forall j.\,\tau(j,n))
   \land \tau_{\Upsilon}(n,t)  \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I * \true} 
  \land 
  \tau_{\Upsilon}(n,t) \} 
\end{array}
}
{
\infer[\textsc{Conseq, Exists}_2]
{
\begin{array}{c}  
  \forall j.\,\tau(j,n) \implies \tau(t,n) \qquad \tau(t,n) \implies \tau_{\Upsilon}(n,t) 
  \\[1pt]
  \emptyset,G,\true \vdash 
  \{
    V \Vdash n \mapsto_{\sm} \_ \land 
    \shared{(n \mapsto_{\se} \_  * \true) \land I} \land 
    \tau(t,n)
  \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{
    V \Vdash n \mapsto \_ \land \shareds{I * \true} \land \tau(t,n)
  \} 
\end{array}
}
{
\infer[\textsc{Shared-S}]
{
\emptyset,G,\true \vdash 
\{
  V \Vdash n \mapsto_{\sm} \_ \land 
  \shared{(n \mapsto_{\se} \_  * X) \land I} \land 
  \tau(t,n)
\} 
\, \mathtt{skip}_{\textsf{Take}} \,  
\{
  V \Vdash n \mapsto \_ \land \shareds{I * X} \land \tau(t,n)
\} 
% \begin{array}{l}  
%   \emptyset,G,\true \vdash \{V \Vdash n \mapsto_{\sm} \_ \land 
%   \shared{(n \mapsto_{\se} \_  * \true) \land I} \land 
%   (\shareds{\exists y.\, \cc \mapsto y \land y \neq n} \since \shareds{\exists z.\, \HP[t] \mapsto z \land z \neq n}) 
%   \} 
%   \, \mathtt{skip}_{\textsf{Take}} \,  \\
%   \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
%   \{V \Vdash n \mapsto \_ \land \shareds{\true \land I} 
%   \land 
%   (\shareds{\exists y.\, \cc \mapsto y \land y \neq n} \since \shareds{\exists z.\, \HP[t] \mapsto z \land z \neq n}) \} 
% \end{array}
}
{
\infer[\textsc{Conseq}]
{
\begin{array}{c}  
  \textsf{Take} =  n \mapsto_{\sm}  \mid n \mapsto_{\se} \_  * X \leadsto X
  \\
  \emptyset,G,\true \vdash \{V \Vdash n \mapsto_{\sm} \_ * 
  ((n \mapsto_{\se} \_  * X) \land I \land 
  (\exists y.\, \cc \mapsto y \land y \neq n * \true))
  \} 
  \, \mathtt{skip} \\
  \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
  \{V \Vdash n \mapsto \_ * (X \land I 
  \land 
  (\exists y.\, \cc \mapsto y \land y \neq n * \true)) \} 
\end{array}
}
{
\begin{array}{l}  
  V \Vdash n \mapsto_{\sm} \_ * 
  ((n \mapsto_{\se} \_  * X) \land I \land 
  (\exists y.\, \cc \mapsto y \land y \neq n * \true))
  \implies  
  V \Vdash n \mapsto \_ * (X \land I 
  \land 
  (\exists y.\, \cc \mapsto y \land y \neq n * \true))  
  \\
  \emptyset,G,\true \vdash 
  \{
  V \Vdash n \mapsto_{\sm} \_ * 
  ((n \mapsto_{\se} \_  * X) \land I \land 
  (\exists y.\, \cc \mapsto y \land y \neq n * \true))
  \} 
  \, \mathtt{skip} \\
  \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
  \{
  V \Vdash n \mapsto_{\sm} \_ * 
  ((n \mapsto_{\se} \_  * X) \land I \land 
  (\exists y.\, \cc \mapsto y \land y \neq n * \true))
  \} 
\end{array}
}}}}}

\\[10pt]

\infer[\textsc{Inv}]
{
R,G,\Upsilon \vdash \{V \Vdash n \mapsto_{\sm} \_ \land \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n))\} 
\, \mathtt{skip}_{\textsf{Take}} \, 
\{V \Vdash   n \mapsto \_  \land \shareds{I} \}
}
{
\infer[\textsc{Shared-R,Conseq}]
{
R,G,\Upsilon \vdash \{V \Vdash n \mapsto_{\sm} \_ \land \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land \Upsilon\} 
\, \mathtt{skip}_{\textsf{Take}} \, 
\{V \Vdash  n \mapsto \_  \land \shareds{I}  \}
}
{
\infer[\textsc{Forall}_1]
{
\begin{array}{l}  
\emptyset,G,\true \vdash \{V \Vdash n \mapsto_{\sm} \_ \land \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land \Upsilon\} 
\, \mathtt{skip}_{\textsf{Take}} \, 
\{V \Vdash n \mapsto \_ \land \shareds{I}   \land \Upsilon \}
\end{array}
}
{
\infer[\textsc{Disj}]
{
\begin{array}{l}  
  \emptyset,G,\true \vdash \{V \Vdash n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  \tau_{\Upsilon}(x,t) \}
  % \emptyset,G,\true \vdash \{V \Vdash n \mapsto_{\sm} \_ \land 
  % \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land \tau \land 
  % ((\shared{\HP[t]\mapsto x * \true} \since \shared{\cc\mapsto x * \true}) \implies \shared{x \mapsto_{\se} \_ * \true}) \} 
  % \, \mathtt{skip}_{\textsf{Take}} \, \\
  % \qquad\qquad\{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  % ((\shared{\HP[t]\mapsto x * \true} \since \shared{\cc\mapsto x * \true}) \implies \shared{x \mapsto_{\se} \_ * \true}) \}
\end{array}
}
{
\begin{array}{l}  
  \emptyset,G,\true \vdash \{V \Vdash n = x \land n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  \tau_{\Upsilon}(x,t) \}
  \\[2pt]
  % \emptyset,G,\true \vdash \{V \Vdash n \mapsto_{\sm} \_ \land 
  % \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land \tau \land 
  % ((\shared{\HP[t]\mapsto x * \true} \since \shared{\cc\mapsto x * \true}) \implies \shared{x \mapsto_{\se} \_ * \true}) \} 
  % \, \mathtt{skip}_{\textsf{Take}} \, \\
  % \qquad\qquad\{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  % ((\shared{\HP[t]\mapsto x * \true} \since \shared{\cc\mapsto x * \true}) \implies \shared{x \mapsto_{\se} \_ * \true}) \}
  \emptyset,G,\true \vdash \{V \Vdash n \neq x \land n \mapsto_{\sm} \_ \land 
  \shared{n \mapsto_{\se} \_ * \true} \land \shareds{I} \land (\forall j.\,\tau(j,n)) \land 
  \tau_{\Upsilon}(x,t) \} 
  \, \mathtt{skip}_{\textsf{Take}} \,  
  \{V \Vdash n \mapsto \_ \land \shareds{I} \land   
  \tau_{\Upsilon}(x,t) \}
\end{array}
}
}
}
}
\end{array}
\]
\end{small}
\caption{Formal derivation of the \textsf{Take} action in \texttt{retire()}.}
\end{figure*}


% \begin{figure*}
% \[
% \begin{array}{l}
% \{ 
%  n \mapsto_{\se} \_
%  *
%  ((n \mapsto_{\se} * X) \land (\neg (\HP[t]\mapsto x * \true) \lor ((\HP[t]\mapsto x * \true) \land \neg(\cc \mapsto x * \true))))
% \} \, 
% \mathbf{skip} \, \\
% \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
% \{ 
%  n \mapsto \_
%  *
%  (X \land (((\HP[t]\mapsto x * \true) \land (\cc \mapsto x * \true)) \implies (x \mapsto_{\se} * \true)))
% \} 
% 
% \\
% \\
% 
% \{
% n \mapsto_{\se} \_
% *
% ((n \mapsto_{\se} \_  * X) \land (\HP[t] \mapsto x * \true) \land (x \mapsto_{\se} \_ * \true))
% \}
% \, \mathbf{skip} \,\\
% \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
% \{ 
%  n \mapsto \_
%  *
%  (X \land (\neg(\HP[t] \mapsto x * \true) \lor (x \mapsto_e * \true)))
% \}
% \end{array}
% \]
% 
% 
% 
% \[
% \infer[\textsc{Inv}]
% {
% }
% {
% }
% \]
% 
% \caption{Deriving \textsc{Take}.\label{fig:hazard:take}}
% \end{figure*}



\section{Useful subset of Abstract Logic\label{sec:perm}} 

\subsection{Concrete States}
In our examples we use a particular instantiation of the abstract logic
presented in Section~\ref{sec:logic}, choosing our separation algebra $\State$ 
as an extension of the $\RAM$ model
with three kinds of permissions: $1$, $\sm$, and $\se$.
$$
\Loc = \{1, 2, \ldots\};
\quad 
\Val = \mathbb{Z};
\quad
\RAM_r 
= \Loc \rightharpoonup_{\it fin} \Val \times \{1,\sm,\se \}.
$$
We refer to $1$ as a \emph{full} permission, to $\sm$ as a \emph{master} permission,
and to $\se$ as an \emph{existential} permission.
 
Let $E, F$ range over expressions over logical
variables (such expressions are enough for our purposes).
Our  assertion language includes three new atomic assertions
$E \mapsto F$, $E \mapsto_{\sm} F$, and $E \mapsto_{\se} F$, 
which denotes states with the only
allocated cell at the address $E$ containing $F$, with the full permission ($1$),
the \emph{master} permission and the \emph{existential} permission ($\se$), respectively:
$$
\begin{array}{l}
[\db{E}_{\intp} : \db{F}_{\intp}],\intp \models E \mapsto F \times 1,\\
{[}\db{E}_{\intp} : \db{F}_{\intp}],\intp \models E \mapsto F \times \sm, ~\text{and}\\
{[}\db{E}_{\intp} : \db{F}_{\intp}],\intp \models E \mapsto F \times \se,
\end{array}
$$
where $\db{E}_{\intp}$ denotes the value of the expression $E$ with respect to
the interpretation $\intp$.

The $*$ operator on $\RAM_r$ is defined as a union combines to be  a union of functions with 
either disjoint domains, or that for every location in their common domain one state 
has a master permission and one state has an existential permission.
In the latter case, the $*$ operator merges the two permissions into one full permission.
In all other cases, $*$ is not defined.


\ag{m + e = 1. m + m, e + e - undefined.
check with examples what m and e should allow (and whether e should
really be r)}


\ag{change to e+e = 1 the rest not important + copy paste and modify from rcu.}

\subsection{Specialised Proof Rules}
In our proofs, we only use a limited number of tautologies involving $\since$ and a particular form of 
a temporal invariant. We use these tautologies to derive special proof rules.
for establishing assertions involving $\since$, carrying them over atomic commands, and proving the preservation 
of the invariant.


\subsubsection{Tautologies}
We use the following tautologies to establish and carry temporal assertions involving $\since$.
\[
\begin{array}{l}
(A \wedge B) \implies (A \since B) \\
((A \since B) \extend A) \implies (A \since B) \\
(A \since B) \implies A\\
(\neg A \wedge \neg B) \implies \neg (A \since B)\\
\neg (A \since B) \extend (\neg A \lor \neg B) \implies \neg (A \since B)
\end{array}
\]


\subsubsection{Derived Share rule - with Alexey}

\ag{clean up derivation. Use infer. Add derivation - explain derivation.}
\ag{Tautologies - in proofs + in derivation - write down. explain important ones.}

Note: In the \texttt{Inc} In the case of the hazard pointers when we use the second premise of the 
derived rule for shared we do another case split on top of $u \land \neg v$
depending whether  the hazard pointer  points to $x$ or not.
\[
\begin{array}{c}
\neg u \\
u \land \neg v \leftarrow \text{Inc}
\end{array}
\]



\[
\infer[d]
{
\begin{array}{l}
\{p*l \land \shareds{p_s} 
\land 
(\shared{u} \since \shareds{v} \implies \shareds{w}) 
\land (\shared{r} \since \shared{s}) \}
\\
\qquad \,\langle\, C \,\rangle\,
\\
\{q \land \shareds{q_s} 
\land 
(\shared{u} \since \shareds{v} \implies \shareds{w}) 
\land (\shared{r} \since \shared{s}) \}
\end{array}
}
{
\begin{array}{l}
\begin{array}{l}
\{p*l *(p_s 
\land 
w \land r) \}
\\
\qquad  C 
\\
\{q * 
(q_s
\land 
(w \lor \neg u) 
\land 
r) \}
\end{array}
\\
\\
\begin{array}{l}
\{p*l *(p_s 
\land 
(\neg  u \lor ( u \land \neg v)) 
\land r) \}
\\
\qquad  C 
\\
\{q * 
(q_s
\land 
(( u  \land  v) \implies w)
\land 
r) \}
\end{array}
\end{array}
}
\]

\[
\begin{array}{c}
\begin{array}{l}
\{p*l \land \shareds{p_s} 
\land 
\shareds{w} 
\land (\shared{r} \since \shared{s}) \}
\\
\qquad \,\langle\, C \,\rangle\,
\\
\{q \land \shareds{q_s} 
\land 
(\shared{u} \since \shareds{v} \implies \shareds{w}) 
\land (\shared{r} \since \shared{s}) \}
\end{array}
\\
\\
\begin{array}{l}
\{p*l \land \shareds{p_s} 
\land 
\neg (\shared{u} \since \shareds{v}) 
\land (\shared{r} \since \shared{s}) \}
\\
\qquad \,\langle\, C \,\rangle\,
\\
\{q \land \shareds{q_s} 
\land 
(\shared{u} \since \shareds{v} \implies \shareds{w}) 
\land (\shared{r} \since \shared{s}) \}
\end{array}
\\
\\
\hline
\\
  \begin{array}{l}
  \{p*l \land \shareds{p_s} 
  \land 
  (\shared{u} \since \shareds{v} \implies \shareds{w}) 
  \land (\shared{r} \since \shared{s}) \}
  \\
  \qquad \,\langle\, C \,\rangle\,
  \\
  \{q \land \shareds{q_s} 
  \land 
  (\shared{u} \since \shareds{v} \implies \shareds{w}) 
  \land (\shared{r} \since \shared{s}) \}
  \end{array}
\end{array}
\]

$
(\neg (u \since v)
\extend
\shareds{u \land v \implies w})
\implies
(\shareds{u} \since \shareds{v} \implies \shareds{w})
$

\[
\begin{array}{c}
  l \mid p_s \leadsto q_s \in G
  \\
  p*l \land \shareds{p_s} 
  \land 
  \neg (\shared{u} \since \shareds{v}) 
  \land (\shared{r} \since \shared{s}) \implies\\
  \qquad
  p*l 
  \land 
  (\shared{r} \since \shared{s}) 
  \land 
  \neg (\shared{u} \since \shareds{v})
  \land
  \shareds{p_s \land (\neg u \lor (u \land \neg v)) \land r}
  \\
  \begin{array}{l}
  \emptyset,\emptyset,\true \vdash \{p*l *(p_s 
  \land 
  (\neg  u \lor ( u \land \neg v)) 
  \land r) \}
  \\
  \qquad  C 
  \\
  \{q * 
  (q_s
  \land 
  (( u  \land  v) \implies w)
  \land 
  r) \}
  \end{array}
\\
q \land (((\shareds{r} \since \shareds{s}) \land \neg (\shared{u} \since \shareds{v})) 
  \extend \shareds{q_s \land (u \land v \implies w) \land r})
\implies\\
\qquad
q \land \shareds{q_s} \land 
(\shareds{u} \since \shareds{v} \implies \shareds{w}) \land
(\shareds{r} \since \shareds{s})
\\
\\
\hline
\\
\begin{array}{l}
\{p*l \land \shareds{p_s} 
\land 
\neg (\shared{u} \since \shareds{v}) 
\land (\shared{r} \since \shared{s}) \}
\\
\qquad \,\langle\, C \,\rangle\,
\\
\{q \land \shareds{q_s} 
\land 
(\shared{u} \since \shareds{v} \implies \shareds{w}) 
\land (\shared{r} \since \shared{s}) \}
\end{array}
\end{array}
\]


tautologies:
$\shareds{u} \since \shareds{v} \implies \shareds{u}$

$ \shareds{w \lor \neg u}
\implies
(\shareds{u} \since \shareds{v} \implies \shareds{w})$

$ (\shareds{r} \since \shareds{s}) 
\extend
\shareds{r}
\implies
(\shareds{r} \since \shareds{s})$






%%%%%%%%%%%%
\[
\begin{array}{c}
  \begin{array}{l}
    l \mid p_s \leadsto q_s \in G
    \\
    p * l \land \shared{p_s} \land \shareds{w} 
    \land (\shared{r} \since \shared{s}) 
    \implies
    p * l      
    \land (\shared{r} \since \shared{s} )
    \land (\shared{p_s \land w \land r} ) 
    \\
    \begin{array}{l}
    \emptyset,\emptyset,\true \vdash\{p*l *(p_s 
    \land 
    w \land r) \}
    \\
    \qquad  C 
    \\
    \{q * 
    (q_s
    \land 
    (w \lor \neg u) 
    \land 
    r) \}
    \end{array} 
     \\ 
     q \land (\shareds{r} \since \shareds{s}) \extend \shareds{q_s \land (w \lor \neg u) \land r}
     \implies \mbox{}\\
     \qquad
     q \land \shareds{q_s} \land (\shared{u} \since \shareds{v} \implies \shareds{w}) \land (\shareds{r} \since \shareds{s})
    \end{array}\\
  \hline
  \begin{array}{l}
  \{p*l \land \shareds{p_s} 
  \land 
  \shareds{w} 
  \land (\shared{r} \since \shared{s}) \}
  \\
  \qquad \,\langle\, C \,\rangle\,
  \\
  \{q \land \shareds{q_s} 
  \land 
  (\shared{u} \since \shareds{v} \implies \shareds{w}) 
  \land (\shared{r} \since \shared{s}) \}
  \end{array}
\end{array}
\]

\subsection{Derived Shared Rule}
For the special case where the invariant has the form 
\[
\Upsilon = (\tau_A \since \tau_B) \implies \tau_C\,,
\]
the rule $\textsc{Shared'}$, shown below, can be  
derived from the general $\textsc{Shared}$ rule.
\[
\begin{array}{c}
%
\infer[\textsc{Shared'}]{
R, G, ((\tau_A \since \tau_B) \implies \tau_C) \vdash 
\{P \}
\, \langle c \rangle\, 
\{ Q \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
}{
\begin{array}{c}  
% \Upsilon = (\tau_A \since \tau_B) \implies \tau_C
% \\[2pt]
% \\
% R, G, \Upsilon \vdash \mbox{}\\[1pt]
% \qquad
% \{P\wedge \neg \tau_C\}
% \, \langle c \rangle\, 
% \{Q \wedge (\tau_C \lor \neg \tau_A \lor \neg \tau_B)\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% \\[2pt]
l \mid p_s \leadsto q_s \in G
\\
P \wedge \neg \tau_C \wedge \neg (\tau_A \since \tau_B) \implies  p * l \wedge \tau \wedge \shared{p_s}
\\
f_c(\db{p * l * p_s}) \sqsubseteq \db{q * q_s}
\\
q \wedge (\tau \extend \shared{q_s})
\Rightarrow  
\shareds{\tau_C \lor \neg \tau_A \lor \neg \tau_B} \land Q
\\
\\
% R, G, \Upsilon \vdash \mbox{}\\[1pt]
% \qquad
% \{P\wedge \tau_C \wedge \neg (\tau_A \since \tau_B)\}
% \, \langle c \rangle\, 
% \{Q \wedge (\tau_C \lor \neg \tau_A \lor \neg \tau_B)\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% \\[2pt]
%\\
l' \mid p'_s \leadsto q'_s \in G
\\
P \wedge \tau_C \wedge (\tau_A \since \tau_B) \implies  p' * l' \wedge \tau' \wedge \shared{p'_s}
\\
f_c(\db{p' * l' * p'_s}) \sqsubseteq \db{q' * q'_s}
\\
q' \wedge (\tau' \extend \shared{q'_s})
\Rightarrow  
\shareds{\tau_C \lor \neg \tau_A \lor \neg \tau_B} \land Q
\\
\\
% R, G, \Upsilon \vdash \mbox{}\\[1pt]
% \qquad
% \{P\wedge \tau_C \wedge (\tau_A \since \tau_B)\}
% \, \langle c \rangle\, 
% \{Q \wedge (\tau_C \lor (\neg \tau_A \land \neg \tau_B))\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% \\
% \\
l'' \mid p''_s \leadsto q''_s \in G
\\
P \wedge \tau_C \wedge \neg (\tau_A \since \tau_B) \implies  p'' * l'' \wedge \tau'' \wedge \shared{p''_s}
\\
f_c(\db{p'' * l'' * p''_s}) \sqsubseteq \db{q'' * q''_s}
\\
q'' \wedge (\tau'' \extend \shared{q''_s})
\Rightarrow  
\shareds{\tau_C \lor (\neg \tau_A \land \neg \tau_B)} \land Q
\end{array}
}
%  
\end{array}
\]
To derive the rule, we first apply the disjunction rule to 
perform a three-way case analysis.
\[
\begin{array}{c}
%
\infer[\textsc{Disj}]{
R, G, ((\tau_A \since \tau_B) \implies \tau_C) \vdash 
\{P \}
\, \langle c \rangle\, 
\{ Q \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
}{
\begin{array}{l}  
R, G, ((\tau_A \since \tau_B) \implies \tau_C) \vdash \mbox{}\\[1pt]
\qquad
\{P\wedge \neg \tau_C\}
\, \langle c \rangle\, 
\{Q \wedge (\tau_C \lor \neg \tau_A \lor \neg \tau_B)\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
\\[2pt]
R, G, ((\tau_A \since \tau_B) \implies \tau_C) \vdash \mbox{}\\[1pt]
\qquad
\{P\wedge \tau_C \wedge \neg (\tau_A \since \tau_B)\}
\, \langle c \rangle\, 
\{Q \wedge (\tau_C \lor \neg \tau_A \lor \neg \tau_B)\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
\\[2pt]
R, G, ((\tau_A \since \tau_B) \implies \tau_C) \vdash \mbox{}\\[1pt]
\qquad
\{P\wedge \tau_C \wedge (\tau_A \since \tau_B)\}
\, \langle c \rangle\, 
\{Q \wedge (\tau_C \lor (\neg \tau_A \land \neg \tau_B)\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
\end{array}
}
%  
\end{array}
\]
\begin{description}
\item[Case 1:]
Assume that the invariant hold at the pre-state, but 
$\tau_C$ does not.
This implies that $\tau_A \since \tau_B$ does not hold in the pre-state either.
Thus, to reestablish the invariant at the post-state we need either to establish $\tau_C$
or show that $\tau_A \since \tau_B$ does not hold.
To show the latter we use the tautology
\[
\neg (\tau_A \since \tau_B) \extend (\neg  \tau_A \lor \neg \tau_B)
\]
and the assumption.
\item[Case 2:]
Assume that the invariant as well $\tau_C$ hold at the pre-state.
There can be two sub cases: either $\tau_A \since \tau_B$ holds at the pre-state or not.
In this case, we assume the latter. Thus, the reasoning in done as in the first case.
\item[Case 3:]
Assume that the invariant as well $\tau_C$ and $\tau_A \since \tau_B$ hold at the pre-state.
To reestablish the invariant at the post-state we need either to establish $\tau_C$
or show that $\tau_A \since \tau_B$ does not hold.
To show the latter we use the tautology
\[
(\neg  \tau_A \land \neg \tau_B) \implies \neg (\tau_A \since \tau_B)\,.
\]
\end{description}


\subsection{Derived Shared Rule}
\nr{Under Construction}
For the special case where the invariant has the form 
\[
\Upsilon = \forall x.\,(\exists t.\, \shareds{p(x,t)*\true} \since \shareds{x \mapsto \_*\true}) \implies \shareds{x \mapsto_e \_*\true}\,,
\]
and $\foot(p(x,t)) = \foot(p(x,t'))$ for all $t,t'$,
the rule $\textsc{Shared''}$, shown below, can be  
derived from rule $\textsc{Shared'}$ rule.
\[
\begin{array}{c}
%
\infer[\textsc{Shared''}]{
R, G, \Upsilon \vdash 
\{P \}
\, \langle c \rangle\, 
\{ Q \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
}{
\begin{array}{c}  
l \mid p_s \leadsto q_s \in G
\\
P  \implies  p * l \wedge \tau \wedge \shared{p_s}
\\
f_c(\db{p * l * p_s}) \sqsubseteq \db{q * q_s}
\\
\foot(p_s) \subseteq \foot(q_s)
\\
q \wedge (\tau \extend \shared{q_s})
\Rightarrow  
Q
% \\
% \\
% % R, G, \Upsilon \vdash \mbox{}\\[1pt]
% % \qquad
% % \{P\wedge \tau_C \wedge \neg (\tau_A \since \tau_B)\}
% % \, \langle c \rangle\, 
% % \{Q \wedge (\tau_C \lor \neg \tau_A \lor \neg \tau_B)\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% % \\[2pt]
% %\\
% l' \mid p'_s \leadsto q'_s \in G
% \\
% P \wedge \tau_C \wedge (\tau_A \since \tau_B) \implies  p' * l' \wedge \tau' \wedge \shared{p'_s}
% \\
% f_c(\db{p' * l' * p'_s}) \sqsubseteq \db{q' * q'_s}
% \\
% q' \wedge (\tau' \extend \shared{q'_s})
% \Rightarrow  
% \shareds{\tau_C \lor \neg \tau_A \lor \neg \tau_B} \land Q
% \\
% \\
% % R, G, \Upsilon \vdash \mbox{}\\[1pt]
% % \qquad
% % \{P\wedge \tau_C \wedge (\tau_A \since \tau_B)\}
% % \, \langle c \rangle\, 
% % \{Q \wedge (\tau_C \lor (\neg \tau_A \land \neg \tau_B))\} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% % \\
% % \\
% l'' \mid p''_s \leadsto q''_s \in G
% \\
% P \wedge \tau_C \wedge \neg (\tau_A \since \tau_B) \implies  p'' * l'' \wedge \tau'' \wedge \shared{p''_s}
% \\
% f_c(\db{p'' * l'' * p''_s}) \sqsubseteq \db{q'' * q''_s}
% \\
% q'' \wedge (\tau'' \extend \shared{q''_s})
% \Rightarrow  
% \shareds{\tau_C \lor (\neg \tau_A \land \neg \tau_B)} \land Q
\end{array}
}
%  
\end{array}
\]


Another possible rule is 
\[
\begin{array}{c}
%
\infer[\textsc{Shared''}]{
R, G, \Upsilon \vdash 
\{P \}
\, \langle c \rangle\, 
\{ Q \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
}{
\begin{array}{c}  
x\mapsto_m\_ \mid X*x\mapsto_e\_ \leadsto X \in G
\\
P  \implies  p * x\mapsto_m\_  \wedge \tau \wedge \shared{p_s * c\mapsto_e\_}
\\
f_c(\db{p * x\mapsto_m\_  * p_s * x \mapsto_e \_}) \sqsubseteq \db{q * x \mapsto \_ * p_s}
\\
q \wedge (\tau \extend \shared{p_s})
\Rightarrow  
Q
\end{array}
}
\end{array}
\]

\subsection{Derived  Rules}

\sparagraph{Since introduction.}
For an atomic command that does not modify the 
shared state, we use the following tautology to establish 
that $A \since B$ holds.
\[
(A \wedge B) \implies (A \since B) 
\]
The derived rule says that if before the command we were able to
establish $\shareds{A}$ (and, in addition, some other information $\tau$ regarding the history of the shared state)
and that the execution of the command maintains $\shareds{A}$ \emph{and} establishes {\shareds{B}
then $\shareds{A} \since \shareds{B}$ (and $\tau$) holds after the command.
\[
\infer[\textsc{Since-Intro}]{
R, G, \Upsilon \vdash 
\{p \wedge \tau \wedge \shareds{A} \}\, 
\langle c \rangle\, 
\{ q \wedge \tau \wedge   \shareds{A} \since \shareds{B} \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
}{
\begin{array}{l}
%l \mid p_s \leadsto q_s \in G\\
\tau \wedge \shared{A}  \Rightarrow \shared{p_s}\\
f_c(\db{p * p_s}) \sqsubseteq \db{q * (A \land B)}
\\
\end{array}
}
\]
The soundness of the rule  comes from the following two observations.
First, $\tau \wedge \shared{A}$ were stable before the command.
The command did not change the state, and as we assume the invariant to be closed for stuttering
(recall that we assume ${\sf Id}$ is always in $R \cap G$) then ...
\nr{say something on stability} 
Also, from the semantics of \emph{since} we get that 
\[
\text{if}~A~\text{is stable}\,\implies\,A~\since B~\text{is stable}\,.
\]

\nr{We may want to have special formulae for \emph{single-writer -multi-reader always exist  cells}}
% \[
% \infer[\textsc{Since-Intro'}]{
% R, G, \Upsilon \vdash 
% \{p \wedge \tau \wedge \shareds{A} \}\, 
% \langle c \rangle\, 
% \{Q \wedge   (\shareds{A} \since \shareds{B}) \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% }{
% \begin{array}{l}
% l \mid p_s \leadsto q_s \in G\\
% (l * p) \land \tau \wedge \shared{A}  \Rightarrow \shared{p_s}
% \\
% f_c(\db{l * p * p_s}) \sqsubseteq \db{q * (q_s \land A \land B)}
% \\
% q \wedge ((\tau \land \shareds{A}) \extend \shared{q_s  \land A \land B})
% \Rightarrow  \Upsilon \land Q
% \end{array}
% }
% \]


\sparagraph{Invariant introduction.}
\[
\infer[\textsc{Inv-Intro}]{
\begin{array}{l}
R, G, \forall x.\,\forall t\,. \shareds{A(x,t)}\implies \shareds{C(x,t)}\vdash \mbox{}\\
\qquad\qquad\qquad\qquad\{P \}\, 
C \, 
\{Q \wedge  \shareds{A(e,e')} \wedge  \shareds{C(e,e')}) \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
\end{array}
}{
\begin{array}{l}
R, G, \forall x.\,\forall t\,. \shareds{A(x,t)}\implies \shareds{C(x,t)}\vdash \mbox{}\\
\qquad\qquad\qquad\qquad\{P \}\, 
C \, 
\{Q \wedge  \shareds{A(e,e')}) \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
\end{array}
}
\]


% \sparagraph{Master Stability.}
% \[
% \infer[\textsc{Master-Stability}]{
% \begin{array}{l}
% R, G, \Upsilon \{P \}\, 
% C \, 
% \{Q \wedge  \shareds{A(e,e')} \wedge  \shareds{C(e,e')}) \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% \end{array}
% }{
% \begin{array}{l}
% R, G, \forall x.\,\forall t\,. \shareds{A(x,t)}\implies \shareds{C(x,t)}\vdash \mbox{}\\
% \qquad\qquad\qquad\qquad\{P \}\, 
% C \, 
% \{Q \wedge  \shareds{A(e,e')}) \} %Q \{q \wedge (\tau \extend \shared{q_s})\}
% \end{array}
% }
% \]


\subsection{Syntactic Stabilisation}
We use the following tautologies to establish stability involving $\since$.
\[
\begin{array}{l}
  A~\text{is stable} \implies A \since B ~\text{is stable}
\end{array}
\]


\sparagraph{Invariant utilisation.}

\subsection{Invariant Preservation}
In our proofs, we use invariants of the form $(A \since B) \implies C$.
We show the preservation of the invariant using the following rule, 
which is derived from the  {\sc Shared} rule in the abstract logic.
The rule is derived by using the {\sc Disjunction} rule to allow for a 
case analysis regarding whether the invariant holds because  $C$ holds
or because $(A \since B)$ does not hold.
Note that from 

\ignore{
$$
\begin{array}{c}
  \infer[\textsc{Shared'}]{
  R, G, (A \since B) \implies C \vdash \{P\}\, \langle c \rangle\,\{Q\}
  }{
  \begin{array}{l}
  P \implies p \wedge \tau 
  \\
  \tau \implies \shareds{p_s}
  \\
  \shareds{p_s} \leadsto \shareds{q_s} \in G
  \\
  f_c(\db{p * p_s}) \sqsubseteq \db{l * q_s}
  \\
  (l \wedge \tau \extend \shared{p_s}) \extend \shared{q_s} 
  \implies Q \wedge I
  \end{array}
  }
\end{array}
$$

$$
\begin{array}{c}
  \infer[\textsc{Shared}]{
  R, G, I \vdash \{P\}\, \langle c \rangle\,\{Q\}
  }{
  \begin{array}{l}
  P \implies (p * l_p) \wedge (\tau \extend \shared{p_s})
  \\
  l_p \mid \shareds{p_s} \leadsto \shareds{q_s} \in G
  \\
  f_c(\db{p * l_p * p_s}) \sqsubseteq \db{l * q_s}
  \\
  (l \wedge \tau \extend \shared{p_s}) \extend \shared{q_s} 
  \implies Q \wedge I
  \end{array}
  }
\end{array}
$$

$$
\begin{array}{c}
  \infer[\textsc{Shared}]{
  R, G, I \vdash \{P\}\, \langle c \rangle\,\{Q\}
  }{
  \begin{array}{l}
  I \implies I_1 \lor I_2\\
  \end{array}
  }
\end{array}
$$
}



\subsection{Messy (Logic instantiation)}

\ag{
We use only a limited number of tautologies involving $\since$. We can first
present a general logic, and then use the tautologies below to get derived rules
specialised for the particular forms of temporal invariants, etc. that we use.
}

$(A \wedge B) \Rightarrow (A \since B)$

$A \since B$ is stable if so is $A$

$(A \since B) \circ A \Rightarrow (A \since B)$

$\dlf{A \since B} \Rightarrow A$

$\neg(A \since B) \circ \neg B \Rightarrow \neg(A \since B)$

NB: We might need to use consistency with the local state when we check the
satisfaction of $I$ in the Shared rule. We might also need to tighten the
interpretation of assertions so that it checks the consistency of the local and
the shared state.

We can use a rule derived from Shared and specialised to the form of the
temporal invariant $(A \since B)\Rightarrow C$.

$$
\infer{
\{((A \since B) \Rightarrow C ) \wedge P\}\, \langle c \rangle\,
\{((A \since B) \Rightarrow C) \wedge Q\}
}{
\begin{array}{c}
\{A \wedge C \wedge P\}\, c\, \{((A \wedge C) \vee \neg(A \wedge B)) \wedge Q\}
\\[3pt]
\{(\neg B \vee (B \wedge \neg A)) \wedge P\}\, c\, 
\{\neg B \vee B \wedge \neg A \vee A \wedge B \wedge C) \wedge Q\}
\end{array}
}
%
$$

So, you can either preserve the validity of the since clause and $C$ or
invalidate it. Might also split this rule into several ones, for different cases.

May be the disjunctions $\neg B \vee (B \wedge \neg A)$ are not needed; a
stronger one would do, e.g., $\neg B$.

Note that it's too imprecise to apply the Shared rule straight on the
implication $(A \since B) \Rightarrow C$: you'll lose corellations with the next
state and the history. So, first you need to make a case split on whether the
since clause is true using the disjunction rule. Note that the assertions that
you get (like, the since clause) aren't stable in general (they are if we're in
the reclaimer, but not the a reader). So, we need to formulate the stability
constraints carefully to check the stability only before applying the
disjunction rule and after.



% We define the following algebra $\RAM_{\pi}$, extending the $\RAM$
% algebra of Section~\ref{sec:setting}:
% $$
% \begin{array}{l@{\qquad\qquad}l}
% \Val = \mathbb{Z};
% &
% {\sf Cell} = \sm(\mathbb{N}_0 \times \mathbb{N}_0 \times \Val) \uplus
% \se(\mathbb{N}) \uplus
% \sro(\mathbb{N} \times \Val);
% \\
% \Loc = \mathbb{N};
% &
% \RAM_{\pi} = \Loc \rightharpoonup_{\it fin} {\sf Cell},
% \end{array}
% $$
% 

% \subsection{Clean (but Irrelevant for now)}
% 
% 
% 
% In our examples we use a particular instantiation of the abstract logic
% presented in Section~\ref{sec:logic}, choosing a separation algebra $\State$
% with appropriate kinds of permissions. As we explained in
% Section~\ref{sec:informal}, in some algorithms using RCU, threads can be viewed
% as taking out permissions from the shared state preventing certain memory cells
% from being deallocated. Sometimes we similarly need to prohibit cell
% modification. In this section we review the well-known existential and read-only
% counting permissions used to handle these two cases~\cite{boyland,permissions}.
% 
% We define the following algebra $\RAM_{\pi}$, extending the $\RAM$
% algebra of Section~\ref{sec:setting}:
% $$
% \begin{array}{l@{\qquad\qquad}l}
% \Val = \mathbb{Z};
% &
% {\sf Cell} = \sm(\mathbb{N}_0 \times \mathbb{N}_0 \times \Val) \uplus
% \se(\mathbb{N}) \uplus
% \sro(\mathbb{N} \times \Val);
% \\
% \Loc = \mathbb{N};
% &
% \RAM_{\pi} = \Loc \rightharpoonup_{\it fin} {\sf Cell},
% \end{array}
% $$
% where $\mathbb{N}$ and $\mathbb{N}_0$ are natural numbers including and
% excluding zero, respectively.  States from $\RAM_{\pi}$ have allocated memory
% locations annotated not only with their values in $\Val$, but with permissions,
% which restrict the types of operations that a thread can perform on the given
% location in the state. 
% 
% The permission $\sm(0, 0)$ is the {\em full} permission: it allows a thread to
% read, write and deallocate the corresponding cell. A full permission can be
% split into a {\em master} permission and several {\em existential} and {\em
%   read-only} ones, each of which can be given to a separate thread.  An
% existential permission guarantees that the cell is not going to be deallocated
% and gives the right to read it, but does not guarantee its value, since another
% thread can be concurrently writing to the cell. A single existential permission
% is represented by $\se(1)$, and $n$ such permissions combined together, as
% $\se(n)$; the value component is missing in this case. A read-only permission
% guarantees that the cell is not going to be deallocated {\em or modified} and
% also gives the right to read it. Several read-only permissions are represented
% by $\sro(n)$. Finally, a master permission is represented by $\sm(n, m)$, with a
% positive $n$ or $m$. Here $n$ and $m$ maintain the counts of existential and
% read-only permissions issued for the cell. The master permission gives the right
% to read the cell, but not to deallocate it; if the count of read-only
% permissions issued for the cell is zero, the permission additionally allows
% writing to it.
% 
% For example, the full permission $\sm(0, 0)$ can be split into two existential
% permissions $\se(1)$ and one master permission $\sm(2, 0)$. The former ones can
% be used by two readers to access the cell while guaranteeing safety, and the
% latter one by a single writer to write to the cell. Later, $\sm(2, 0)$ can be
% further split into a read-only permission $\sro(1)$ and a master permission
% $\sm(2, 1)$, both of which can be used to read from the cell while guaranteeing
% that it is not modified. The two existential permissions $\se(1)$ can later be
% recombined into a single one $\se(2)$, which can finally be combined with the
% read-only permission $\sro(1)$ and the master permission $\sm(2, 1)$ into a full
% permission $\sm(0,0)$, allowing the cell to be deallocated. The $*$ operation on
% $\RAM_{\pi}$ is defined following this intuition. First, we define it on ${\sf
%   Cell}$:
% $$
% \begin{array}{@{}c@{\quad}l@{}}
% \multicolumn{2}{c}{\se(n_1) * \se(n_2) = \se(n_1+n_2);
% \qquad
% \sro(n_1, u) * \sro(n_2,u) = \sro(n_1+n_2, u);}
% \\
% \sm(n_1, n_2, u) * \se(m)= \se(m)*\sm(n_1, n_2, u)
%  = \sm(n_1-m, n_2, u), &\mbox{if } n_1 \ge m;
% \\
% \sm(n_1, n_2, u) * \sro(m, u) = \sro(m, u)*\sm(n_1, n_2, u)=
% \sm(n_1, n_2-m, u), &\mbox{if } n_2 \ge m;
% \end{array}
% $$
% undefined in all other cases. We then define a relation $\sharp$ on states in
% $\RAM_{\pi}$ showing when two states are compatible:
% $$
% \theta_0 \mathop{\sharp} \theta_1 \Longleftrightarrow
% \forall i \in \{0, 1\}.\, {\theta_i(x) \fdef} \Rightarrow 
% {\theta_{1-i}(x) \fundef} \vee {(\theta_i(x) * \theta_{1-i}(x)) \fdef}.
% $$
% Two states are compatible if they do not make contradictory permissions claims
% on a memory location. Finally, $*$ on states adds up permissions for
% corresponding locations:
% \begin{multline*}
% \theta_0 * \theta_1 = \{(x, w) \mid 
% \exists i \in \{0, 1\}.\, {\theta_i(x) \fdef} \wedge{}\\
% (({\theta_{1-i}(x) \fundef} \wedge w = \theta_i(x)) \vee 
% ({\theta_{1-i}(x) \fdef} \wedge w = \theta_i(x) * \theta_{1-i}(x)))
% \},
% \end{multline*}
% if $\theta_0 \mathrel{\sharp} \theta_1$; undefined otherwise. Thus, the unit
% element of the algebra is the everywhere-undefined function $[\,]$.
% 
% To denote elements of $\RAM_{\pi}$, we extend the assertion
% language for predicates over states given in Section~\ref{sec:logic}:
% $
% p ::=  \ldots \mid E \xmapsto{\se:G,\sro:G'} F \mid 
% E \xhookrightarrow{G}_{\sf e} \_ \mid E \xhookrightarrow{G}_{\sf ro} F
% $,
% where $E, F, G,G'$ denote expressions over logical variables.  
% Here $E \xmapsto{\se:0,\sro:0}_{\sf e} F$ denotes a full
% permission, $E \xmapsto{\se:G,\sro:G'}_{\sf e} F$ with a positive $G$ or $G'$, a
% master permission, $E \xhookrightarrow{G}_{\sf e} \_$, several existential
% permissions, and $E \xhookrightarrow{G}_{\sf ro} F$, several read-only
% permissions:
% $$
% \begin{array}{lcl@{\quad\ \ }l}
% (\theta, \intp) \models E \xmapsto{\se:G,\sro:G'}_{\sf e} F &\Longleftrightarrow
% & \theta = [\db{E}_{\intp} : \sm(\db{G}_\intp,\db{G'}_\intp, \db{F}_{\intp})],&
% \db{G}_\intp,\db{G'}_\intp \ge 0;\\
% (\theta, \intp) \models E \xhookrightarrow{G}_{\sf e} \_ &\Longleftrightarrow & \theta =
% [\db{E}_{\intp} : \se(\db{G}_\intp)],&\db{G}_\intp > 0;\\
% (\theta, \intp) \models E \xhookrightarrow{0}_{\sf e} \_ &\Longleftrightarrow
% & \theta = [\,],
% \\
% (\theta, \intp) \models E \xhookrightarrow{G}_{\sf ro} F &\Longleftrightarrow & \theta =
% [\db{E}_{\intp} : \sro(\db{G}_\intp,\db{F}_\intp)],&\db{G}_\intp > 0;\\
% (\theta, \intp) \models E \xhookrightarrow{0}_{\sf ro} F &\Longleftrightarrow
% & \theta = [\,],
% \end{array}
% $$
% where $\db{E}_{\intp}$ denotes the result of evaluating the expression
% $E$ with respect to an interpretation $\intp$. For uniformity, we allow the
% assertions $E \xhookrightarrow{0}_{\sf e} \_$ and 
% $E \xhookrightarrow{0}_{\sf ro} F$, which denote an empty state.
% % We also use an iterated $*$ operation: $\bigast_{i=1}^n P_i = P_1 * \ldots *
% % P_n$, so that $\bigast_{i=1}^n E \hookrightarrow_{\sf e} \_$ represents $n$ existential
% % permissions for the cell at the address $E$.
% Let $E \hookrightarrow_{\sf e} \_$ and $E \hookrightarrow_{\sf ro} F$ be
% syntactic sugar for $E \xhookrightarrow{1}_{\sf e} \_$ and $E
% \xhookrightarrow{1}_{\sf ro} F$, respectively.
% We drop labels $\se:0$ or $\sro:0$ on arrows, so that 
% $E \mapsto F$ means $E \xmapsto{\se:0,\sro:0}_{\sf e} F$.
% For a structure taking two adjacent memory cells, we write $E \mapsto
% F, F'$ for $E \mapsto F * (E+\textit{off}) \mapsto F'$, where {\it off} is the
% offset of the second field in the structure. We use the same notation for other
% kinds predicates introduced above.
% 
% Due to space constraints, transformers and axioms for standard primitive
% commands over $\RAM_{\pi}$ are given in Appendix~\ref{app:formal}. Informally,
% disposing a cell requires the full permission, reading it, a master or an
% existential permission, and writing to it, a master permission. When a thread
% allocates a cell, it gets it with the full permission. Reading from a cell with
% an existential permission produces an arbitrary value.
