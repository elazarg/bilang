%!TEX root = ./recycling.tex

\section{Permissions}\label{sec:perm}

\nr{My plan is to merge this section with the hazard pointer proof and 
    have a section about the instantiated logic where we use the hazard pointer
    example to explain the \emph{instantiation}.}

% Our assertion language denote sets of worlds, i.e., pairs 
% of  thread private state and a sequence of states describing the history of the 
% the history of the shared  

% Our assertion language comes from instantiate the abstract logic
% presented in Section~\ref{sec:logic} with 
% a separation algebra $\State$ 
% which extends the $\RAM$ model described in Section~\ref{sec:setting} 
% with permissions.

\nr{We want $m$ and $e$ so we could show that there are no memory leaks.}

As  explained in Section~\ref{sec:informal},
when a thread modifies the value of the counter 
it becomes responsible for the deallocation of the  cell
that it detaches.
Formally, we record this responsibility in our assertion language using
\emph{permissions}~\cite{boyland,permissions}:
We instantiate the abstract logic
presented in Section~\ref{sec:logic} with 
a separation algebra $\State$ 
which instruments the $\RAM$ model described in Section~\ref{sec:setting} 
with three kinds of permissions: $1$, $\sm$ and~$\se$.
$$
\Loc = \{1, 2, \ldots\};
\quad 
\Val = \mathbb{Z};
\quad
\RAM_r 
= \Loc \rightharpoonup_{\it fin} \Val \times \{1, \sm, \se \}.
$$
We refer to the instrumented model as $\RAM_\se$,
to $1$ as a \emph{full} permission, to $\sm$ as a \emph{master} permission,
and to $\se$ as an \emph{access} permission.
States from $\RAM_{\se}$ have allocated memory
locations annotated not only with their values in $\Val$, but also with permissions.
A full permission can be
split into a {\em master} permission ($\sm$) and an {\em access} permission ($\se$), which 
cannot be split any further.

We denote elements of $\RAM_{\se}$ by extending the assertion
language for predicates over states given in Section~\ref{sec:logic}.
Let $E, F$ range over expressions over logical
variables (such expressions are enough for our purposes).
Our  assertion language includes three new atomic assertions
$E \mapsto F$,  $E \mapsto_{\sm} F$, and $E \mapsto_{\se} F$, 
which denotes states with the only
allocated cell at the address $E$ containing $F$, with the full permission ($1$), 
a \emph{master} permission($\sm$) or an \emph{access} permission ($\se$), respectively:
$$
\begin{array}{lcl}
\theta,\intp \models E \mapsto F 
& 
\iff 
& 
\theta = [\db{E}_{\intp} : (\db{F}_{\intp},1)]
\\
\theta,\intp \models E \mapsto_{\sm} F, 
&
\iff 
& 
\theta = [\db{E}_{\intp} : (\db{F}_{\intp},\sm)]
~\text{, and}\\
\theta,\intp \models E \mapsto_{\se} F 
& 
\iff
& 
\theta = {[}\db{E}_{\intp} : (\db{F}_{\intp},\se)]\,.
\end{array}
$$
where $\db{E}_{\intp}$ denotes the value of the expression $E$ with respect to
the interpretation $\intp$.

%  in the state based on the historical information 
% record by the permission. 
% 
% 
Informally, the memory cell pointed to by the global variable $\cc$ is always 
associated with the  full permission. 
When a thread modifies the value of the counter it splits the 
permission of the detached cell $p$ into a master permission, which it takes into its own private state,
and an access permission which is left in the shared state thus indicating that other threads are 
allowed to 
keep accessing~$p$ as long as  $p$'s grace period does not end.
More formally, 
which we use the permissions to
restrict the types of operations that a thread can 
perform on a given location, as we now explain.


We us permissions to define the primitive transformer.
The {\em full} permission ($1$) allows a thread to
read, write and deallocate the corresponding cell. A full permission can be
split into two partial permissions a {\em master} permission ($\sm$) and an {\em existential} 
permission ($\se$) which can be used by different threads. 
A partial  permission guarantees that the that the cell is not going to be 
deallocated or modified and
also gives the right to read it.



% is left in the shared  is viewed as detaches a cell  
% 
% when a thread detaches an element form 
% 
%  which we use to
% to restrict the types of operations that a thread can 
% perform on a given location.
% 
% The memory cell pointed to by $\cc$ has a full permission associated with it.s in the shared state 
% 
% with a 
% We ensure that the memory cell pointed 
% When a thread detaches a  it cell is viewed gets the master permission for the 
% cell. 
% 
% 
% 
% 
% 
% 
% The threads leave an existential permission in the shared state allowing other threads to 
% keep accessing the removed node as long as the grace period of the removed element did not end.
% The partial permission is essentially the well-known read-only
% permission~\cite{boyland,permission} but cannot be split any further.
% 
%  We record the information this future commitment using 
% a \emph{master} permission. the aforementioned permissions:
% A thread that detaches a future commia can be viewed as taking out permissions from the shared state and thus taking 
% responsibility for their deallocation in the future.
% We model this 
% 
% The threads leave an existential permission in the shared state allowing other threads to 
% keep accessing the removed node as long as the grace period of the removed element did not end.
% The partial permission is essentially the well-known read-only
% permission~\cite{boyland,permission} but cannot be split any further. 
%  
% 
% The {\em full} permission ($1$) allows a thread to
% read, write and deallocate the corresponding cell. A full permission can be
% split into a {\em master} permission ($\sm$) and an {\em existential} permission ($\se$) which can be used by different threads. 
% A partial  permission guarantees that the that the cell is not going to be 
% deallocated {\em or modified} and
% also gives the right to read it.
 

% For a structure taking two adjacent memory cells, we write $E \mapsto
% F, F'$ for $E \mapsto F * (E+\textit{off}) \mapsto F'$, where {\it off} is the
% offset of the second field in the structure. We use the same notation for other
% kinds predicates introduced above.

\nr{explain why asymmetric. }

\todone{\ag{change to e+e = 1 the rest not important + copy paste and modify from rcu.}}


%%% Local Variables:
%%% TeX-master: "recycling"
%%% End:  
