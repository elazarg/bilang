%!TEX root = ./recycling.tex

%\newcommand{\safe}{\textsf{safe}}
\newcommand{\consistent}[1]{(#1)\fdef}
\newcommand{\unit}{\epsilon}
\newcommand{\safecond}[1]{\noindent\textbf{\saferef{#1}}}
\newcommand{\saferef}[1]{Condition~(\ref{safe:#1})} %{Def.~\ref{def:safe}(\ref{safe:#1})}
\newcommand{\gsafecond}[1]{\noindent\textbf{\gsaferef{#1}}}
\newcommand{\gsaferef}[1]{Condition~(\ref{gsafe:#1})} %{Def.~\ref{def:safe}(\ref{safe:#1})}
\newcommand{\safeloccond}[1]{\noindent\textbf{\safelocref{#1}}}
\newcommand{\safelocref}[1]{Condition~(\ref{safeloc:#1})} %{Def.~\ref{def:safe}(\ref{safeloc:#1})}
%\newcommand{\emptyhistory}{\epsilon}

\newcommand{\stable}[3]{\mathsf{stab}_{#2,#3}(#1)}

\newcommand{\tvdash}{\vdash_\ltid}
\newcommand{\tvDash}{\vDash_\ltid}

 
\section{Proof of Soundness\label{app:soundness}}

%\TODO{ There is a bit of a mess with thread ids and interpretations. Needs to be cleaned.}

\paragraph{Notations.}
For each action $a = (l \mid  p_s \leadsto q_s)$, 
we write $\theta_l,\theta_s,\theta_s' \in \db{a}$ 
to mean that 
$$
\exists \intp.\;
(\theta_l,\intp\vDash l) \wedge
(\theta_s,\intp\vDash p_s) \wedge
(\theta_s',\intp\vDash q_s).
$$
We write $\stable{Q}{R}{\Upsilon}$ as a shorthand for assertion
$Q$ is stable under $R$ and temporal invariant $\Upsilon$.


%In the following, we will used a fixed arbitrary thread $\ltid$.

\subsection{Soundness for Commands}


\paragraph{Proof strategy.}
Our proof strategy follows  Vafeiadis\footnote{
V. Vafeiadis. Concurrent Separation Logic and Operational Semantics. In {\em
  MFPS}, 2011.}:
The $\safe$ predicate (Definition~\ref{def:safe}) formalises the notion of a command $C$ 
executed by a thread  $\ltid$ 
starting from an abstract local state $\theta_l$,  
a (non-empty) abstract history $\xi\theta_s$ (whose current shared state is $\theta_s$),
and a logical environment $\intp$; 
establishing a postcondition $Q$, while preserving the temporal invariant $\Upsilon$ and respecting the guarantee $G$--provided the environment modifies the shared state according to rely $R$ while preserving the same temporal invariant $\Upsilon$. 


\begin{defin}[Extended Worlds]\label{def:extworld}
  An \emph{extended world}  
  is a $7$-tuple $\upomega=(\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ such that
  $\theta_l$ is an abstract state,
  $\xi\theta_s$ is a non-empty history (sequence of abstract states) whose last element--the current shared state--is $\theta_s$, 
  $\intp$ is a  logical interpretation, 
  $R$ is a  set of (rely) actions, 
  $G$ is a set of (guarantee) actions, 
  $\Upsilon$ is a temporal invariant (a close assertion on histories),
  and $Q$ is an assertion on worlds.
\end{defin}

\begin{defin}[Thread Configuration]\label{def:config}
  A \emph{thread configuration}  
  is an $8$-tuple $\kappa=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ 
  such that $C$ is a command, $(\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$
  is an extended world, and the local state is consistent with the current shared  state $\consistent{\theta_l * \theta_s}$.
\end{defin}  



%:def:safe
\begin{defin}[Safety of Thread Configurations]\label{def:safe}
  A thread configuration  
  $\kappa = (C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ is always \emph{safe
  for $0$ steps for \emph{any} thread $\ltid$}, denoted 
  $
  \safe_0(\kappa).
  $
  $\kappa$ is \emph{safe for $n + 1$ steps for thread $\ltid$},  
  denoted 
  $
  \safe_{n+1}(\kappa),
  $
  if all of the following conditions hold:
  % $\safe_0(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ holds always and 
  % $\safe_{n+1}(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$ holds if and only if
  \begin{compactenum}[(a)]
    \item \label{safe:done} If 
    $C = \done$ then $\theta_l,\xi\theta_s,\intp \vDash Q$ and $\xi\theta_s,\intp\vDash\Upsilon$.

    \item \label{safe:noabort}  
    For all $\theta_f$ such that $\consistent{\theta_l*\theta_s*\theta_f}$,
    $$
    (C,\theta_l*\theta_s*\theta_f) \not\rightarrow_\ltid \top.
    $$
    \item \label{safe:step} 
    For all $\theta_f,C',\theta'$ such that 
    $$
    \consistent{\theta_l*\theta_s*\theta_f}
    \,\wedge\,
    ((C,\theta_l*\theta_s*\theta_f) \rightarrow_\ltid (C',\theta')),
    $$
    there exist  $\theta'_l$ and $\theta'_s$   such that 
    \begin{compactenum}[(1)]
      \item \label{safe:step:consistent} 
      $\theta'=\theta'_l * \theta'_s * \theta_f$, and 
      \item \label{safe:step:shared}
      either $C=\langle C'' \rangle_a$ for some $C''$ and $a$ such that
      \begin{compactenum}[(i)]
        \item \label{safe:step:guarantee} 
        there exist $\theta_{l_0}$ and $\theta_{l_1}$  such that
        $\theta_l = \theta_{l_0} * \theta_{l_1}$ 
        and
        $(\theta_{l_1},\theta_s,\theta'_s,\intp) \vDash a$ and  $ \db{a} \subseteq \db{G}$,
        \item \label{safe:step:inv} 
        $(\xi\theta_s\theta'_s,\intp)\vDash\Upsilon$, and
        \item \label{safe:step:ind} 
        $\safe_{n}(C',\theta'_l,\xi\theta_s\theta'_s,\intp,R,G,\Upsilon,Q)$;      
      \end{compactenum}
      \item  \label{safe:step:stutter}
       or $C\neq\langle C'' \rangle_a$ for any $C''$ and $a$  such that     
      \begin{compactenum}[(i)]
        \item \label{safe:step:stutter:same} 
        $\theta'_s = \theta_s$ and 
        \item \label{safe:step:stutter:ind} 
        $\safe_{n}(C',\theta'_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$.
      \end{compactenum}

    \end{compactenum}

    \item \label{safe:env}
    For every $\theta^l$ and $\theta^s$ 
    if 
    \begin{compactenum}[(1)]
      \item \label{safe:env:rely} $(\theta^l,\theta_s,\theta^s)\in \db{R}$,
      \item \label{safe:env:consistent} $\consistent{\theta^l*\theta_l*\theta_s}$ 
      and $\consistent{\theta_l*\theta^s}$ , and
      \item \label{safe:env:inv} $\xi\theta_s\theta^s,\intp\vDash\Upsilon$
    \end{compactenum}
    then $\safe_{n}(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon,Q)$.
  \end{compactenum}
  Thread configuration $\kappa$ is \emph{safe}, denoted $\safe(\kappa)$, if it is safe for any $0 \leq n$ steps.
\end{defin}

\begin{proposition}\label{pro:env:a}
For all sets of actions $G$ if $a \in G$ then $\db{a} \subseteq \db{G}$.
\end{proposition}

\begin{proposition}\label{pro:env:a}
For all sets of actions $R$,  $(\theta_l,\theta_s,\theta_s') \in \db{R}$
only if there is $a \in R$ such that   $(\theta_l,\theta_s,\theta_s') \in \db{a}$.
\end{proposition}

\nr{Needs to fix env to talk about $\db{R}$ instead of $\db{a}$.}


\begin{defin}[Meaning of Thread-local Judgements]\label{def:semtriple}
We express the validity of a triple for the thread $\ltid$ and the step $n$ by
$$
R,G,\Upsilon \tvDash^n \{ P \} \, C \, \{ Q \}.
$$
This validity holds if and only if 
for every thread configuration $\kappa = (C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$
if
$\theta_l,\xi\theta_s,\intp \vDash P$ and
$\xi\theta_s,\intp \vDash \Upsilon$
then 
$\safe_n(\kappa)$. We also write
$$
R,G,\Upsilon \tvDash \{ P \} \, C \, \{ Q \}
$$
when
$R,G,\Upsilon \tvDash^n \{ P \} \, C \, \{ Q \}$ for every $0 \leq n$.
%
%
%$R,G,\Upsilon \tvDash \{ P \} \, C \, \{ Q \}$ if and only if 
%for every configuration $\kappa = (C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$
%if
%$\theta_l,\xi\theta_s,\intp \tvDash P$ and
%$\xi\theta_s \tvDash \Upsilon$
%then 
%$\safe(\kappa)$.
\end{defin}

\ignore{
\begin{defin}[Closure under Stuttering]\label{def:stuttering}
An assertion $\Upsilon$ is \emph{closed under stuttering}
if for every abstract state $\theta_l$, non-empty history $\xi\theta_s$ 
and interpretation $\intp$ if
$\theta_l,\xi\theta_s,\intp\vDash \Upsilon$
holds then
$\theta_l,\xi\theta_s\theta_s,\intp\vDash \Upsilon$
also holds.
\end{defin}
}

\begin{theorem}[Soundness of Grace Logic for Commands]\label{the:sound:thread}
  If 
  $$
  R,G,\Upsilon \tvdash \{ P \} \, C \, \{ Q \}
  $$  
  is derivable in our logic % and $\Upsilon$ is closed under stuttering, 
  then
  $$  
  R,G,\Upsilon \tvDash \{ P \} \, C \, \{ Q \}
  $$ 
  holds.
\end{theorem}

\begin{proof}
The proof is done by induction on the derivation tree:
Intuitively, we prove that each rule is a sound implication if we replace all the $\tvdash$ by $\tvDash$. 
We handle each case separately by different lemmas in \S\ref{sec:auxiliary_lemmas}.
%We prove that each rule is a sound implication if we replace all the $\tvdash$ by $\tvDash$. 
%Then, the theorem follows by a straightforward rule induction. 
%%In the following, we prove the soundness of every rule using a different lemma.
\qed
\end{proof}

%\hy{This is not a straightforward rule induction. You prove a lot
%of lemmas to justify this theorem. Just say that each case is handled
%separately. Also, don't forget to put qed. Marking the end of the proof helps
%readers. Finally, the stuttering closure should be part of the condition of
%our logic.}



\subsection{Soundness for Programs}

\begin{defin}[Configuration]\label{def:glo-config}
  A \emph{configuration}  
  is an $5$-tuple $\rho =(\cp,\theta_l,\xi\theta_s,\intp,Q)$ 
  such that $\cp$ is a program, $\theta_l$ is the combination of 
  local states of threads, $\xi\theta_s$ is a history with
  $\consistent{\theta_l*\theta_s}$,
  $\intp$ is an interpretation of logical variables and
  $Q$ is an assertion about worlds.
\end{defin}  

\begin{defin}[Safety of Configurations]\label{def:gsafe}
  A configuration  $\rho = (\cp,\theta_l,\xi\theta_s,\intp,Q)$ is 
  always \emph{safe for $0$ steps}, denoted 
  $
  \gsafe_0(\rho)\,.
  $
  $\rho$ is \emph{safe for $n + 1$ steps},  denoted 
  $
  \gsafe_{n+1}(\rho)\,,
  $
  if all of the following conditions hold:
  \begin{compactenum}[(I)]
    \item \label{gsafe:done} If 
    $\cp = \done \parallel \ldots \parallel \done$ 
    then $(\theta_l,\xi\theta_s,\intp \vDash Q)$.
    \item \label{gsafe:noabort}  
    $(\cp,\theta_l*\theta_s) \not\rightarrow \top$.
    \item \label{gsafe:step} 
    For all $\cp',\theta'$, if
    $$
    (\cp,\theta_l*\theta_s) \rightarrow (\cp',\theta'),
    $$
    there exist  $\theta'_l$ and $\theta'_s$   such that
    either
    \begin{compactenum}[(i)]
    \item\label{safe:prog:step:shared}
    $\gsafe_{n}(\cp',\theta'_l,\xi\theta_s\theta'_s,\intp,Q)$, or
    \item\label{safe:prog:step:stutter}
    $\gsafe_{n}(\cp',\theta'_l,\xi\theta_s,\intp,Q) \land \theta_s = \theta'_s$   
	\end{compactenum}
  \end{compactenum}
  Configuration $\rho$ is \emph{safe}, denoted $\gsafe(\rho)$, if it is safe for any $0 \leq n$ steps.
\end{defin}

\begin{defin}[Meaning of Global Judgements]\label{def:semtriple2}
We express the validity of a triple for the program $\cp$ and the step $n$ by
$$
{} \vDash^n \{ P \} \, \cp \, \{ Q \}.
$$
This holds if and only if 
for every configuration $\rho = (\cp,\theta_l,\xi\theta_s,\intp,Q)$
if $\theta_l,\xi\theta_s,\intp \vDash P$,
then 
$\gsafe_n(\rho)$. We also write
$$
{} \vDash \{ P \} \, \cp \, \{ Q \}
$$
when
${} \vDash^n \{ P \} \, \cp \, \{ Q \}$ for every $0 \leq n$.
\end{defin}

\begin{lemma}\label{lem:safe:par}
Let $\kappa_1,\ldots,\kappa_n$ be thread configurations that have
the following form:
$$
\kappa_i = (C_i,(\theta_l)_i,\xi\theta_s,\intp,R_i,G_i,\Upsilon, Q_i)
$$ 
such that 
$$
\consistent{(\theta_l)_1 * \ldots * (\theta_l)_n * \theta_s}
\wedge
(R_i = \bigcup_{j \neq i} G_i).
$$
Also, let $\rho$ be the configuration that combines all of $\kappa_i$'s:
$$
\rho = 
(C_1 \parallel \ldots \parallel C_n,
 (\theta_l)_1 * \ldots * (\theta_l)_n,
 \xi\theta_s,
 \intp,Q_1 * \ldots * Q_n)
$$
If $\gsafe(\kappa_i)$ holds for every $i$,
so does $\gsafe(\rho)$.
\end{lemma}

\begin{proof}
The proof is done by induction on the number $k$ of steps for all $n$-tuples of 
possible configurations. 
For $k=0$, $\gsafe_0(\rho)$ holds by definition.
For the induction step,
assume the induction hypothesis (IH)
\begin{multline*}
\forall 1 \leq i \leq n.\, \kappa_i = (C'_i,(\theta'_l)_i,\xi'\theta'_s,\intp,R_i,G_i,\Upsilon, Q_i) \land \mbox{}\\
\safe_k(\kappa'_i) \land \consistent{(\theta'_l)_1 * \ldots * (\theta'_l)_n * \theta'_s} \implies \mbox{}\\
\gsafe(C'_1 \parallel \ldots \parallel C'_n,
 (\theta'_l)_1 * \ldots * (\theta'_l)_n,
 \xi'\theta'_s,
 \intp,Q'_1 * \ldots * Q'_n)
\end{multline*}
and that 
\[
(\dag_{\downarrow}) \; \consistent{(\theta_l)_1 * \ldots * (\theta_l)_n * \theta_s}
\]
holds and that
\[
(\dag_i) \;\safe_{k+1}(\kappa_i) 
\]
holds for $i=1,\ldots,n$.
We now show that $\gsafe_{k+1}(\rho)$ holds.

\gsafecond{done} if $C_i=\done$ for every $i=1,\ldots,n$ then from ($\dag_i$) and
\saferef{done} of Definition~\ref{def:safe}, we get that 
for every $i=1,\ldots,n$ it holds that 
$(\theta_l)_i,\xi\theta_s,\intp \vDash_i Q_i$ and 
$\xi\theta_s,\intp\vDash_i\Upsilon$.
As $Q_i$ and $\Upsilon$ do not have $\tid$, we get that 
for every $i=1,\ldots,n$ it holds that  
\[
(\%_i)\;
(\theta_l)_i,\xi\theta_s,\intp \vDash  Q_i \;\text{and}\; 
\xi\theta_s,\intp\vDash \Upsilon\,. 
\]
From ($\dag_{\downarrow}$), ($\%_1,\ldots \%_n$), and the meaning of $*$ for assertions on world 
we get that 
$((\theta_l)_1 * \ldots * (\theta_l)_n, \xi\theta_s,\intp \vDash Q_1 *\ldots Q_n)$.

\gsafecond{noabort}
Inspecting the operational semantics, we see that $(\cp,\theta)\rightarrow \top$
only if there is a thread $t$ such that $(C_t,\theta)\rightarrow \top$.
However, by ($\dag_{\downarrow}$), we get that 
for $\theta_f=(\theta_l)_1 * \ldots * (\theta_l)_{t-1} * (\theta_l)_{t+1} * \ldots * (\theta_l)_n$
it holds that $\consistent{(\theta_l)_t * \theta_s * \theta_f}$.
By assumption ($\dag_t$) and \saferef{noabort} of Definition~\ref{def:safe}, we get that $(C_t,\theta)\not\rightarrow \top$.

\gsafecond{step}
Inspecting the operational semantics, we see that $(\cp,\theta)\rightarrow (\cp',\theta')$
only if there is a thread $t$ such that $(C_t,\theta)\rightarrow (C'_t,\theta')$
for some $1 \leq t \leq n$ and 
$$
\cp'= C_1 \parallel \ldots   \parallel C'_t \parallel  \ldots \parallel   C_n\,.
$$
For $\theta_f$ as before, we get from 
assumption ($\dag_t$) and \saferef{step} of Definition~\ref{def:safe}, we get that 
there exist $\theta_l'$ and $\theta_s'$ such that 
\begin{gather*}
(\$)\;
(C_t,\theta)\rightarrow_{\ltid} (C_t',\theta_l'*\theta_s'*\theta_f)\; ,
\\
(\&)\;
\consistent{(\theta_l)_1 * \ldots * (\theta_l)_{t-1} * (\theta_l') * (\theta_l)_{t+1} * \ldots * (\theta_l)_n * \theta_s'}\,,
\end{gather*}


and either 
\begin{compactenum}
\item\label{proof:sound:prog:step}
$
(\xi\theta_s\theta_s'\vDash \Upsilon) \land
\safe_n(C_t',\theta_l',\xi\theta_s,\intp,R_t,G_t,\Upsilon,Q_t)
$ or
\item\label{proof:sound:prog:stutter}
$
(\theta'_s=\theta_s) \land (\xi\theta_s\vDash \Upsilon) 
\land 
\safe_n(C_t',\theta_l',\xi\theta_s,\intp,R_t,G_t,\Upsilon,Q_t)
$.
\end{compactenum} 

We continue be case analysis.
\begin{enumerate}
\item
Assume the first case hold.
From assumptions ($\dag_t$), ($\$$),  and \saferef{step}, we get that there exists $a \in G_t$ 
and states $\theta_{l_0}$ and $\theta_{l_1}$ 
such that 
($\%$) $(\theta_l)_t = \theta_{l_0} * \theta_{l_1}$ and 
($\ddag$) $(\theta_{l_0} , \theta_s, \theta_s') \in \db{a}$.

Recall that or every $i\in\{j \neq t \mid 1 \leq j \leq n\}$, 
it holds by assumptions of the lemma that $G_t \subseteq R_i$.
Hence, for every  such $i$, we get from ($\%$) and ($\ddag$), 
assumptions ($\dag_t$) and ($\$$)  and \saferef{env} that 
$\safe_n(C_i,(\theta_l)_i,\xi\theta_s\theta_s',\intp,R_i,G_i,Q_i)$ holds.

\item
Assume the second case hold.
To use the induction assumption, it  suffuices to show that for every $i\neq t$
it holds that $\safe_i(\kappa_i)$. This is because the shared history was not modified.
We get the desired result from assumption ($\dag_i$) and Proposition~\ref{pro:sound:lesssteps}.
\end{enumerate}

Hence, we can now apply the induction hypothesis which, recall, was for arbitrary configurations up to step $n$.
\qed
\end{proof}

\[
\begin{array}{@{}r@{}}
\infer[\textsc{Par}]{
 \vdash \{P_1 * \ldots * P_n\}\,C_1 \parallel \ldots \parallel C_n\,\{Q_1 * \ldots * Q_n\}
}{
\begin{array}{@{}c@{}}
R_1,G_1,\Upsilon  \vdash_1 \{P_1\}\,C_1\,\{Q_1\} \ 
\ldots\ 
R_n,G_n,\Upsilon  \vdash_n \{P_n\}\,C_n\,\{Q_n\}\\[2pt]
R_\ltid = \bigcup\{G_k \mid 1\leq k \leq n \land  k\neq \ltid\}
\qquad
P_1 * \ldots * P_n \Rightarrow \Upsilon
\end{array}
}
\end{array}
\]

\begin{theorem}[Soundness of Grace Logic]
  If 
  $$
  {} \vdash \{ P \} \, \cp \, \{ Q \}
  $$  
  is derivable in our logic, then
  $$  
  {} \vDash \{ P \} \, \cp \, \{ Q \}
  $$ 
  holds.
\end{theorem}
\begin{proof}
Assume $\vdash \{ P \} \, \cp \, \{ Q \}$ is derivable in our logic.
Thus, there must be a proof tree whose root is derived by rule $\textsc{Par}$
because this is the only rule that can be used to prove programs.
Hence, it must be that there exist   
\begin{compactdesc}
\item[($n$)] $n >0$,
\item[($\dag_C$)] $\cp = C_1 \parallel \ldots \parallel C_n$, 
\item[($\dag_P$)] $P = P_1 * \ldots * P_n$, 
\item[($\dag_{\Upsilon}$)] $P \implies \Upsilon$, 
\item[($\dag_Q$)] $Q = Q_1 * \ldots Q_n$, 
\item[($\dag_G^i$)] there exist  $G_1,\ldots G_n$, for $i=1,\ldots,n$,  
such that ($\dag_R^k$) $R_k = \bigcup_{\{j \neq k \mid 1 \leq j \leq n\}} G_k$, for $k=1,\ldots,n$, and
\item[($\dag_{\vdash}^i$)] the judgement   $R_i,G_i,\Upsilon  \vdash_i \{P_i\}\,C_i\,\{Q_i\}$, 
for $i = 1,\ldots, n$, is derivable in the logic. % for a thread with $\ltid=i$.
\end{compactdesc}

\smallskip 
Assume $(\theta_l,\xi\theta_s)$ is a world and $\intp$ is an interpretation such that 
$\theta_l,\xi\theta_s,\intp\vDash P$.



By ($\dag_{\Upsilon}$), it must be that ($\ddag_{\Upsilon}$) $\xi\theta_s,\intp\vDash \Upsilon$.
By ($\dag_P$) and the meaning of $*$, there must be 
($\ddag_{l}$)  $(\theta_l)_1, \ldots, (\theta_l)_n$ such that $\theta_l = (\theta_l)_1 * \ldots* (\theta_l)_n$ and ($\ddag_i$) $(\theta_l)_i,\xi\theta_s,\intp\vDash P_i$ for $i=1,\ldots,n$.
(Note that by the definition of worlds, it must be that ($\ddag_{\downarrow}$) 
$\consistent{\theta_l*\theta_s}$, and from this 
and the cancelativity of $*$, it must be that 
($\ddag^i_{l}$) $\consistent{(\theta_l)_i*\theta_s}$ for $i=1,\ldots,n$.)


By ($\dag_{\vdash}^i$) and Theorem~\ref{the:sound:thread}, it must be that
($\ddag^i_{\vDash}$) $R_i,G_i,\Upsilon \vDash_i \{P_i\}\, C_i\, \{Q_i\}$,
for $i=1,\ldots,n$.

By ($\ddag_i$), ($\ddag_{\Upsilon}$), ($\ddag^i_{\vDash}$), and Definition~\ref{def:semtriple}, 
for $i=1,\ldots,n$, 
it must be that ($\$_i$) $\safe(\kappa_i)$ holds for $\kappa_i = (C_i,(\theta_l)_i,\xi\theta_s,\intp,R_i,G_i,Q_i)$.
% $\tid$ is a constant interpreted as $t$.

By ($\ddag_l$) and ($\ddag_{\downarrow}$), we get that ($\%$)
$\consistent{(\theta_l)_1 * \ldots* (\theta_l)_n * \theta_s}$.

By  Lemma~\ref{lem:safe:par}, ($\%$), ($\$_1$),$\ldots$,($\$_n$), ($\dag_R^1$), $\ldots$,  ($\dag_R^n$),
it holds that ($\&$) $\gsafe(C_1 \parallel \ldots \parallel C_n,(\theta_l)_1 * \ldots* (\theta_l)_n, \xi\theta_s,\intp,Q_1 * \ldots * Q_n)$.

By ($\&$),  ($\dag_C$), ($\ddag_l$),  and ($\dag_Q$), we get that
$\gsafe(\cp,\theta_l,\xi\theta_s,\intp,Q)$ holds. $\qed$
\end{proof}

%\hy{Use the above lemma and prove the theorem.}

\subsection{Auxiliary Lemmas} % (fold)
\label{sec:auxiliary_lemmas}


\begin{proposition}\label{pro:sound:lesssteps}
Let $\kappa = (C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ be a configuration.
If $\safe_n(\kappa)$ hold then
$\safe_m(\kappa)$ hold for every $0 \leq m \leq n$.
\end{proposition}

\nr{Viktor proved the following using induction on $m$ but I on $n$.}

\begin{proof}
The proof is done by induction on $n$ for   arbitrary configurations.
The induction hypothesis (IH) is
\begin{multline*}
\forall m,n,\kappa' = (C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q').\,
\\
\safe_n(\kappa') \land 0 \leq m \leq n
\implies 
\safe_m(\kappa')\,. 
\end{multline*}
In the base case, $n=0$ and hence $m=0$, and the result holds from the definition of $\safe_0$
for any configuration.
For the inductive step, assume that the lemma holds for $n$.
We prove that it also holds for $n+1$.
It suffices to show that if  $\safe_{n+1}(\kappa)$ holds
then $\safe_n(\kappa)$ also hold:
once we do so, the result will follow from the induction hypothesis for any $m < n$.

Assume  ($\dagger$) $\safe_{n+1}(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ holds.
We show that $\safe_n(\kappa)$.

By assumption ($\dagger$), \saferef{done} and  
\saferef{noabort} hold as they are irrespective of $n$.

To show that \saferef{step} holds, pick an arbitrary  
$\theta_f$ such that $\consistent{\theta_l * \theta_s * \theta_f}$ holds and
an arbitrary $C'$ such that $C,\theta_l * \theta_s * \theta_f \rightarrow C',\theta'$.
Applying \saferef{step:consistent} to assumption ($\dagger$),
we get that there exist $\theta_l'$ and $\theta_s'$ 
such that $\theta'=\theta_l'*\theta_s'*\theta_f$. 
Choose the same states to show that \saferef{step} holds for $\safe_{n}(\kappa)$.
\saferef{step:consistent} holds by selection.
If \saferef{step:stutter} holds for $\safe_{n+1}(\kappa)$
then we have ($\sharp$) 
$\theta_s = \theta_s'$ and ($\ddag$) 
$\safe_{n}(C',\theta'_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$ holds.
Note, that ($\sharp$) establishes \saferef{step:stutter:same} holds.
Recall that the induction hypothesis is for arbitrary configurations.
Thus, we can use (IH) for  ($\ddag$) and $n$ to get that $\safe_{n-1}(C',\theta'_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$
which is what required to establish that \saferef{step:stutter:ind} for $\kappa$ and $n$.

Establishing \saferef{step:shared} and \saferef{env}
for $\kappa$ and $n$ is done in a similar way.
\qed\end{proof}

% subsection auxiliary_lemmas (end)

\subsubsection{Soundness of Proof Rules for Primitive Commands} % (fold)
\label{sec:sound:cprim}


\nr{Viktor did not mention this assumption about stability in RGsep.
 I am assuming stability before done.}
 
\begin{lemma}[Done]\label{lem:done}
For all $n$ and for all configurations 
$\kappa=(\done,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$
If 
\begin{compactenum}[(i)]
\item \label{lem:done:post} $\theta_l,\xi\theta_s,\intp \vDash Q$, 
\item \label{lem:done:inv} $\xi\theta_s \vDash \Upsilon$, and
\item \label{lem:done:stable} $Q$ is stable with respect to $R$ and $\Upsilon$ 
\end{compactenum}
then 
$\safe(\kappa)$.
\end{lemma}

\begin{proof}
The proof is done by induction on $n$ and for arbitrary configurations for  $\done$.
The induction hypothesis is (IH)
\begin{multline*}
\forall n,\kappa'=(\done,\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q').\, \\
\theta_l',\xi'\theta'_s,\intp' \vDash Q' \land \xi'\theta'_s \vDash \Upsilon' \land \stable{Q'}{R'}{\Upsilon'} \\
\hfill 
\implies
\safe_n(\kappa')\,.
\end{multline*}
For $n=0$, the induction holds by definition.
We assume now that the induction hypothesis holds for $n$ and show that it holds for $n+1$:
\saferef{done} holds by assumptions  (\ref{lem:done:post}) and  (\ref{lem:done:inv}).
\saferef{noabort} and \saferef{step} hold vacuously because no transition leaves \textsf{done}.
We show that \saferef{env} holds using the induction assumption for 
$\safe_n(\textsf{done},\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon,Q)$.
This is possible because the induction hypothesis was for arbitrary configurations for  \textsf{done} and 
all three requirements of the lemma hold:
The first requirement (\ref{lem:done:post}) follows from the 
three assumptions made in \saferef{env} on $\theta^s$ 
together with the assumed stability of $Q$ with respect to $R$ and $\Upsilon$. 
The second requirement (\ref{lem:done:inv})  holds because of 
the assumption made in \saferef{env:inv} on $\theta^s$. 
The third requirement is the same as assumption (\ref{lem:done:stable}) of the lemma.
\qed\end{proof}




\begin{lemma}[Local]\label{lem:local}
For all $n$ and for all 
configurations $\kappa=(\alpha,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, q)$
if 
\begin{compactenum}[(i)]
\item \label{lem:local:inv} 
$\xi\theta_s\vDash\Upsilon$, 
\item 
$c\in\PComm \setminus\{\done\}$, 
\item \label{lem:local:post}
$f^{\ltid}_\alpha(\theta_l) \subseteq \db{q}_{\intp}$, and  
\item 
$f^{\ltid}_\alpha$ is local,\footnote{For a discussion about  local commands see   
\S\ref{sec:pcomm}.} 
i.e., $\forall \theta.\, \consistent{\theta*\theta_l} \land \consistent{f^{\ltid}_c(\theta_l)} \Rightarrow f^{\ltid}_c(\theta *\theta_l) = f^{\ltid}_c(\theta_l)*\{\theta\}$
\end{compactenum}
then $\safe_n(\kappa)$.
\end{lemma}

\begin{proof}
Formally, the proof is done by induction on $n$.
The induction hypothesis is  (IH)  
\begin{multline*}
  \forall \alpha,\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', q'.\,
   f^{\ltid}_{\alpha}(\theta_l') \subseteq \db{q}_{\intp'} \implies \mbox{}\\
    (\forall \theta.\, \consistent{\theta*\theta'_l} \land \consistent{f^{\ltid}_c(\theta_l')} \Rightarrow
     f^{\ltid}_\alpha(\theta *\theta'_l) = f^{\ltid}_\alpha(\theta'_l)*\{\theta\})
  \implies \mbox{}\\
  \safe_n(\alpha,\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', q')\,.
\end{multline*}
In the base case, 
$\safe_0(\kappa)$ holds by definition.
Assume the induction assumption holds for $n$. 
We show that $\safe_{n+1}(\kappa)$ also holds.

\safecond{done}: 
Holds trivially as $\alpha \neq \done$.

\safecond{noabort}:
Pick an arbitrary $\theta_f$ such that ($\&$)  $\consistent{\theta_l*\theta_s*\theta_f}$.
By assumption  $f^{\ltid}_\alpha(\theta_l) \subseteq \db{q}$. This  implies that ($\dagger$) 
$f^{\ltid}_\alpha(\theta_l) \neq \top$. The result follows from ($\dagger$) and   
the locality of $f^{\ltid}_\alpha$.

\safecond{step}: 
Consulting the operational semantics, we see that the only possible transitions
for $c$ and $\theta_f$ as above are
$c, \theta_l*\theta_s*\theta_f \rightarrow \done,\theta'$ 
where $\theta' \in f^{\ltid}_\alpha(\theta_l*\theta_s*\theta_f)$.
From the locality of $f^{\ltid}_\alpha$ and ($\dag$), 
we get that there exists $\theta'_l$ such that 
($\ddag$) $\theta'_l \in f^{\ltid}_\alpha(\theta_l)$ and
($\sharp$)  $\theta'=\theta'_l * \theta_s * \theta_f$. 
We show that \saferef{step} holds using
$\theta'_l$ 
and  $\theta'_s = \theta_s$.
This choice satisfies \saferef{step:consistent} and \saferef{step:stutter:same} 
by ($\&$) and ($\sharp$), respectively.
To show that \saferef{step:stutter:ind} is satisfied,  
we need to show that $\safe_{n}(\kappa')$ holds
where $\kappa'=\safe_n(\done,\theta'_l,\xi\theta_s,\intp,R,G,\Upsilon, q)$. 

We show that $\safe_{n}(\kappa')$ holds using Lemma~\ref{lem:done}.
Note that the requirements of the lemma are satisfied:
\begin{compactitem}
\item
Requirement~(\ref{lem:done:post}) is satisfied because by assumption (\ref{lem:local:post}) and $(\ddag)$
$\theta'_l,\intp \vDash q$. As an assertion on worlds, $q$ 
places no restrictions on the history. 
Thus, it also holds that $\theta'_l,\xi\theta_s\intp \vDash q$.   
\item
Requirement~(\ref{lem:done:inv}) is satisfied by Assumption~(\ref{lem:local:inv})
of this lemma.
\item
Requirement~(\ref{lem:done:stable}) is satisfied because $q$ is independent of the history.
\end{compactitem}

\safecond{env}: 
We establish the result using the induction assumptions.
This is possible because  $q$ is independent of the history, $\theta_l$ is local and thus does not   change,
and the environment preserves $\Upsilon$.
\qed\end{proof}

%\nr{define $\vDash$ notation for satisfaction for assertions and invariant.}


% subsection soundness_of_cprim_proof_rule (end)

\subsubsection{Soundness of Proof Rules for Composite Commands} % (fold)
\label{sec:sound:composite}




%\nr{We need that $Id$ is in $G$.}
\begin{lemma}[Seq]\label{lem:seq}
For all $n$ and for all 
configurations $\kappa_1 = (C_1,\theta^1_l,\xi^1\theta^1_s,\intp,R,G,\Upsilon, Q_1)$
if  
\begin{compactenum}[(i)]
\item \label{lem:seq:c}
$\safe_n(\kappa_1)$ holds,
\item \label{lem:seq:cc}
for every $\kappa_2 = (C_1,\theta^2_l,\xi^2\theta^2_s,\intp,R,G,\Upsilon, Q_2)$ 
if $\xi^2\theta^2_s \vDash \Upsilon$ and $\theta^2_l,\xi^2\theta^2_s,\intp \vDash Q_1$  hold
then $\safe_n(\kappa_2)$ holds, and
\item \label{lem:seq:c}
$Q_1$ is stable under $R$ and $\Upsilon$. 
\end{compactenum}
then  $\safe_n(\kappa)$ where 
$\kappa=(C_1;C_2,\theta^1_l,\xi^1\theta^1_s,\intp,R,G,\Upsilon, Q_2)$.
\end{lemma}


\begin{proof}
%The proof is done by induction on $n$ and for arbitrary configurations $k'_1$ and $k'_2$
%for which the requirements of the lemma hold.
The proof is done by induction on $n$ and for arbitrary configurations.
The induction hypothesis (IH)  is 
\begin{multline*}
  \forall \kappa_1' = (C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q').\,\\ \safe_n(\kappa_1) \land \stable{Q_1}{R}{\Upsilon} \land
  \mbox{}\\
  \Big(
	\big(\forall \kappa_2''=(C'',\theta''_l,\xi''\theta''_s,\intp',R',G',\Upsilon', Q'').\quad\qquad\qquad\qquad\\ 
	\theta'_l,\xi'\theta'_s,\intp' \vDash Q' 
	\land \mbox{} 
    \xi''\theta''_s \vDash \Upsilon''\big)  \implies 
    \safe_n(\kappa''_2)\Big) 
  \implies \mbox{}\\
  \hfill
  \safe_n(C';C'',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q'')\,.
\end{multline*}
In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
($\dagger_1$) $\safe_{n+1}(\kappa_1)$   
and that assumption~(\ref{lem:seq:cc}) holds for $n+1$.
(Note that the latter together with Proposition~\ref{pro:sound:lesssteps} means that 
($\dag_2$) assumption~(\ref{lem:seq:cc}) holds for $n$.)
We now show that 
$\safe_{n+1}(\kappa)$ 
also holds.


\safecond{done}:
Holds trivially because $C_1 ; C_2$ is  not \textsf{done}.


\safecond{noabort}: 
Consider a state $\theta_f$ such that ($\dag$) $\consistent{\theta^1_l*\theta^1_s*\theta_f}$.
Consulting the operational semantics, we see that 
$C_1 ; C_2, \theta^1_l*\theta^1_s*\theta_f$  can reduce in one step to $\top$ only 
if $C_1, \theta^1_l*\theta^1_s*\theta_f$ does so,
which contradicts assumption ($\dagger_1$).

\safecond{step}: 
For $\theta_f$ as above, we consult the operational semantics and see that
there can be two cases.
Either $C_1=\done$, 
and  
$C_1 ; C_2, \theta^1_l*\theta^1_s*\theta_f \rightarrow C_2,\theta^1_l*\theta^1_s*\theta_f$
or 
$C_1, \theta_l*\theta_s*\theta_f \rightarrow C_1',\theta'$
and 
$C_1;C_2, \theta_l*\theta_s*\theta_f \rightarrow C_1';C_2,\theta'$.

In the first case, we choose 
$\theta'_l=\theta^1_l$   
and  $\theta'_s = \theta^1_s$.
\saferef{step:consistent} and \saferef{step:stutter:same} are satisfied by this choice and ($\dag$).
To show that \saferef{step:stutter:ind} is satisfied, we need to show that 
$\safe_n(C_2,\theta^1_l,\xi^1\theta^1_s,\intp,R,G,\Upsilon, Q_2)$ holds.
To do so, we use ($\dag_1$) and \saferef{done}, which, as $C_1=\done$,
give us that 
$\xi^1\theta^1_s \vDash \Upsilon$ and $\theta^1_l,\xi^1\theta^1_s,\intp \vDash Q_1$.
Using ($\dag_2$), gives us 
%$\safe_{n+1}(C_2,\theta^1_l,\xi^1\theta^1_s,\intp,R,G,\Upsilon, Q_2)$  holds.
%Using  
%Proposition~\ref{pro:sound:lesssteps}, we get
the desired result.
%
%The assumption that $G$  allows stuttering establishes \saferef{step:guarantee}.
%The closure of $\Upsilon$ under stuttering ensures \saferef{step:inv} is satisfied
%we need to show that $\safe_n()$ holds.
%The assumed 
%safety of $\kappa_1$ for $n+1$ steps ($\dag_1$)
%and \saferef{done}
%ensure that $\theta^1_l*\theta^1_s*\theta_f,\intp\vDash Q_1$ and that
%$\xi\theta_s^1\vDash \Upsilon$.
%Thus, the lemma requirements are satisfied and we can use the 
%induction hypothesis to establish that 
%$\safe_n(C_2,\theta^1_l,\xi^1\theta^1_s\theta^1_s,\intp,R,G,\Upsilon, Q_2)$.
%
%\nr{the choice of the history above is slightly weird.}

In the second case, we may assume that $C_1$ is not $\done$.
From ($\dag_1$), 
there must be 
$\theta'_l$ and $\theta'_s$  such that $\theta'=\theta'_l * \theta'_s * \theta_f$
which justify the transition 
$C_1, \theta_l*\theta_s*\theta_f \rightarrow C_1',\theta'$.
Pick the same states.
By choice, these states satisfy \saferef{step:consistent} and either  
\saferef{step:shared} or \saferef{step:stutter}.
Let $\xi'=\xi^1\theta^1_s\theta^{1'}_s$  in the first case and $\xi'=\xi^1\theta^1_s$ in the second case.
Note that the above choice also ensures that ($\ddag$)  
$\safe_n(C'_1, \theta'_l,\xi',\intp,R,G,\Upsilon, Q_1)$ holds.
Using ($\dagger_2$) and the induction hypothesis, which recall was for arbitrary configurations,
we get that 
$\safe_n(C'_1;C_2, \theta'_l,\xi',\intp,R,G,\Upsilon, Q_2)$ holds, as required.

%
%
%In the second case, we may assume that $C_1$ is not $\done$.
%As $\safe_{n+1}(\kappa_1)$ is assumed to hold ($\dag_1$) 
%there must be 
%$\theta'_l$, $\theta_{l_0}$, $\theta_{l_1}$, and $\theta'_s$ 
%which justify the transition 
%$C_1, \theta_l*\theta_s*\theta_f \rightarrow C_1',\theta'$.
%Pick the same four states.
%By choice, these states satisfy \saferef{step:consistent}, \saferef{step:guarantee}, and 
%\saferef{step:inv}.
%Furthermore, this choice also ensures that ($\ddag$)  
%$\safe_n(C'_1, \theta^1_l,\xi^1\theta^1_s\theta'_s,\intp,R,G,\Upsilon, Q_1)$ holds.
%We are now ready to establish \saferef{step:ind} of $\safe_{n+1}(\kappa)$:
%We use ($\dag_2$) and Proposition~\ref{pro:sound:lesssteps}
%to get that $\safe_n(\kappa_2)$ holds.
%This, together  with ($\ddag$) and the induction hypothesis,
%establishes that $\safe_n(C'_1;C_2, \theta^1_l,\xi^1\theta^1_s\theta'_s,\intp,R,G,\Upsilon, Q_2)$
%holds, as required.


\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^s$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
As the same $R$ and $\Upsilon$ are used in the premise of 
\saferef{env} for $\safe_{n+1}(\kappa_1)$--which is assumed to 
hold $(\dag_1)$--we get that ($\sharp$)
$\safe_n(C_1,\theta^1_l,\xi^1\theta^1_s\theta^s,\intp,R,G,\Upsilon, Q_1)$
holds. 
%Using that, ($\dag_2$), and the induction hypothesis  and Proposition~\ref{pro:sound:lesssteps}
%to get that $\safe_n(\kappa_2)$ holds.
Using that, ($\sharp$), and the induction hypothesis, we establish that 
$\safe_n(C_1;C_2, \theta^1_l,\xi^1\theta^1_s\theta^s,\intp,R,G,\Upsilon, Q_2)$
holds, as required.
Note that we can use the induction hypothesis because 
$\xi\theta_s\theta^s\vDash\Upsilon$ holds from \saferef{env:inv} for ($\sharp$)and 
$\theta_l,\xi\theta_s\theta^s,\intp\vDash Q_1$ holds from the stability of $Q_1$ under $R$ and $\Upsilon$.

%
%We use ($\dag_2$) and Proposition~\ref{pro:sound:lesssteps}
%to get that $\safe_n(\kappa_2)$ holds.
%Using that, ($\sharp$), and the induction hypothesis, we establish that 
%$\safe_n(C_1;C_2, \theta^1_l,\xi^1\theta^1_s\theta^s,\intp,R,G,\Upsilon, Q_2)$
%holds, as required.
%We can use the induction hypothesis because 
%$\xi\theta_s\theta^s\vDash\Upsilon$ holds from \saferef{env:inv} for ($\sharp$) 
%$\theta_l,\xi\theta_s\theta^s,\intp\vDash Q_1$ holds from the stability of $Q_1$ under $R$ and $\Upsilon$.
\qed\end{proof}

\begin{lemma}[Choice]\label{lem:choice}
For all $n$ and for all 
configurations $\kappa = (C_1 + C_2,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$
if
$\safe_n(C_1,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$
and 
$\safe_n(C_2,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$
then 
$\safe_n(\kappa)$.
\end{lemma}

\begin{proof}
The proof is done by induction on $n$ and for arbitrary configurations.
The base case ($n=0$) holds by definition.
For the inductive step, 
assume 
($\dagger_i$) $\safe_{n+1}(C_i,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$  
hold for $i=1,2$.
We now show that 
$\safe_{n+1}(C_1 + C_2,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)$ 
also holds.

\safecond{done} holds trivially 
 because $C_1 + C_2 \neq \done$.

\safecond{noabort}
$C_1 + C_2$ never transitions to $\top$.
%To see that \saferef{noabort} holds, we consult the operational semantics and see that 
%$C_1 + C_2$  can reduce in one step to $C_1$ or to $C_2$,  but never reduces to $\top$ in one step.
%The operational semantics also helps  us establish \saferef{step}:
%If the transition taken from $C_1 + C_2$ leads to $C_i$ (where $i=1$ or $2$) then 
%($\dagger_i$) together with Proposition~\ref{pro:sound:lesssteps} 
%implies  that \saferef{step} hold.

\safecond{step}
From the operational semantics,
$C_1 + C_2, \theta \rightarrow C_i,\theta$ for either $i=1$ or $i=2$.
The result follows from  the induction hypothesis after
applying  Proposition~\ref{pro:sound:lesssteps} to ($\dagger_1$) and ($\dagger_2$).



%From ($\dag_1$), 
%there must be 
%$\theta'_l$ and $\theta'_s$  such that $\theta'=\theta'_l * \theta'_s * \theta_f$
%which justify the transition 
%$C_1, \theta_l*\theta_s*\theta_f \rightarrow C_1',\theta'$.
%Pick the same states.
%By choice, these states satisfy \saferef{step:consistent} and either  
%\saferef{step:shared} or \saferef{step:stutter}.
%Let $\xi'=\xi^1\theta^1_s\theta^{1'}_s$  in the first case and $\xi'=\xi^1\theta^1_s$ in the second case.
%Note that the above choice also ensures that ($\ddag$)  
%$\safe_n(C'_1, \theta'_l,\xi',\intp,R,G,\Upsilon, Q)$ holds.
%Using ($\ddag$) and the induction hypothesis, which recall was for arbitrary configurations,
%we get that 
%$\safe_n(C'_1+C_2, \theta'_l,\xi',\intp,R,G,\Upsilon, Q)$ holds, as required.


\safecond{env}
To establish \saferef{env}, we need to show that 
$\safe_n(C_1+C_2,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon,Q)$ holds
for $\theta^l$ and $\theta^s$ that satisfy the assumed conditions for $\theta_l$, $R$, and $\Upsilon$.
As these conditions are insensitive to the command of the configuration,
assumptions ($\dagger_1$) and ($\dagger_2$) 
gives us that 
$\safe_n(C_i,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon,Q)$
for $i=1$ and $i=2$, respectively.
Using the induction hypothesis (recall that the induction hypothesis is for 
arbitrary configurations)
we get that $\safe_n(C_1+C_2,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon,Q)$ holds.
\qed\end{proof}


\begin{lemma}[Iter]\label{lem:iter}
For all $n$ and for all 
configurations $\kappa_1=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$
if  
\begin{compactenum}[(i)]
\item \label{lem:iter:safen}
$\safe_n(\kappa_1)$ holds and
\item \label{lem:iter:prepost}
$\theta_l,\xi\theta_s,\intp \vDash Q$ and $\xi\theta_s \vDash \Upsilon$
\end{compactenum}
then  $\safe_n(\kappa)$ where 
$\kappa=(C^*,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$.
\end{lemma}


\begin{proof}
The proof is done by induction on $n$.
In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
($\dagger_1$) $\safe_{n+1}(\kappa_1)$ holds, ($\dagger_2$) assumption~(\ref{lem:iter:prepost}) holds, 
and the induction hypothesis (IH)  
\begin{multline*}
  \forall C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q'.\,
  \mbox{}\\
  \big(\safe_n(C',\theta'_l,\xi'\theta_s',\intp',R',G',\Upsilon', Q') 
  \land 
  \theta'_l,\xi'\theta'_s,\intp' \vDash Q'
  \land \mbox{}\\
  \xi'\theta'_s \vDash \Upsilon' \big)
  \implies 
  \safe_n(C'^*,\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q')\,.
\end{multline*}
We now show that $\safe_{n+1}(\kappa)$ also holds.


 
\safecond{done} holds trivially as $C^* \neq\done$.

\safecond{noabort} is done in the same way as in 
  Lemma~\ref{lem:seq}, using $C$ instead of $C_1$ and $C^*$ instead of $C_2$.

\safecond{step}: 
Pick an arbitrary $\theta_f$ such that ($\dagger$) $\consistent{\theta_l*\theta_s*\theta_f}$.
We show that \saferef{step} holds using
$\theta'_l=\theta_l$ and 
 $\theta'_s = \theta_s$.
This choice satisfy \saferef{step:stutter:same} and, with ($\dagger$) , it also satisfies 
\saferef{step:consistent}.
% by ($\dag_2$). 

  
To establish \saferef{step:ind},
we consult the operational semantics, 
and see that there can be two cases.
Either
$C^*, \theta_l*\theta_s*\theta_f \rightarrow \done,\theta_l*\theta_s*\theta_f$
or 
$C^*, \theta_l*\theta_s*\theta_f \rightarrow C;C^*,\theta_l*\theta_s*\theta_f$.

%Consulting the operational semantics, 
%and see that there can be two cases:
%Either
%$C^*, \theta_l*\theta_s*\theta_f \rightarrow \done,\theta_l*\theta_s*\theta_f$
%or 
%$C^*, \theta_l*\theta_s*\theta_f \rightarrow C;C^*,\theta_l*\theta_s*\theta_f$.

In the first case, we use Lemma~\ref{lem:done} to show that
$\safe_n(\done,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ holds.
We can use the lemma because 
$\theta_l,\xi\theta_s,\intp \vDash Q$ and $\xi\theta_s \vDash \Upsilon$ hold
by assumption (\ref{lem:iter:prepost}).



%In the first case, we use Lemma~\ref{lem:done} to show that
%$\safe_n(\done,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ holds.
%We can use the lemma because 
%$\theta_l,\xi\theta_s,\intp \vDash Q$ and $\xi\theta_s \vDash \Upsilon$ hold
%by assumption (\ref{lem:iter:prepost}).

In the second case, we use Lemma~\ref{lem:seq} 
to show that
$\safe_n(C;C^*,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ holds.
We can use the lemma because assumption $(\dag_1)$ and Proposition~\ref{pro:sound:lesssteps} 
ensure that 
$\safe_{n}(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ holds
and (IH) ensures that 
$\safe_{n}(C*,\theta'_l,\xi'\theta'_s,\intp,R,G,\Upsilon, Q)$
hold for every $\theta'_l$ and $\xi'\theta'_s$ such that
$\theta'_l,\xi'\theta'_s,\intp \vDash Q$ and $\xi'\theta'_s \vDash \Upsilon$.

\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^s$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
As the same $G$ and $\Upsilon$ are used in the premise of 
\saferef{env} for $\safe_{n+1}(\kappa_1)$--which is assumed to 
hold $(\dag_1)$--we get that ($\sharp$)
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, Q)$
holds.
Using ($\sharp$) and the induction hypothesis, we establish that 
$\safe_n(C^*, \theta^1_l,\xi^1\theta^1_s\theta^s,\intp,R,G,\Upsilon, Q_2)$
holds, as required.
We can use the induction hypothesis because 
$\xi\theta_s\theta^s\vDash\Upsilon$ holds from \saferef{env:inv} for ($\sharp$) and
$\theta_l,\xi\theta_s\theta^s,\intp\vDash Q$ holds  from the stability of $Q$ under $R$ and $\Upsilon$.
\qed\end{proof}

% subsubsection soundness_of_proof_rules_for_composite_commands (end)


% subsubsection soundness_of_proof_rule_for_local_commands (end)

\subsubsection{Soundness of Structural Proof Rules} % (fold)
\label{sec:sound:structural}

\nr{Need to fix these so we satisfy \saferef{step}
using \saferef{step:stutter} and say that the history does not change}


\begin{lemma}[Disj]\label{lem:disj}
For all $n$ and for all 
configurations 
$\kappa_1=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q_1)$
and
$\kappa_2=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q_2)$
if  
%\begin{compactenum}[(i)]
%\item \label{lem:iter:postab}
$\safe_n(\kappa_1)$ holds or $\safe_n(\kappa_2)$ holds %', and
%\item \label{lem:disj:inv}
%$\xi\theta_s \vDash \Upsilon$
%\end{compactenum}
then  
$\safe_n(\kappa)$ holds 
where $\kappa=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q_1 \lor Q_2)$.
\end{lemma}


\begin{proof}
The proof is done by induction on $n$.
In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
the induction hypothesis (IH)  
\begin{multline*}
  \forall C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_1', Q_2',.\,
  \big(\xi'\theta_s' \vDash \Upsilon' \land \mbox{}\\
  (\safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_1') \lor \mbox{}\\
   \safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_2'))\big)\\ 
   \mbox{}\implies  \safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_1' \lor Q'_2)   
\end{multline*}
and that ($\dagger_1$) $\safe_{n+1}(\kappa_1)$ holds.
(The case where $\safe_{n+1}(\kappa_1)$ is symmetric.)
We now show that $\safe_{n+1}(\kappa)$ also holds.

\safecond{done} 
If $C = \done$ then by assumption ($\dagger_1$) we get that 
$\theta_l,\xi\theta_s,\intp \vDash Q_1$, and thus, $\theta_l,\xi\theta_s,\intp \vDash Q_1 \lor Q_2$,
and as \saferef{done}, in particlar, is assumed to hold in ($\dagger_1$) 
%assumption(\ref{lem:disj:inv})
we get that $\xi\theta_s \vDash \Upsilon$.


\safecond{noabort} 
If $C=\done$, we are done.
Otherwise, 
pick an arbitrary $\theta_f$ such that ($\dagger$) $\consistent{\theta_l*\theta_s*\theta_f}$.
If $C,\theta_l*\theta_s*\theta_f \rightarrow \top$   we get a contradiction to ($\dagger_1$),
which is  assumed to hold.



\safecond{step}: 
If $C=\done$, we are done.
Otherwise, 
for the same $\theta_f$ as before, 
assume
$C, \theta_l*\theta_s*\theta_f \rightarrow C,\theta'$.
As $\safe_{n+1}(\kappa_1)$ is assumed to hold ($\dag_1$) 
there must be 
$\theta'_l$  and $\theta'_s$  such that ($\dag$) $\theta'=\theta'_l*\theta'_s*\theta_f$ 
which justify the transition. 
Pick the same   states.
Pick the same states.
By choice, these states satisfy \saferef{step:consistent} and either  
\saferef{step:shared} or \saferef{step:stutter}.
Let $\xi'=\xi^1\theta^1_s\theta^{1'}_s$  in the first case and $\xi'=\xi^1\theta^1_s$ in the second case.
Note that the above choice also ensures that ($\ddag$)  
$\safe_n(C'_1, \theta'_l,\xi',\intp,R,G,\Upsilon, Q_1)$ holds.
Using ($\ddag$) and the induction hypothesis, which recall was for arbitrary configurations,
we get that 
$\safe_n(C, \theta'_l,\xi',\intp,R,G,\Upsilon, Q_1 \lor Q_2)$ holds, as required.



%By choice and ($dag$), these states satisfy \saferef{step:consistent} and \saferef{step:stutter:same}.
%The choice also  ensures that
%$\safe_n(C, \theta_l,\xi\theta_s\theta'_s,\intp,R,G,\Upsilon, Q_1)$ holds.
%Hence, we can use the induction hypothesis,
%to establish that $\safe_n(\kappa)$
%holds, as required.

%If $C=\done$, we are done.
%Otherwise, 
%for the same $\theta_f$ as before, 
%and as $\safe_{n+1}(\kappa_1)$ is assumed to hold ($\dag_1$) 
%there must be 
%$\theta'_l$, $\theta_{l_0}$, $\theta_{l_1}$, and $\theta'_s$ 
%which justify the transition 
%$C, \theta_l*\theta_s*\theta_f \rightarrow C,\theta'$.
%Pick the same four states.
%By choice, these states satisfy \saferef{step:consistent}, \saferef{step:guarantee}, and, 
%in particular, \saferef{step:inv}, i.e., that $\xi\theta_s\theta'_s,\vDash\Upsilon$.
%It also ensures that
%$\safe_n(C, \theta_l,\xi\theta_s\theta'_s,\intp,R,G,\Upsilon, Q_1)$ holds.
%Hence, we can use the induction hypothesis,
%to establish that $\safe_n(\kappa)$
%holds, as required.


\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^s$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
As the same $R$ and $\Upsilon$ are used in the premise of 
\saferef{env} for $\safe_{n+1}(\kappa_1)$--which is assumed to 
hold $(\dag_1)$--we get that ($\sharp$)
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, Q_1)$ holds.
Using the induction hypothesis and 
that
$\xi\theta_s\theta^s\vDash\Upsilon$ holds (by \saferef{env:inv} for ($\sharp$))
we establish that 
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, Q_1 \lor Q_2)$
as required.
% $\theta_l,\xi\theta_s\theta^s,\intp\vDash Q_1$ holds from the stability of $Q_1$ under $R$ and $\Upsilon$.
\qed\end{proof}

\[
\infer[\textsc{Conseq}]{
R, G,\Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
}{
\begin{array}{@{}c@{}}
P \wedge \Upsilon \Rightarrow P' \quad R \Rightarrow R' \quad
G' \Rightarrow G \quad Q' \wedge \Upsilon \Rightarrow Q
\\[2pt]
 R', G',\Upsilon \vdash_\ltid \{P'\}\,C\,\{Q'\} 
\end{array}
} 
\]

\begin{lemma}[Conseq]\label{lem:Conseq}
For all configurations  $\kappa=(C^0,\theta^0_l,\xi^0\theta^0_s,\intp^0,R,G,\Upsilon, Q)$
and for all assertions $P'$ and $Q'$ and sets of actions $R'$
and $G'$.
%for all configuration  $\kappa_1=(C,\theta_l,\xi\theta_s,\intp,R',G',\Upsilon, Q')$
If 
\begin{compactenum}
\item \label{lem:conseq:preP}
$\theta^0_l,\xi^0\theta^0_s,\intp\vDash P$,
\item \label{lem:conseq:preInv}
$\xi^0\theta^0_s,\intp^0\vDash \Upsilon$,
\item \label{lem:conseq:P}
$P \land \Upsilon \implies P'$,
\item \label{lem:conseq:Q}
$Q' \land \Upsilon \implies Q$,
\item \label{lem:conseq:R}
$R \implies R'$,
\item \label{lem:conseq:R}
$G' \implies G$, and 
\item \label{lem:conseq:safe}
%$\safe_n(\kappa_1)$ % and $X$ is not a free variable in either $R$ or $G$, 
$R',G',\Upsilon \vDash_{\ltid}  \{ P'\} C^0 \{Q'\}$
\end{compactenum}
then  
$\safe_n(\kappa)$.
% holds,
%where $\kappa=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, \exists X.\, Q)$.
\end{lemma}


\begin{proof}
By assumptions (\ref{lem:conseq:preP}) and (\ref{lem:conseq:preInv})
we get that 
\[
 \theta^0_l,\xi^0\theta^0_s,\intp^0 \vDash P \land \Upsilon\,.
\]
(Recall that $\Upsilon$ does not restrict the local state.)
By this and assumption (\ref{lem:conseq:P}),
we get that 
\[
 \theta^0_l,\xi^0\theta^0_s,\intp^0 \vDash P'\,.
\]
By this, and assumptions (\ref{lem:conseq:preInv}) and (\ref{lem:conseq:safe}),
we get that 
\[
 (\$\$) \; \safe(\kappa^0) \;\text{where}\; \kappa^0 = (C,\theta^0_l,\xi^0\theta^0_s,\intp^0,R',G',\Upsilon, Q')\,.
\]
We now show that $ (\$\$)$  implies the desired result.


The proof continues by induction on the number of steps $n$.
In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
the induction hypothesis (IH)  
\begin{multline*}
  \forall C^1,\theta^1_l,\xi^1\theta^1_s,\intp^1,R^1,G^1,\Upsilon, Q^1, R^2,G^2,P^2,Q^2.\,
  \\
  \big(%(\theta^1_l,\xi^1\theta^1_s,\intp^1 \vDash P^1) \land
  %(\xi^1\theta^1_s,\intp^1 \vDash \Upsilon) \land \mbox{} \qquad\qquad\qquad\\
  (P^1 \land \Upsilon \implies P^2) \land 
  (Q^2 \land \Upsilon \implies Q^1) \land \mbox{} \qquad\\ 
  (R^2 \implies R^1) \land 
  (G^1 \implies G^2) \land \mbox{} \qquad\qquad\\
  \safe_n(C^1,\theta^1_l,\xi^1\theta^1_s,\intp^1,R^2,G^2,\Upsilon, Q^2)\big)
  %R^2,G^2,\Upsilon \vDash_{\ltid}^n \{ P^2 \} \,C^1 \,\{Q^2\}\big) 
  \implies \mbox{} \\
  \safe_n(C^1,\theta^1_l,\xi^1\theta^1_s,\intp^1,R^1,G^1,\Upsilon, Q^1)    
\end{multline*}
and that 
$$
(\$) \;\safe_{n+1}(\kappa') \quad \text{for} \quad \kappa' = (C,\theta_l,\xi\theta_s,\intp,R',G',\Upsilon, Q')\,.
$$
%
%$R',G',\Upsilon \vDash_{\ltid}^{n+1} \{ P'\}\, C \,\{Q'\})$ holds.
We now show that $\safe_{n+1}(\kappa)$ also holds.



\safecond{done} 
If $C = \done$ then by ($\$$), 
we get that $\theta_l,\xi\theta_s,\intp \vDash Q'$
and that $\xi\theta_s \vDash \Upsilon$.
Hence,
$$
\theta_l,\xi\theta_s,\intp \vDash Q' \land \Upsilon\,.
$$

By this and assumption (\ref{lem:conseq:Q}),
we get that 
$(\theta_l,\xi\theta_s,\intp \vDash   Q)$. 
%using the intepretatio$\theta$ for al free occurrences of $X$ in $Q$.

\safecond{noabort} 
If $C=\done$, we are done.
Otherwise, 
pick an arbitrary $\theta_f$ such that %($\dagger$) 
$\consistent{\theta_l*\theta_s*\theta_f}$.
If $(C,\theta_l*\theta_s*\theta_f \rightarrow \top)$   we get a contradiction to ($\$$).

\safecond{step}: 
If $C=\done$, we are done.
Otherwise, 
for the same $\theta_f$ as before
assume $(C, \theta_l*\theta_s*\theta_f \rightarrow C',\theta')$. 
%As $\safe_{n+1}(\kappa_1)$ is assumed to hold ($\dag_1$), 
By ($\$$), 
there must be  $\theta'_l$  and $\theta'_s$ such that 
($\dag$) $\theta' = \theta_l' * \theta_s' * \theta_f$ 
which justify the transition for $\kappa'$ to be safe up to $n+1$ steps.

Pick the same   states $\theta'_l$  and $\theta'_s$  as above.
We now show that \saferef{step} also holds for $\kappa$ and $n+1$ steps. 
By choice, these states satisfy \saferef{step:consistent} and either  
\saferef{step:shared} or \saferef{step:stutter} for $\kappa'$ to be safe up to $n+1$ steps.
%:h
In the first case, 
choose the  history of the shared state to be  
$\xi\theta_s\theta^{'}_s$.
By \saferef{step:guarantee}, there exist $a \in G'$ and states $\theta'_{l_0}$ and $\theta'_{l_1}$
such that $\theta'_{l} = \theta'_{l_0} * \theta'_{l_1}$  and
$(\theta'_l,\theta_s,\theta_s',\intp \vDash a)$.
Recall that $G' \implies G$, hence $\db{a}\subseteq \db{G}$.
This satisfies \saferef{step:guarantee} for $\kappa$. 
By \saferef{step:inv}, $(\xi\theta_s\theta_s',\intp \vDash \Upsilon)$.
This satisfies \saferef{step:inv} for $\kappa$. 
By \saferef{step:ind}, it holds that 
$\safe_n(C',\theta'_l,\xi'\theta_s\theta_s',\intp,R',G',\Upsilon,Q')$.
Using this and the induction hypothesis, we get
$\safe_n(C',\theta'_l,\xi'\theta_s\theta_s',\intp,R,G,\Upsilon,Q)$,
which satisfies  \saferef{step:ind} for $\kappa$.


In the second case, pick $\xi\theta_s$ as the history of the shared state.
As we do not change the history, this satisfies \saferef{step:stutter:same}.
As \saferef{step:stutter:ind} holds for $\kappa'$, we get that 
$\safe_n(C',\theta'_l,\xi'\theta_s,\intp,R',G',\Upsilon,Q')$ holds.
Using this and the induction hypothesis, we get
$\safe_n(C',\theta'_l,\xi'\theta_s\theta_s',\intp,',G,\Upsilon,Q)$,
which satisfies  \saferef{step:stutter:ind} for $\kappa$.


%Note that the above choice also ensures that ($\ddag$)  
%$\safe_n(C'_1, \theta'_l,\xi',\intp,R',G,'\Upsilon, Q')$ holds.
%Using ($\ddag$) and the induction hypothesis, which recall was for arbitrary configurations,
%we get that 
%$\safe_n(C, \theta'_l,\xi',\intp,R,G,\Upsilon, \exists X.\,Q)$ holds, as required.
%

\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^{s}$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
By ($\ref{lem:conseq:R}$), we get that $\db{R} \subseteq \db{R'}$. 
Hence, %because we use the set of relies  $R'$ and the invariant  $\Upsilon$   
%in the premise of 
from \saferef{env} for $\safe_{n+1}(\kappa_1)$--which is assumed to 
hold $(\$)$--we get that ($\sharp$)
$\safe_n(C,\theta_l,\xi\theta_s\theta^{s},\intp,R',G',\Upsilon, Q')$.
Using the induction hypothesis 
%and 
%that
%$\xi\theta_s\theta^{s'}\vDash\Upsilon$ holds (by \saferef{env:inv} for ($\sharp$))
we establish that 
$\safe_n(C,\theta_l,\xi\theta_s\theta^{s},\intp,R,G,\Upsilon, Q)$
as required.\qed
% $\theta_l,\xi\theta_s\theta^s,\intp\vDash Q_1$ holds from the stability of $Q_1$ under $R$ and $\Upsilon$.
\end{proof}



\begin{lemma}[Exists$_{2}$]\label{lem:EXists}
For all $n$ and for all logical variable $X$, state $\theta$,
and configuration 
$\kappa_1=(C,\theta_l,\xi\theta_s,\intp[X:\theta],R,G,\Upsilon, Q)$
if $\safe_n(\kappa_1)$ % and $X$ is not a free variable in either $R$ or $G$, 
then  
$\safe_n(\kappa)$ holds,
where $\kappa=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, \exists X.\, Q)$.
\end{lemma}

%\nr{I assume our commands cannot modify free variables.}
\begin{proof}
Before beginning the proof we remind ourselves that $C$, as all commands in our language
does not modify the interpretation of (logical) variables of any type.

The proof is done by induction on $n$.
In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
the induction hypothesis (IH)  
\begin{multline*}
  \forall C',\theta'_l,\xi'\theta'_s,\intp',R'G',\Upsilon', Q', \theta'.\,
  \\
  \safe_n(C', \theta'_l,\xi'\theta'_s,\intp'[X:\theta],R',G',\Upsilon', Q') 
  \\
   \mbox{} \implies  \safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon',\exists X.\,Q')   
\end{multline*}
and that ($\dagger_1$) $\safe_{n+1}(\kappa_1)$ holds.
We now show that $\safe_{n+1}(\kappa)$ also holds.

\safecond{done} 
If $C = \done$ then by assumption ($\dagger_1$) we get that 
$\theta_l,\xi\theta_s,\intp[X:\theta] \vDash Q$
and that $\xi\theta_s \vDash \Upsilon$.
By the (standard) semantic definition of $\exists$ we get that 
$\theta_l,\xi\theta_s,\intp \vDash \exists X.\,Q$. 
%using the intepretatio$\theta$ for al free occurrences of $X$ in $Q$.

\safecond{noabort} 
If $C=\done$, we are done.
Otherwise, 
pick an arbitrary $\theta_f$ such that ($\dagger$) 
$\consistent{\theta_l*\theta_s*\theta_f}$.
If $C,\theta_l*\theta_s*\theta_f \rightarrow \top$   we get a contradiction to ($\dagger_1$),
which is  assumed to hold.

\safecond{step}: 
If $C=\done$, we are done.
Otherwise, 
for the same $\theta_f$ as before
assume $C, \theta_l*\theta_s*\theta_f \rightarrow C',\theta'$. 
As $\safe_{n+1}(\kappa_1)$ is assumed to hold ($\dag_1$), 
there must be 
$\theta'_l$  and $\theta'_s$ such that ($\dag$) $\theta' = \theta_l' * \theta_s' * \theta_f$ 
which justify the transition.
Pick the same   states.
By choice, these states satisfy \saferef{step:consistent} and either  
\saferef{step:shared} or \saferef{step:stutter}.
Choose the  history of the shared state to be  
$\xi'=\xi^1\theta^1_s\theta^{1'}_s$  in the first case and $\xi'=\xi^1\theta^1_s$ in the second case.
Note that the above choice also ensures that ($\ddag$)  
$\safe_n(C'_1, \theta'_l,\xi',\intp[X:\theta],R,G,\Upsilon, Q)$ holds.
Using ($\ddag$) and the induction hypothesis, which recall was for arbitrary configurations,
we get that 
$\safe_n(C, \theta'_l,\xi',\intp,R,G,\Upsilon, \exists X.\,Q)$ holds, as required.


\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^s$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
As the same $G$ and $\Upsilon$ are used in the premise of 
\saferef{env} for $\safe_{n+1}(\kappa_1)$--which is assumed to 
hold $(\dag_1)$--we get that ($\sharp$)
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp[X:\theta],R,G,\Upsilon, Q)$.
Using the induction hypothesis and 
that
$\xi\theta_s\theta^s\vDash\Upsilon$ holds (by \saferef{env:inv} for ($\sharp$))
we establish that 
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, \exists X.\,Q)$
as required.\qed
% $\theta_l,\xi\theta_s\theta^s,\intp\vDash Q_1$ holds from the stability of $Q_1$ under $R$ and $\Upsilon$.
\end{proof}

The proof for the other quantification rules is similar, and thus omitted. 

%\begin{lemma}[Precision]\label{lem:precision}
%Let $\kappa=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$ be a configuration and $\theta'$ a state such that
%\begin{compactenum}[(1)]
%\item 
%$\safe_{n+1}(\kappa)$ holds,
%\item
%$\xi\theta_s\vDash \Upsilon$,
%\item
%$C, \theta_l*\theta_s\rightarrow C',\theta'$,
%\item
%$\theta' = \theta^1_l*\theta^1_s = \theta_l^2*\theta_s^2$,
%\item
%$\theta^1_s \neq \theta^2_s$,
%\item
%For $i=1,2$, either 
%\begin{compactenum}[(i)]
%  \item \label{precision:stutter} $\theta'_s = \theta_s$ or 
%  \item \label{precision:guarantee} there exist $\theta_{l_0}$ 
%        and $\theta^i_{l_1}$  such that 
%          $\theta^i_l = \theta^i_{l_0} * \theta^i_{l_1}$ 
%          and $\theta^i_{l_1},\theta_s,\theta^i_s,\intp \vDash G$,  
%\end{compactenum}
%\item \label{precision:inv} 
%For $i=1,2\/$, it holds that $\xi\theta_s\theta^i_s\vDash\Upsilon$, and
%\item \label{precision:safe:step:ind} 
%For $i=1,2\/$, $\safe_{n}(C',\theta^i_l,\xi\theta_s\theta^i_s,\intp,R,G,\Upsilon,Q)$.       
%\end{compactenum}
%then 
%\begin{compactenum}[(1)]
%\item 
%$C, \theta_l*\theta_s\rightarrow C',\theta_l*\theta_s$ and 
%\item
%$\safe_{n}(C',\theta_l,\xi\theta_s\theta_s,\intp,R,G,\Upsilon,Q)$. 
%\end{compactenum}
%\end{lemma}
%
%\begin{proof}
%  \TODO[after ATOM]
%\qed\end{proof}

\[
\infer[\textsc{Conj}]{
R,G, \Upsilon \tvdash  \{P_1 \land P_2\}\,C\,\{Q_1 \land Q_2\} \quad
}{
R,G, \Upsilon \tvdash  \{P_1\}\,C\,\{Q_2\}
\quad
R,G, \Upsilon \tvdash \{P_2\}\,C\,\{Q_2\}
}
\]

\begin{lemma}[Conj]\label{lem:conj}
For all $n$ and for all 
configurations 
$\kappa_1=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q_1)$,
$\kappa_2=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q_2)$, and
$\kappa=(C,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q_1 \land Q_2)$,
if 
\begin{inparaenum}[(i)]
\item $\safe_n(\kappa_1)$ and %, 
\item $\safe_n(\kappa_2)$ %, and
%\item \label{lem:conj:inv}
%$\xi\theta_s\vDash\Upsilon$
\end{inparaenum}
then
$\safe_n(\kappa)$.
\end{lemma}

\begin{proof}
The proof is done by induction on $n$.
In the base case, 
$\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
the induction hypothesis (IH)  
\begin{multline*}
  \forall C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_1', Q_2',.\,\\
  \big(%\xi'\theta'_s \vDash \Upsilon \land \mbox{}\\
  \safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_1') \land \mbox{}\qquad\\
   \safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_2')\big)\\ 
   \mbox{}\implies  \safe_n(C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q_1' \land Q'_2)   
\end{multline*}
and that ($\dagger_1$) $\safe_{n+1}(\kappa_1)$ and ($\dagger_2$) $\safe_{n+1}(\kappa_2)$  
hold.
We now show that $\safe_{n+1}(\kappa)$ also holds.


\safecond{done} 
If $C = \done$ then by assumption ($\dagger_1$) we get that 
$\theta_l,\xi\theta_s,\intp \vDash Q_1$ and by 
($\dagger_2$) we get that 
$\theta_l,\xi\theta_s,\intp \vDash Q_2$.
Thus, $\theta_l,\xi\theta_s,\intp \vDash Q_1 \land Q_2$.
%and by assumption(\ref{lem:conj:inv})
%we have that 
Both ($\dagger_1$) and ($\dagger_2$) give us that $\xi\theta_s \vDash \Upsilon$.


\safecond{noabort} 
If $C=\done$, we are done.
Otherwise, 
pick an arbitrary $\theta_f$ such that ($\dagger$) $\consistent{\theta_l*\theta_s*\theta_f}$.
If $C,\theta_l*\theta_s*\theta_f \rightarrow \top$   we get a contradiction to both ($\dagger_1$) and ($\dagger_2$),
which are assumed to hold.

\safecond{step}: 
If $C=\done$, we are done.
Otherwise, 
for the same $\theta_f$ as before,
assume $C,\theta_l*\theta_s*\theta_f \rightarrow C^c,\theta^c*\theta_f$. %^c to avoid clash with C' 
As $\safe_{n+1}(\kappa_i)$ is assumed to hold ($\dag_i$) for $i=1,2$,
there must be 
($\sharp$) $\theta^c =\theta^{1'}_l * \theta^{1'}_s = \theta^{2'}_l * \theta^{2'}_s$
such that %(\ref{safe:step:stutter})
the requirements of \saferef{step} are satisfied for $Q_i$ by $\theta^{i'}_l$ and $\theta^{i'}_s$ where $i=1,2$. 
To establish, \saferef{step}, it suffices to show that 
$\theta^{1'}_l  = \theta^{2'}_l $ and
$\theta^{1'}_s = \theta^{2'}_s$. Once we do that, we can use the induction hypothesis to establish the desired result.

There can be two cases.
(I) If $C = \langle C'' \rangle_a$ for some $C''$ and $a$ then 
from the ($\dag_1$) and ($\dag_2$)
%from the safety of ($\dag_i$) for $i=1,2$ 
we get that there exist $\theta_{l^i_0}$ and $\theta_{l^i_1}$,   
precise assertions $p_s$ and $q_s$, a variable over states $X$, and abstract states $\theta^i_X$ 
such that $a = l \mid p_s * X \leadsto q_s * X$ and 
$\theta_{l^i_1},\theta_s,\theta^{i'}_s,\intp[X \mapsto\theta^i_X] \vDash a$ for $i=1,2$.
Now, as $\theta_s,\intp[X \mapsto\theta^i_X] \vDash p_s * X$ for both $i=1$ and $i=2$ and $p_s$ is precise,
we get from $*$ being cancelative that $\theta^1_X=\theta^2_X$.
Recall that $\theta^{i'}_s,\intp[X \mapsto\theta^1_X]\vDash q_s * X$.
Hence, there exists $\theta_{q_s}^{i'}$ for $i=1,2$ such that 
($\&$) $\theta^{i'}_s = \theta_{q_s}^{i'} * \theta^1_X$ and ($\%$) $\theta_{q_s}^{i'},\intp\vDash q_s$.
From ($\sharp$),  
we have that $\theta^{1'}_l * \theta^{1'}_s = \theta^{2'}_l * \theta^{2'}_s$.
Hence,
$\theta^{1'}_l * \theta_{q_s}^{1'} * \theta^1_X  = \theta^{2'}_l * \theta_{q_s}^{2'} * \theta^1_X$.
As $*$ is cancelative, we get that 
$\theta^{1'}_l * \theta_{q_s}^{1'}   = \theta^{2'}_l * \theta_{q_s}^{2'} $.
From this equality, ($\%$), and the precision of $q_s$ we get that $\theta_{q_s}^{1'} = \theta_{q_s}^{2'}$, 
and hence $\theta^{1'}_l = \theta^{2'}_l$.
The latter, ($\sharp$), and $*$ being cancelative, implies that $\theta^{1'}_s = \theta^{2'}_s$.
%

(II) If $C \neq \langle C'' \rangle_a$ for any $C''$ and $a$ then 
by \saferef{step:shared} and  ($\dagger_1$) and ($\dagger_2$) 
we get that $\theta^{1'}_s = \theta^{2'}_s = \theta_s$.
Because $*$ is cancelative, we get from ($\sharp$) that  $\theta^{1'}_l = \theta^{2'}_l$.


\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^s$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
As the same $R$ and $\Upsilon$ are used in the premise of 
\saferef{env} for $\safe_{n+1}(\kappa_i)$--which are assumed to 
hold $(\dag_i)$ (for $i=1,2$)--we get that ($\sharp$)
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, Q_i)$.
Using the induction hypothesis and 
that
$\xi\theta_s\theta^s\vDash\Upsilon$ holds (by \saferef{env:inv} for ($\sharp$))
we establish that 
$\safe_n(C,\theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, Q_1 \land Q_2)$
as required.
\qed\end{proof}


% subsection soundness_of_structural_proof_rules (end)


\infer[\textsc{Frame}]{
R, G, \Upsilon \vdash_\ltid \{P*F\}\,C\,\{Q*F\}
}{
R, G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
\quad
F \mbox{ is stable under $R \cup G$ and $\Upsilon$}
}

\begin{lemma}[Frame]\label{lem:Frame}
For all configurations  $\kappa^0=(C^0,\theta^0_l,\xi^0\theta^0_s,\intp^0,R,G,\Upsilon, Q^0)$
and for all assertions $F$. 
%for all configuration  $\kappa_1=(C,\theta_l,\xi\theta_s,\intp,R',G',\Upsilon, Q')$
If 
\begin{compactenum}
\item \label{lem:frame:preP}
$\theta^0_l,\xi^0\theta^0_s,\intp\vDash P*F$,
\item \label{lem:frame:preInv}
$\xi\theta^0_s,\intp^0\vDash \Upsilon$,
\item \label{lem:frame:stable}
$\stable{F}{R \cup G}{\Upsilon}$, and 
\item \label{lem:frame:safe}
$R,G,\Upsilon \vDash_{\ltid}  \{ P\} C^0 \{Q\}$
\end{compactenum}
then  
$\safe_n(\kappa^0)$.
\end{lemma}


\begin{proof}
By assumptions (\ref{lem:conseq:preP}) % and (\ref{lem:conseq:preInv})
%we get that 
%\[
% \theta_l,\xi\theta_s,\intp \vDash (P  * F)\,. % \land \Upsilon\,.
%\]
%Hence, by 
and the interpretation of $*$, we get that 
there exist $\theta^{P0}_{l}$ and $\theta_l^{F0}$ such that 
$$
\begin{array}{ll}
(\dag_1) &\theta^0_l =\theta^{P0}_{l}*\theta_l^{F0}, \\
(\dag_2) &\theta_l^{P0},\xi^0\theta^0_s,\intp^0 \vDash P, ~\text{and}\\
(\dag_3) &\theta_l^{F0},\xi^0\theta^0_s,\intp^0 \vDash F \,.
\end{array}
$$
%(Recall that $\Upsilon$ does not restrict the local state.)
%By this and assumption (\ref{lem:conseq:P}),
%we get that 
%\[
% \theta_l,\xi\theta_s,\intp \vDash P'\,.
%\]
%By this, assumption (\ref{lem:conseq:preInv}), and ($\dagger_1$)
By $(\dag_2)$  and assumptions (\ref{lem:frame:preInv}) and (\ref{lem:frame:safe}),
we get that 
\[
 (\$\$) \; \safe(\kappa^0) \;\text{where}\; \kappa^0 = (C^0,\theta^{P0}_l,\xi^0\theta^0_s,\intp,R,G,\Upsilon, Q)\,.
\]
We now show that $(\$\$)$ implies the desired result.

The proof continues by induction on $n$.
Pick $\kappa=(C,\theta_l^P*\theta_l^F,\xi\theta_s,\intp,R,G,\Upsilon, Q*F)$
such that $\theta_l^P,\xi\theta_s,\intp\vDash Q$ and ($*_0$) $\theta_l^F,\xi\theta_s,\intp\vDash F$.

In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume 
the induction hypothesis (IH)  
\begin{multline*}
  \forall C^1,\theta^1_l,\xi^1\theta^1_s,\intp^1,R^1,G^1,\Upsilon,Q^1,\theta^2_l,F^1.\\
  \Big(\theta^2_l,\xi^1\theta^1_s,\intp^1 \vDash F^1 \land  
  \stable{F}{R \cup G}{\Upsilon} \land \consistent{\theta^1_l * \theta^2_l * \theta^1_s} \land\mbox{} 
  \qquad \\ 
  \safe_n(C^1,\theta^1_l,\xi^1\theta^1_s,\intp^1,R^1,G^1,\Upsilon,Q^1)\Big)
  \implies \mbox{} \\
  \safe_n(C^1,\theta^1_l*\theta^2_l,\xi^1\theta^1_s,\intp^1,R^1,G^1,\Upsilon,Q^1*F^1)
\end{multline*}
and that the following also holds:
% ($\dagger$) $\safe_{n+1}(R,G,\Upsilon \vDash_{\ltid}^n \{ P\} C \{Q\})$ holds.
$$
\begin{array}{ll}
(\$ )   &\safe_{n+1}(\kappa') \quad \text{for} \quad \kappa' = (C,\theta^P_l,\xi\theta_s,\intp,R,G,\Upsilon,Q)\\  
(\%)    & (\theta^F_l,\xi\theta_s,\intp,F)\\ 
(\ddag) & \consistent{\theta^P_l * \theta^F_l * \theta^1_s}
\end{array}
$$
We now show that $\safe_{n+1}(\kappa)$ also holds.



\safecond{done} 
If $C = \done$ then by ($\$$), 
we get that 
$$
(\&) \;\theta^P_l,\xi\theta_s,\intp \vDash Q \land \xi\theta_s,\intp \vDash \Upsilon \,.
$$
By ($\%$), ($\ddag$),  and
%we get that $\consistent{\theta^P_l * \theta^F_l * \theta_s}$.
%By this, 
($\&$) %, $(\dag_1)$,  and $(\dag_3)$, 
we get that $\theta_l,\xi\theta_s,\intp \vDash Q*F$.
%using the intepretatio$\theta$ for al free occurrences of $X$ in $Q$.
By ($\&$), we also get that $\xi\theta_s, \intp \vDash \Upsilon$.

\safecond{noabort} 
If $C=\done$, we are done.
Otherwise, 
pick an arbitrary $\theta_f$ such that %($\dagger$) 
$\consistent{\theta^P_l * \theta^F_l*\theta_s*\theta_f}$.
If $(C,\theta^P_l * \theta^F_l*\theta_s*\theta_f \rightarrow_{\ltid} \top)$,   we get a contradiction to ($\$$).

\safecond{step}: 
If $C=\done$, we are done.
Otherwise, 
for the same $\theta_f$ as before
assume $(C, \theta^P_l * \theta^F_l*\theta_s*\theta_f \rightarrow_\tid C',\theta')$. 
%As $\safe_{n+1}(\kappa_1)$ is assumed to hold ($\dag_1$), 
By ($\$$), 
there must be  $\theta'_l$  and $\theta'_s$ such that 
($\dag$) $\theta' = \theta_l' * \theta_s' * \theta^F_l * \theta_f$ 
which justify the transition for $\kappa'$ to be safe up to $n+1$ steps.

Pick the same   states $\theta'_l$  and $\theta'_s$  as above.
Our choice satisfies \saferef{step:consistent} to $\kappa$.
Recall that  
the same $G$ and $\Upsilon$ appear in $\kappa$  and $\kappa'$.
Thus, in case the history of the shared state changed, then \saferef{step:guarantee} and \saferef{step:inv}
are also satisfied for $\kappa$.

The challenge, is to show that after the step, the claim about the frame still holds.
There can be two case.

In case the history of the shared state changed to $\xi'$, 
then $(\theta^F_l,\xi',\intp \vDash F)$ still holds because 
by \saferef{step:shared} the $\xi'$ is of the form   
$\xi'=\xi\theta_s\theta^{'}_s$.
By \saferef{step:guarantee}, there exist $a \in G$ and states $\theta_{l_0}$ and $\theta_{l_1}$
such that $\theta^P_{l} = \theta_{l_0} * \theta_{l_1}$  and
$(\theta_{l_0},\theta_s,\theta_s',\intp \vDash a)$.
Recall that $F$ is assumed to be stable for $G$ under $\upsilon$.
As \saferef{step:inv} for $\kappa'$ ensures that $\xi',\intp\vDash\Upsilon$. 
Thus, we get that ($*_1$) $(\theta^F_l,\xi',\intp \vDash F)$ holds.

In case the history of the shared state remains  $\xi' = \xi\theta_s$, then 
($*_2$) $(\theta^F_l,\xi\theta_s,\intp \vDash F)$ holds because, by  ($\dag$), 
$\theta^F_l$ was not modified

By \saferef{step:ind} for $\kappa'$, we get that 
$$
\safe_n(C',\theta_l',\xi',\intp,R,G,\Upsilon,Q)\,.
$$
From the above, ($\dag$), ($*_1$), ($*_2$), and the induction hypothesis
we get that 
$$
\safe_n(C',\theta_l'*\theta_l^P,\xi',\intp,R,G,\Upsilon,Q * F)
$$
which is what required to show (\saferef{step:ind}).
 
\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^{s}$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
By ($\ref{lem:frame:stable}$), we have that $F$ is stable for $R$ under $\Upsilon$. 
From this and ($\%$), we get that 
$(\theta^F_l,\xi\theta_s\theta^s,\intp \vDash F)$.
From \saferef{env} for $\safe_{n+1}(\kappa_1)$--which is assumed to 
hold $(\$)$--we get that ($\sharp$)
$\safe_n(C,\theta^P_l,\xi\theta_s\theta^{s},\intp,R,G,\Upsilon, Q)$.
Using the induction hypothesis 
%and 
%that
%$\xi\theta_s\theta^{s'}\vDash\Upsilon$ holds (by \saferef{env:inv} for ($\sharp$))
we establish that 
$\safe_n(C,\theta^P_l * \theta^F_l,\xi\theta_s\theta^{s},\intp,R,G,\Upsilon, Q * F)$
which, by ($*_0$), is what required.
\qed
% $\theta_l,\xi\theta_s\theta^s,\intp\vDash Q_1$ holds from the stability of $Q_1$ under $R$ and $\Upsilon$.
\end{proof}


\subsubsection{Soundness of Shared Proof Rules} % (fold)
\label{sec:sound:shared}

\begin{defin}[Local Configurations]\label{def:localconfig}
  A \emph{local configuration}  is a configuration of the form
  $\kappa=(C,\theta,\xi\unit,\intp,\emptyset,\emptyset, \true, q)$  
  where $C$ is a command which does not contain atomic blocks.
\end{defin} 


\[
\infer[\textsc{Shared-R}]{
R, G, \Upsilon \tvdash  \{P\}\, 
\langle C\rangle_a \, 
\{ Q \} %Q \{q \wedge (\tau \extend \shareds{q_s})\}
}{
\begin{array}{c}
Q \Rightarrow \Upsilon \qquad
\text{$P$, $Q$ are stable under $R$ and $\Upsilon$}
\\[2pt]
\emptyset,G,\true \tvdash \{ P \} \,\langle C\rangle_a\, \{ Q \}
\end{array}
}
\]

\begin{lemma}[Shared-R]\label{lem:SharedR}
Let $\kappa=(\langle C \rangle_a,\theta_l,\xi\theta_s,\intp,R,G,\Upsilon, Q)$
be a configuration.
If 
\begin{compactenum}		
\item \label{sharedr:pre}
$\theta_l,\xi\theta_s,\intp \vDash P$ and 
$\xi\theta_s,\intp \vDash \Upsilon$, 
\item \label{sharedr:safe}
$\emptyset,G,\true \vDash \{ P \} \,\langle C\rangle_a\, \{ Q \}$,
\item  \label{sharedr:inv}
$Q \implies \Upsilon$, and 
\item \label{sharedr:stable}
$P$ and $Q$ are stable under $R$ and $\Upsilon$
\end{compactenum}
then  
$\safe(\kappa)$ holds.
\end{lemma}

\begin{proof}
We show that $\safe_n(\kappa)$ holds for all $0 \leq n$. 
The proof is done by induction on $n$.
In the base case, $\safe_0(\kappa)$ holds by definition.
For the inductive step, 
assume, in addition to (\ref{sharedr:pre}--\ref{sharedr:stable}), 
the induction hypothesis (IH)  
\begin{multline*}    
  \forall a', C',\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon', Q'.\,
  \\
  \Big(\theta'_l,\xi'\theta'_s,\intp' \vDash P' \land \xi'\theta'_s,\intp' \vDash \Upsilon'
  \land \mbox{}\,
  %\\
  \emptyset,G',\true \vDash \{ P' \} \,\langle C'\rangle_{a'}\, \{ Q' \} \land \mbox{}
  \\
  (Q' \implies \Upsilon') \land \mbox{} 
  %\\
  \mbox{}   \stable{P'}{R'}{\Upsilon'} \land  \stable{Q'}{R'}{\Upsilon'}\Big)
  \\
  \mbox{} \implies  \safe_n(\langle C' \rangle_{a'},\theta'_l,\xi'\theta'_s,\intp',R',G',\Upsilon',Q')\,.   
\end{multline*}
%and that ($\&$) $\safe_{n}(\kappa)$ holds.
We now show that $\safe_{n+1}(\kappa)$ also holds.

% because 
%assumption~(\ref{sharedr:safe}) is independent of $n$.

%We show that $\safe_n(\kappa)$ holds for any $0 \leq n$.
%If $n=0$ then $\safe_n(\kappa)$ by definition.
%Assume $n = m +1$ for some $0 \leq m$.
%First note that  ($\$$) $\safe_{m+1}(\kappa_1)$ holds by assumption (\ref{sharedr:safe}).
%We now show that the conditions of Definition~\ref{def:safe}  hold.

\safecond{done} 
Holds vacuously because  $\langle C \rangle_a \neq \done$.

\safecond{noabort} 
Pick an arbitrary $\theta_f$ such that ($\dagger$) 
$\consistent{\theta_l*\theta_s*\theta_f}$.
Let $\kappa_1 = (\langle C \rangle_a,\theta_l,\xi\theta_s,\intp,\emptyset,G,\true, Q)$.
From assumptions (\ref{sharedr:pre}) and (\ref{sharedr:safe}) we get that  
($\$$) $\safe_{n+1}(\kappa_1)$ holds.
Note that  
$\langle C' \rangle_a,\theta_l*\theta_s*\theta_f \rightarrow \top$   
contradicts  ($\$$).

\safecond{step}: 
For the same $\theta_f$ as above, 
assume $\langle C \rangle_a, \theta_l * \theta_s * \theta_f \rightarrow C',\theta'$.
By ($\$$), 
there are  $\theta'_l$  and $\theta'_s$ 
such that ($\ddag$) $\theta'=\theta_l' * \theta_s'*\theta_f$  
which justify this transition for 
$\safe_{n+1}(\kappa_1)$.
Pick the same states.
\saferef{step:consistent} holds by ($\ddag$).
\saferef{step:guarantee}  holds by ($\$$) because the guarantee set in $\kappa$ is the same one as in  $\kappa_1$. 

To see that \saferef{step:inv} holds, 
we recall from the operational semantics that the only possible derivation for 
$\langle C \rangle_a, \theta_l * \theta_s * \theta_f \rightarrow C',\theta'$ 
is one such that $C'=\done$.
Below, we establish that $\safe_{n}(\kappa')$ holds, where 
$\kappa' = (\done, \theta'_l,\xi\theta_s\theta_s',\intp,R,G,\Upsilon, Q)$.

If $n=0$ then $\safe_{n}(\kappa')$ holds by definition.
If $0 < n$ then by applying the definition of safety to ($\$$), % assumption (\ref{sharedr:safe}) 
we get that ($\sharp$) $\safe_{n}(\kappa_1')$ also 
holds where $\kappa_1'=(\done, \theta'_l,\xi\theta_s\theta_s',\intp,\emptyset,G,\true, Q)$. 
As $0<n$, we get from the definition of safety for configurations that 
$\theta'_l,\xi\theta_s\theta_s',\intp \vDash Q$.
By assumption~(\ref{sharedr:inv}), we get that $\xi\theta_s\theta_s',\intp \vDash \Upsilon$
because $\Upsilon$ does not restricts the local state.
We now can apply Lemma~\ref{lem:done} and get that $\safe_{n}(\kappa')$.
 
\safecond{env}: 
Pick an arbitrary $\theta^l$ and $\theta^s$ such that the 
premise of \saferef{env} of $\safe_{n+1}(\kappa)$ holds. 
We need to show that $\safe_n(\kappa^e)$ holds where 
$\kappa^e = (\langle C \rangle_a, \theta_l,\xi\theta_s\theta^s,\intp,R,G,\Upsilon, Q)$.
Recall that $P$ is stable under $R$ and $\Upsilon$.
Hence, $\theta_l,\xi\theta_s\theta^s,\intp \vDash P$ and $\xi\theta_s\theta^s,\intp \vDash \Upsilon$.
Now, we can apply the induction hypothesis for $\kappa^e$ to get the desired result.
\qed\end{proof}

\[
\infer[\textsc{Shared}]{
\emptyset, G, \true \tvdash \{p \wedge  \tau \wedge \shareds{p_s}\}\, 
\langle C\rangle_a\, 
\{ q \wedge ((\tau \wedge \shareds{p_s}) \extend \shareds{q_s}) \}
}{
\begin{array}{c}
p \Rightarrow l * \true
\qquad
\{l \mid p_s \leadsto q_s\} \Rightarrow \{a\} 
\qquad
a \in G
\\[2pt]
\emptyset,\emptyset,\true \tvdash \{ p * p_s \} \,C\, \{ q * q_s \}
\end{array}
}
\\[10pt]
\]


\begin{lemma}[Shared]\label{lem:shared}
Let $\kappa=(\langle C \rangle_a,\theta,\xi\theta_s,\intp,\emptyset,G,\true, Q)$\, 
be a configuration where $Q = q \land ((\tau \land \shared{p_s}) \extend \shared{q_s})\,.$
If 
\begin{compactenum}		
\item \label{shared:local}
$\theta,\intp \vDash p$,
\item \label{shared:hasguard}
there exist $\theta_{l_0}$ and $\theta_{l_1}$ such that $\theta = \theta_{l_0} * \theta_{l_1}$ and $\theta_{l_1},\intp \vDash l$,
\item  \label{shared:shared}
$\theta_s, \intp \vDash p_s$, % and $q_s$ are precise assertions,
\item  \label{shared:history}
$\xi\theta_s, \intp \vDash \tau$, 
\item \label{shared:atomic}
$\emptyset,\emptyset,\true \vDash \{ p * p_s \} \,C\, \{ q * q_s \}$, and
\item \label{shared:guarantee}
$\db{l\mid p_s \leadsto q_s} \subseteq \db{a}$ and $a \in G$,
\end{compactenum}
then  
$\safe(\kappa)$ holds.
\end{lemma}

\begin{proof}
We show that $\safe_n(\kappa)$ for all $0 \leq n$.
For $n = 0$, $\safe_n(\kappa)$  holds by definition.
Thus, assume $n= m+1$.

\safecond{done} holds trivially as $\langle C \rangle_a$ is not $\done$. 

\safecond{noabort}: 
Pick an arbitrary $\theta_f$ such that ($\$$)
$\consistent{\theta * \theta_s * \theta_f}$.
(Note that, in particular, $\consistent{\theta * \theta_s}$.)
Assume, by contradiction, that ($\dagger$) $\langle C \rangle, \theta * \theta_s * \theta_f \rightarrow \top$.
Consulting the operational semantics, we see that ($\dagger$) holds only if 
($\ddag$) $C, \theta  * \theta_s * \theta_f \rightarrow^* \top$.
%Because $\kappa$ is a configuration, it holds that
%$p * p_s \neq \top$.
By assumptions~(\ref{shared:local}) and~(\ref{shared:shared})
it holds that $\theta * \theta_s *\unit,\intp\vDash p * p_s$.
Hence,
$\kappa_L =  (C,\theta * \theta_s,\xi\unit,\intp,\emptyset,\emptyset,\true,q * q_s)$
is a  (local) configuration.
By assumption~(\ref{shared:atomic}) we get that $\safe(\kappa_L)$ holds.
From Lemma~\ref{lem:safeloc:run} and ($\$$), we get that ($\ddag$) cannot hold, 
and hence neither can ($\dagger$).

\safecond{step}: 
Pick  $\theta_f$ as above.
Consulting the operational semantics,
the only way for the one step reduction 
$\langle C \rangle_a, \theta * \theta_s * \theta_f \rightarrow C',\theta'$ 
to occur is if $C'=\done$ and $C, \theta * \theta_s * \theta_f \rightarrow^* \done,\theta'$.
Consider, again, the local configuration $\kappa_L$ and recall that 
$\safe(\kappa_L)$ holds.
From Lemma~\ref{lem:safeloc:run}, we get that there exist 
$\theta''$, $\theta_l'$, and $\theta_s'$ such that $\theta' = \theta'' * \theta_f$,  
$\theta'' = \theta'_l * \theta'_s$, 
($\sharp$) $\theta'_l,\intp \vDash q$, and 
($\&$) $\theta'_s, \intp \vDash q_s$.

Using the aforementioned states, we get that 
$\consistent{\theta'_l * \theta'_s * \theta_f}$, 
and hence \saferef{step:consistent} holds.
We now show that \saferef{step:shared} holds:
\saferef{step:guarantee} holds by ($\&$) and assumptions (\ref{shared:hasguard}), (\ref{shared:shared}) and 
(\ref{shared:guarantee}).
\saferef{step:inv} holds trivially as the temporal invariant is $\true$.
To show that \saferef{step:ind} holds,
we need to establish that
$\safe_m(\done,\theta'_l,\xi\theta_s\theta'_s,\intp,\emptyset,G,\Upsilon,Q)$. We do so using Lemma~\ref{lem:done}.
To apply the latter we need to show that:
\begin{compactenum}[(i)]
\item $\theta'_l,\xi\theta_s\theta_s',\intp \vDash Q$.
By definition of the satisfaction relation over worlds, 
the latter holds if and only if
(a) $\theta'_l,\intp \vDash q$, which  holds by ($\sharp$),
(b) $\xi\theta_s,\intp \vDash p_s$ and $\theta_s,\intp \vDash\tau$, which hold  by
assumptions (\ref{shared:shared}) and (\ref{shared:history}), respectively, and  
(c) $\theta'_s,\intp \vDash q_s$, which holds by  ($\&$).
\item $\xi\theta_s\theta_s',\intp \vDash \true$, holds trivially.
\item $Q$ is stable under $\emptyset$ and $\true$, which holds trivially.
\end{compactenum}

\safecond{env}: holds trivially since the rely is an emptyset.
\qed\end{proof}





\begin{lemma}[Properties of Runs of Local Configurations]\label{lem:safeloc:run}
  Let  $\kappa = (C,\theta,\xi\unit,\intp,\emptyset,\emptyset,\true, q)$ 
  be a safe  local configuration.
  For any $\theta_f$ such that $\consistent{\theta*\theta_f}$ it holds that
  \begin{compactenum}
    \item \label{lem:safeloc:noabort} 
    $\neg(C,\theta * \theta_f,\intp \rightarrow^* \top)$ and
    \item \label{lem:safeloc:post} if 
      $C,\theta * \theta_f,\intp \rightarrow^* \done,\intp,\theta',\intp$
    then there exists $\theta''$ such that $\theta' = \theta'' * \theta_f$
    and $\theta'',\intp \vDash q$.
%    
%    $\xi' = \xi\unit$,
%    $\intp' = \intp$,
%    $R' = G' = \emptyset$, and
%    $\Upsilon = \true$. 
  \end{compactenum}
\end{lemma}

\begin{sketch}
The lemma is proved by induction on the number of derivation steps used in $\rightarrow^*$.
We note that for local configurations, the notion of safety in Definition~\ref{def:safe} simplifies to Definition~\ref{def:safelocal}. 
\end{sketch}

\newcommand{\lsafe}[1][t]{\mathsf{LSafe}^{#1}}

\begin{defin}[Bounded Safety for Local Configurations]\label{def:safelocal}
  A configuration  $\kappa = (C,\theta,\xi\unit,\intp,\emptyset,\emptyset,\true, q)$ 
  is always \emph{locally safe for $0$ steps}, denoted 
  $
   \lsafe_0(\kappa)\,.
  $
  $\kappa$ is \emph{locally safe for $n + 1$ steps},  
  denoted 
  $
   \lsafe_{n+1}(\kappa)\,,
  $
  if the following  holds
  \begin{compactenum}[(a)]
    \item \label{safeloc:done} if 
     $C = \done$ then $\theta,\intp \vDash q$,
     
    \item \label{safeloc:noabort}  
     for all $\theta_f$ if $\consistent{\theta*\theta_f}$ then 
     $C,\theta*\theta_f \not\rightarrow \top$,  
     
    \item \label{safeloc:step} whenever $C,\theta*\theta_f \rightarrow C',\theta'$ 
     \begin{compactenum}[(1)] 
        \item 
        \label{safeloc:step:frame}
    there exists  $\theta''$ such that $\theta'=\theta''*\theta_f$ and       
        \item 
        \label{safeloc:step:ind}
        it holds that  $\safe_{n}(C',\theta'',\xi\unit,\intp,\emptyset,\emptyset,\true,q)$.       
     \end{compactenum}
  \end{compactenum}
  A local configuration $\kappa$ is safe, denoted $\lsafe(\kappa)$, if it is safe for any $0 \leq n$ steps.
\end{defin}

%\begin{defin}[Local Meaning of triples]\label{def:semtriple}
%$\emptyset,\emptyset,\true \vDash_L \{ p \} \, c \, \{ q \}$ if and only if 
%every local configuration $\kappa = (C,\theta,\xi\emp,\intp,\emptyset,\emptyset,\true, q)$
%such that 
%$\theta,\intp \vDash P$ it holds that $\safe^L(\kappa)$.
%\end{defin}

\begin{proposition}
For a local configuration $\kappa = (C,\theta,\xi\unit,\intp,\emptyset,\emptyset,\true, q)$ 
it holds that
$\safe(\kappa)$ if and only if $\lsafe(\kappa)$.
\end{proposition}
 


\ignore{
\subsubsection{Soundness of Parallel Composition}
\label{sec:sound:par}

\[
\infer[\textsc{Par}]{
 \vdash \{P_1 * \ldots * P_n\}\,C_1 \parallel \ldots \parallel C_n\,\{Q_1 * \ldots * Q_n\}
}{
\begin{array}{@{}c@{}}
R_1,G_1,\Upsilon  \vdash_1 \{P_1\}\,C_1\,\{Q_1\} \ 
\ldots\ 
R_n,G_n,\Upsilon  \vdash_n \{P_n\}\,C_n\,\{Q_n\}\\[2pt]
R_\ltid = \bigcup\{G_k \mid 1\leq k \leq n \land  k\neq \ltid\}
\qquad
P_1 * \ldots * P_n \Rightarrow \Upsilon
\end{array}
}
\]

\nr{Need to fix IH: We assume $\vDash_{m+1}$ and initial conditions.
This gives us the $\safe_{m+1}$ for individuals ones.}

\newcommand{\pvDash}{\vDash_p}

\begin{lemma}[Par]\label{lem:par}
For all $0 < n$ and all $0 \leq m$, 
for all $G_\ltid$, where $t=1,\ldots n$, and for all
configurations 
$\kappa = (C, \theta^1_l * \ldots * \theta^n_l,
[1\mapsto\theta_s],\intp, \emptyset,G,\true, Q)$
where $C = C_1 \parallel \ldots \parallel C_n$ and $G = \bigcup_{i=1,\ldots n}G_i$.
%
%$\kappa_\ltid = (C_\ltid,\theta^t_l,\intp, R_\ltid,G_\ltid,\Upsilon, Q_\ltid)$
%if  
If there exists $\Upsilon$ such that 
\begin{compactenum}[(i)]
\item \label{lem:par:c}
for every $\kappa_\ltid = (C_\ltid,\theta^t_l,\xi^t\theta^t_s,\intp,R_\ltid,G,\Upsilon, Q_\ltid)$ 
if $\xi^t\theta^t_s \vDash \Upsilon$ and $\theta^t_l,\xi^t\theta^t_s,\intp \vDash P_\ltid$  hold
then $\safe_m(\kappa_\ltid)$ holds for $R_\ltid = \bigcup\{G_k \mid 1\leq k \leq n \land  k\neq t\}$,
\item \label{lem:seq:stable}
for all $t=1,\ldots,n$ it holds that $P_\ltid$ and $Q_\ltid$ are stable under $R_\ltid$ and $\Upsilon$, and 
\item \label{lem:seq:pre}
for all $\theta^t_l,\xi^t\theta^t_s,\intp$ 
if $\theta^t_l,\theta_s,\intp\pvDash P_\ltid$ and 
$\consistent{\theta^1_l* \ldots \theta^n_l*\theta_s}$
then 
$[1\mapsto\theta_s],\intp \pvDash \Upsilon$.
\end{compactenum}
then  $\safe_m(\kappa)$ for any $t$.



\end{lemma}

\TODO{ Something weird here about the tid.}

\begin{proof}
The proof is by induction.
For the base case, $\safe_m(\kappa)$ holds by definition for $m=0$.
For the induction step, 
assume  
the induction hypothesis ($IH$) 
\begin{multline*}
\forall \intp',P'_1,\ldots,P'_n.\,
 \forall 1 \leq t \leq n.\, 
\stable{P'_\ltid}{R_\ltid}{\Upsilon} \land 
\stable{Q_\ltid}{R_\ltid}{\Upsilon} \implies \mbox{} \\
R_\ltid,G_\ltid,\Upsilon \vDash^m \{P'_\ltid\} C_\ltid \{ Q_\ltid \} \implies \mbox{}\\
\forall \theta_l^{1'},\ldots,\theta_l^{n'},\xi'\theta'_s.\,
\forall 1 \leq t \leq n.\,
\bigg(\xi'\theta'_s,\intp'\vDash \Upsilon \land \mbox{}\\
\xi'\theta'_s,\intp'\vDash P_\ltid  \land \safe_m(C_\ltid,\theta_l^{1'},\xi'\theta'_s,R_\ltid,G_\ltid,\Upsilon, Q_\ltid) \bigg)
\implies \mbox{}\\
\consistent{\theta_l^{1'}*\ldots*\theta_l^{n'}*\theta'_s}
\implies \mbox{} \\
%\forall 1 \leq t \leq n. \, \qquad\qquad\qquad\\
\safe[0]_m( (C'_1 \parallel \ldots \parallel C'_n,\theta^{1'}_l * \ldots * \theta^{n'}_l,
\xi'\theta'_s,\intp',\emptyset,G,\true,Q_1 * \ldots * Q_n)
\end{multline*}
%
%
%
%\begin{multline*}
%\forall \kappa' = (C'_1 \parallel \ldots \parallel C'_n,\theta^{1'}_l * \ldots * \theta^{n'}_l,
%\xi'\theta'_s,\intp', \emptyset,G,\true, Q_1 * \ldots * Q_n)\,.\\
%\forall 1 \leq t \leq n.\, 
%  \xi'\theta'_s,\intp'\vDash P \land \xi'\theta'_s,\intp'\vDash \Upsilon
%
%\safe_m(C_\ltid,\theta_l^{1'},\xi'\theta'_s,R_\ltid,G_\ltid,\Upsilon, Q_\ltid \} \implies\mbox{}\\
%\forall 1 \leq t \leq n.\safe_m(\kappa')\,.
%\end{multline*}
%We now show that $\safe_{m+1}(\kappa)$ holds for $m+1$.
and that for $\intp,P_1,\ldots,P_n$ for every $t=1,\ldots,n$ 
and $\theta_l^{1},\ldots,\theta_l^{n},\xi'\theta_s$
it holds that 
\[
(\&_\ltid) \quad
\stable{P'_\ltid}{R_\ltid}{\Upsilon} \land 
\stable{Q_\ltid}{R_\ltid}{\Upsilon} 
\]
\[
(\$_\ltid) R_\ltid,G_\ltid,\Upsilon \vDash^m \{P_\ltid\} C_\ltid \{ Q_\ltid \} 
\]
\[
(\sharp_\ltid) \quad \xi'\theta_s,\intp\vDash \Upsilon 
\]
\[
(\%) \quad \xi'\theta_s,\intp'\vDash P_\ltid  
\]
\[
(\dag_\ltid) \quad \safe_m(C_\ltid,\theta_l^{1},\xi\theta_s,R_\ltid,G_\ltid,\Upsilon, Q_\ltid) 
\]
\[
(\ddag) \quad \consistent{\theta_l^{1}*\ldots*\theta_l^{n'}*\theta_s}\,.
\]
We show that 
\[
\safe[0]_{m+1}(C_1 \parallel \ldots \parallel C_n,\theta^{1}_l * \ldots * \theta^{n}_l,
\xi'\theta'_s,\intp',\emptyset,G,\true,Q_1 * \ldots * Q_n)\,.
\]


%Assume that for all $t=1,\ldots,n$ it holds that 
%($\&_\ltid$) $P'_\ltid$ and $Q_\ltid$ are stable under $R_\ltid$ and $\Upsilon$.
%and that 

\safecond{done}  holds trivially as $C_1 \parallel \ldots \parallel C_n \neq \done$.

\safecond{noabort} 
Pick $\theta_f$ such that $\consistent{\theta_l^{1'} * \ldots * \theta_l^{n'} * \theta_l^{1'} * \theta}$.

\nr{I am here.}

%$\safe_m(C_\ltid,\theta_l^{1'},\xi'\theta'_s,R_\ltid,G_\ltid,\Upsilon, Q_\ltid \}$

\qed\end{proof}



% subsubsection proof_of_soundness_for_atomic_commands (end)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  END   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%\subsection{Soundness for the Local Fragment}\label{sec:soundloc}


%\ignore{
%\begin{defin}[Extend Local Worlds]\label{def:extlocworld}
%  An \emph{extended local world}  
%  is an extended world $\upomega=(\theta,\xi\unit,\intp,\emptyset,\emptyset, \true, q)$ such that
%  the current shared state is empty, 
%  the rely and guarantee sets are empty,  
%  the temporal invariant is $\true$, 
%  and $q$ is an assertion on states. 
%\end{defin}
%
%\begin{defin}[Local Configurations]\label{def:localconfig}
%  A \emph{local configuration}  is a configuration of the form
%  $\kappa=(C,\theta,\xi\unit,\intp,\emptyset,\emptyset, \true, q)$  
%  such that $C$ is a command which does not contain atomic blocks 
%  and $(\theta_l,\xi\unit,\intp,\emptyset,\emptyset,\true, q)$ is an extended local world.
%\end{defin}  
%}
%\begin{defin}[Bounded Safety for Local  Configurations]\label{def:safelocal}
%  A local configuration  $\kappa = (C,\theta,\xi\unit,\intp,\emptyset,\emptyset,\true, q)$ 
%  is always \emph{locally safe for $0$ steps}, denoted 
%  $
%   \safe^L_0(\kappa)\,.
%  $
%  $\kappa$ is \emph{locally safe for $n + 1$ steps},  
%  denoted 
%  $
%   \safe^L_{n+1}(\kappa)\,,
%  $
%  if the following  holds
%  \begin{compactenum}[(a)]
%    \item \label{safeloc:done} if 
%     $C = \done$ then $\theta,\intp \vDash q$,
%     
%    \item \label{safeloc:noabort}  
%     for all $\theta_f$ if $\consistent{\theta*\theta_f}$ then 
%     $C,\theta*\theta_f \not\rightarrow \top$,  
%     
%    \item \label{safeloc:step} whenever $C,\theta*\theta_f \rightarrow C',\theta'$ 
%     \begin{compactenum}[(1)] 
%        \item 
%        \label{safeloc:step:frame}
%    there exists  $\theta''$ such that $\theta'=\theta''*\theta_f$ and       
%        \item 
%        \label{safeloc:step:ind}
%        it holds that  $\safe_{n}(C',\theta'',\xi\unit,\intp,\emptyset,\emptyset,\true,q)$.       
%     \end{compactenum}
%  \end{compactenum}
%  A local configuration $\kappa$ is safe, denoted $\safe^L(\kappa)$, if it is safe for any $0 \leq n$ steps.
%\end{defin}
%
%\begin{defin}[Local Meaning of triples]\label{def:semtriple}
%$\emptyset,\emptyset,\true \vDash_L \{ p \} \, c \, \{ q \}$ if and only if 
%every local configuration $\kappa = (C,\theta,\xi\emp,\intp,\emptyset,\emptyset,\true, q)$
%such that 
%$\theta,\intp \vDash P$ it holds that $\safe^L(\kappa)$.
%\end{defin}
%
%\begin{lemma}
%For local configuration $\kappa = (C,\theta,\xi\unit,\intp,\emptyset,\emptyset,\true, q)$ 
%it holds that
%$\safe(\kappa)$ if and only if $\safe^L(\kappa)$.
%\end{lemma}
%
%\begin{proof}
%Definition~\ref{def:safelocal} is a simplification of Definition~\ref{def:safe}
%for local configurations.
%\qed\end{proof}
%
%\begin{theorem}[Grace logic locally is sound for local configurations]
%  If  $\emptyset,\emptyset,\true \tvdash \{ p \} \, C \, \{ q \}$  
%  then
%  $\emptyset,\emptyset,\true \vDash_L \{ p \} \, C \, \{ q \}$\,.
%\end{theorem}

%\begin{sketch}
%The proof is done by induction following the line of the general soundness proof, but using the simplified definition safety (Definition~\ref{def:localconfig}). 
%\end{sketch}
}

%%% Local Variables:
%%% TeX-master: "recycling"
%%% End:  
