%!TEX root = ./recycling.tex

\section{Formalising Read-Copy-Update}\label{sec:rcu}

%This section formalises the reasoning method for RCU presented informally in
%\S\ref{sec:rcu-prelim}.

\paragraph{RCU specification.} We start by deriving specifications for RCU
commands in our logic from the abstract RCU implementation in
Figure~\ref{fig:RCUProofSketch}; see Figure~\ref{fig:rcu-spec}.  The formula
$S(\ltid,1)$ states that the thread $\ltid$ is in a critical section, and $S(\ltid,0)$, that
it is outside one. We use the identity action {\sf Id} and an action $\RCU_\ltid$
allowing a thread $\ltid$ to enter or exit a critical section. The latter
is used to derive the specification for $\rlock$ and $\runlock$ (see
Figure~\ref{fig:RCUProofSketch}). To satisfy the premisses of the {\sc Shared-R}
rule in these derivations, we require certain conditions ensuring that the RCU
client will not corrupt the {\tt rcu} array. First, we require that the rely $R$
does not change the element of the $\rcu$ array for the thread $\ltid$ executing the
RCU function (condition 1). In practice, $R$ includes the actions $\RCU_k$
for $k\not=\ltid$ and actions that do not access the $\rcu$ array. Second, we
require that $\Upsilon$ be preserved under the actions that RCU
functions execute (condition 2).

%this is easily formalised by adjusting the definition of stability~(\ref{stab}).

The specification for $\sync$ is the most interesting one. The precondition $p
\wedge \tau$ is required to be stable (condition 3), and thus holds for the
whole of $\sync$'s duration. Since, while $\sync$ is executing, every thread
passes through a point when it is not in a critical section, we obtain $\forall
t.\, \tau \since S(t, 0)$ in the postcondition. (We mention the local state $p$
in the specification, as it helps in checking stability; see below.)  The
derivation of the specification from Figure~\ref{fig:RCUProofSketch} is
straightforward: e.g., the invariant of the loop in line~\ref{impl:wait2} is
$
r, i \Vdash p \wedge \forall t.\, (t < i+1 \vee r[t-1] = 0) 
\Rightarrow
(\tau \since S(t,0)).
$
As usual, here we obtain the {\sf since} clause 
by weakening: $(\tau \wedge S(\ltid, 0)) \Rightarrow (\tau \since S(\ltid, 0))$.

% $ \{V \,{\Vdash}\, p \,{\wedge}\,
% \forall 1 \,{\le}\, j \,{<}\, i{+}1. (r[j{-}1]\,{=}\,0 
% \Rightarrow (\tau \since S(j,0))\}$


\begin{figure}[t]
{\small
Let $S(\ltid,k) = \shared{\rcu[\ltid-1]\mapsto k * \true}$ and 
$$
X \leadsto X \quad(\textsf{Id})
%\qquad
\quad
\qquad
\qquad
\rcu[\ltid-1] \mapsto \_ * X \leadsto \rcu[\ltid-1] \mapsto \_ * X \quad(\textsf{RCU}_\ltid)
$$
Then, \quad
$
\begin{array}[t]{@{}l@{}}
R, \{\RCU_\ltid\},\Upsilon \vdash_\ltid
\{S(\ltid,0) \wedge \emp \} \, \mathtt{rcu\_enter()} \, \{S(\ltid,1) \wedge \emp \};
\\
R,\{\RCU_\ltid\},\Upsilon \vdash_\ltid \{S(\ltid,1) \wedge \emp \} \,
\mathtt{rcu\_exit()}\,\{S(\ltid,0)  \wedge \emp \};
\\
R,\{{\sf Id}\},\Upsilon \vdash_\ltid
\{ p \wedge \tau \}\, \sync()\, 
\{p \wedge \forall t.\, \tau \since S(t,0) \},
\end{array}
$

\smallskip
where \quad
\begin{tabular}[t]{@{}l@{}}
1. $R \Rightarrow \{(\rcu[\ltid-1] \mapsto x * \true) \leadsto (\rcu[\ltid-1] \mapsto x * \true)\}$;
\\
2. $\Upsilon$ is stable under $\{{\sf Id}, \RCU_\ltid\}$ and $\true$; and
\\
3. $p \wedge \tau$ is stable under $R \cup \{{\sf Id}\}$ and $\Upsilon$.
\end{tabular}
}
\caption{\label{fig:rcu-spec} \small
Specification of RCU commands}
\end{figure}

\paragraph{Verification of the RCU-based counter.} Since this RCU-based algorithm is similar to the
one using hazard pointers, most actions in relies and guarantees are reused from
that proof (Figure~\ref{fig:HazardRG}): we let $G_\ltid = \{\textsf{Id},
\textsf{Inc}, \textsf{Take}, \textsf{RCU}_\ltid \}$ and $R_\ltid = \bigcup \{G_{k} \mid
{1 \le k \le \nthreads} \wedge {k \not= \ltid}\}$. The following invariant
formalises~(\ref{rcu-inv}):
%in the same way as $\Upsilon_{\sf HP}$ in
%Figure~\ref{fig:HazardRG} formalises the invariant~(\ref{inf-inv}) for hazard pointers:
$$
\Upsilon_{\RCU} \iff
  \forall x, t.\,  (S(t,1) \since 
\shareds{\cc \mapsto x * x \mapsto \_ * \true})
  \Rightarrow \shareds{x \mapsto_{\se} \_* \true}.
$$

%\begin{figure}[t]
%{\figfontsize
%\begin{lstlisting}[numbers=left, numberstyle=\tiny, language=C, escapeinside={(*}{*)}]
%int *C=new int(0); bool rcu[N]={0}; Set detached[N]={(*$\emptyset$*)};
%int inc() {
%  int v, *n, *s;
%  (*$\{V \Vdash n \mapsto \_  * F_\ltid \land I \land S(\ltid,0)\}$*)
%  rcu_enter();
%  do {
%    (*$\{V \Vdash n \mapsto \_  * F_\ltid \land I \land S(\ltid,1)\}$*)
%    rcu_exit();
%    rcu_enter();
%    (*$\langle $*)s = C(*$\rangle_{\textsf{Id}}$*);(*\label{rcu:readc}*)
%    (*$\{V \Vdash n \mapsto \_  * F_\ltid \land I   
%      \ph (S(\ltid,1) \since \shareds{\cc \mapsto s * s \mapsto \_ * \true}) 
%        \land \shareds{s \mapsto_\se \_ * \true}\}$*)
%    (*$\langle $*)v = *s(*$\rangle_{\textsf{Id}}$*);(*\label{rcuget:cderef}*)
%    *n = v+1;
%    (*$\{V \Vdash n \mapsto \_  * F_\ltid\land I  \land 
%    \ph (S(\ltid,1) \since \shareds{\cc \mapsto s * s \mapsto \_ * \true}) 
%        \land \shareds{s \mapsto_\se \_ * \true}\}$\label{rcu:before-cas}*)
%  } while (!CAS(*$_{{\sf Inc}, { \sf Id}}$*)(&C, s, n));(*\label{rcu:cas}*)
%  rcu_exit();
%  (*$\{V \Vdash s \mapsto_{\sm} \_  * F_\ltid \land I \land S(\ltid,0)\}$*)
%  reclaim(s);
%  (*$\{V \Vdash F_\ltid \land I \land S(\ltid,0)\}$*)
%  return v; }
%
%void reclaim(int* s) {  
%  (*$\{V \Vdash s \mapsto_{\sm} \_ * F_\ltid \land I \land S(\ltid,0) \}$*)
%  insert(detached[tid-1], c);
%  if (nondet()) return;
%  (*$\{V \Vdash I \land S(\ltid,0) \land \exists A.\, \rlist[\ltid-1] \mapsto A * \mbox{}$*)
%  (*$\ph (\bigast\nolimits_{x \in A} x \mapsto_\sm \_)  \wedge
%\shareds{(\bigast\nolimits_{x \in A} x \mapsto_\se \_) * \true}\}$*)
%  sync();(*\label{rcu:sync}*)
%  (*$\{V \Vdash I \land S(\ltid,0) \land \exists A.\, \rlist[\ltid-1] \mapsto A * \mbox{}$*)
%  (*$\ph (\bigast\nolimits_{x \in A} x \mapsto_\sm \_) \wedge
%\forall t.\, \shareds{(\bigast\nolimits_{x \in A} x \mapsto_\se \_) * \true} 
%\since S(t,0)\}$\label{rcureclaim:sync}*)
%  (*$\{V \Vdash I \land S(\ltid,0) \land \exists A.\, \rlist[\ltid-1] \mapsto A * \mbox{}$*)
%  (*$\ph \bigast\nolimits_{x \in A} (x \mapsto_\sm \_ \wedge \shareds{x \mapsto_\se
%    \_ * \true}) \wedge 
% \ph \forall t.\, 
%\neg \shareds{\cc \mapsto x * x \mapsto \_ * \true}
% \since S(t,0)\}$\label{rcureclaim:after-sync}*)
%  (*$\langle$*) ; (*$\rangle_{\sf Take}$\label{rcureclaim:take}*)
%  (*$\{V \Vdash I \land S(\ltid,0) \land 
%     \exists A.\,\rlist[\ltid{-}1] \mapsto A * 
%    (\bigast\nolimits_{x \in A} x \mapsto \_)\}$*)
%  while (!isEmpty(detached[tid]))
%    free(pop(detached[tid]));
%  (*$\{V \Vdash F_\ltid \land I \land S(\ltid,0) \}$*) }
%\end{lstlisting}
%}
%\caption{\label{fig:RCUCounterProof2}
%Counter with an RCU-based memory management. 
%Here $V$ is $v, n,s$.}
%\end{figure}

\begin{figure}[t]
\begin{tabular}{@{\quad\ }l@{}l@{}}
\begin{minipage}[b]{0.52\linewidth}
{\figfontsize
\begin{lstlisting}[numbers=left, numberstyle=\tiny, language=C, escapeinside={(*}{*)}]
int *C=new int(0); bool rcu[N]={0}; 
Set detached[N]={(*$\emptyset$*)};
int inc() {
  int v, *n, *s; 
  (*$\{V \Vdash F_\ltid \land I \land S(\ltid,0)\}\}$*)
  n = new int;
  (*$\{V \Vdash n \mapsto \_  * F_\ltid \land I \land S(\ltid,0)\}\}$*)
  rcu_enter();
  do { (*$\{V \Vdash n \mapsto \_  * F_\ltid \land I \land S(\ltid,1) \}$*)
    rcu_exit();
    rcu_enter();
    (*$\langle $*)s = C(*$\rangle_{\textsf{Id}}$*);(*\label{rcu:readc}*)
    (*$\{V \Vdash n \mapsto \_  * F_\ltid \land I \land \shareds{s \mapsto_\se \_ * \true} \land {}$*)
    (*$\ph (S(\ltid,1) \since \shareds{\cc \mapsto s * s \mapsto \_ * \true}) \}$*) 
    (*$\langle $*)v = *s(*$\rangle_{\textsf{Id}}$*);(*\label{rcuget:cderef}*)
    *n = v+1;
    (*$\{V \Vdash n \mapsto \_  * F_\ltid\land I  \land \shareds{s \mapsto_\se \_ * \true}$\label{rcu:before-cas2}*)
    (*$\ph (S(\ltid,1) \since \shareds{\cc \mapsto s * s \mapsto \_ * \true}) \}$\label{rcu:before-cas}*)
  } while (!CAS(*$_{{\sf Inc}, { \sf Id}}$*)(&C, s, n));(*\label{rcu:cas}*)
  rcu_exit(); 
  (*$\{V \Vdash s \mapsto_{\sm} \_  * F_\ltid \land I \land S(\ltid,0) \land{}$*)
  (*$\ph \shareds{s \mapsto_\se \_ * \true} \}$*) 
  reclaim(s); 
  (*$\{V \Vdash F_\ltid \land I \land S(\ltid,0)\}$*)
  return v; }
\end{lstlisting}
}
\end{minipage}
&
\begin{minipage}[b]{0.7\linewidth}
{\figfontsize
\begin{lstlisting}[firstnumber=26,numbers=left, numberstyle=\tiny, language=C, escapeinside={(*}{*)}]
void reclaim(int* s) {  
  (*$\{V \Vdash s \mapsto_{\sm} \_ * F_\ltid \land I \land S(\ltid,0) \land {}$*)
  (*$\ph \shareds{s \mapsto_\se \_ * \true} \}$*) 
  insert(detached[tid-1], s);
  if (nondet()) return;
  (*$\{V \Vdash I \land S(\ltid,0) \land {}$*)
  (*$\ph \exists A.\, \rlist[\ltid-1] \mapsto A * \mbox{}$*)
  (*$\ph (\bigast\nolimits_{x \in A} x \mapsto_\sm \_) \land \mbox{}$*)
  (*$\ph \shareds{(\bigast\nolimits_{x \in A} x \mapsto_\se \_) * \true} \wedge
  \mbox{}$*) 
  (*$\ph (\bigast\nolimits_{x \in A}\neg \shareds{\cc \mapsto x * x \mapsto \_ *
    \true}) \}$*) (*\label{rcu:obtain}*)
  sync();(*\label{rcu:sync}*)
  (*$\{V \Vdash I \land S(\ltid,0) \land {}$*)
  (*$\ph \exists A.\, \rlist[\ltid-1] \mapsto A * \mbox{}$*)
  (*$\ph \bigast\nolimits_{x \in A} ((x \mapsto_\sm \_ \wedge \shareds{x
    \mapsto_\se \_ * \true}) \wedge \forall t.  $*)
  (*$\ph \neg \shareds{\cc \mapsto x * x \mapsto \_ * \true} \since S(t,0))\}$\label{rcureclaim:sync}*)
  (*$\langle$*) ; (*$\rangle_{\sf Take}$\label{rcureclaim:take}*)
  (*$\{V \Vdash I \land S(\ltid,0) \land \mbox{} $*)
  (*$\ph \exists A.\,\rlist[\ltid-1] \mapsto A * \mbox{}$*)
  (*$\ph (\bigast\nolimits_{x \in A} x \mapsto \_) \}$*)
  while (!isEmpty(detached[tid]))
    free(pop(detached[tid]));
  (*$\{V \Vdash F_\ltid \land I \land S(\ltid,0)\}$*)
}
\end{lstlisting}
}
\end{minipage}
\end{tabular}
\caption{\label{fig:RCUCounterProof2}\small
Counter with an RCU-based memory management. 
Here $V$ is $v, n,s$.}
\end{figure}


The proof outline for the RCU-based counter is given in
Figure~\ref{fig:RCUCounterProof2}. The assertion $F_\ltid$ is the same as for
hazard pointers and is defined by~(\ref{ft-def}) in \S\ref{sec:grace}.  The
assertion $I$ describes the state invariant of the algorithm:
$$
I \iff \shared{
  (\bigast\nolimits_{t} \rcu[t-1] \mapsto \_  )
  * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true_\se}.
$$

The key points are as follows.  After reading $\cc$ at line~\ref{rcu:readc}, we
obtain an unstable assertion $S(\ltid,1) \land \shared{\cc \mapsto s * s \mapsto
  \_ * \true}$, which we weaken to a stable one $(S(\ltid,1) \since \shared{\cc
  \mapsto s * s \mapsto \_ * \true})$.  Then $\Upsilon_\RCU$ yields $\shared{s
  \mapsto_\se \_ * \true}$, which justifies the safety of dereferencing {\tt s}
at line~\ref{rcuget:cderef}. The same assertion in line~\ref{rcu:before-cas2}
would let us rule out the ABA problem in a linearizability proof. We get the
assertion in line~\ref{rcu:obtain} from the tautology $x \mapsto_\sm \_
\Rightarrow \neg\shareds{\cc \mapsto x * x \mapsto \_ * \true}$. At
line~\ref{rcu:sync}, we apply the specification of {\tt sync} with $\tau =
\shareds{(\bigast\nolimits_{x \in A} x \mapsto_\se \_) * \true}
\wedge
(\bigast\nolimits_{x \in A}\neg \shareds{\cc \mapsto x * x \mapsto \_ *
    \true})$ and $p =
(\bigast\nolimits_{x \in A} x \mapsto_\sm \_)$. The resulting
{\sf since} clause formalises~(\ref{rcu-neg}) and allows us to justify that the
{\sf Take} action in line~\ref{rcureclaim:take} does not violate
$\Upsilon_\RCU$. 

Like for hazard pointers, this proof implies that the algorithm does not leak
memory, and that the ABA problem does not occur.

%\paragraph{Extensions.}  

%An informal analysis of RCU-based linked lists and hash tables~\cite{hashtable},
%has shown that the reasoning method based on the specifications in
%Figure~\ref{fig:rcu-spec} is applicable to them as well.

%%% Local Variables:
%%% TeX-master: "recycling"
%%% mode: latex
%%% End:  
