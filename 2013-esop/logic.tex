%!TEX root = ./recycling.tex
%
% logic.tex

\section{Abstract Logic\label{sec:logic}}

Reasoning about highly concurrent algorithms, such as the example in
\S\ref{sec:informal}, is convenient in logics based on
rely-guarantee~\cite{Jones83,Pnueli}, which avoids direct reasoning about all
possible thread interactions in a concurrent program by specifying a relation
(the {\em guarantee} condition) for every thread restricting how it can change
the program state. For any given thread, the union of the guarantee conditions
of all the other threads in the program (its {\em rely} condition) restricts how
those threads can interfere with it, and hence, allows reasoning about this
thread in isolation.  

The logic we use to formalise our verification method for memory reclamation
algorithms uses a variant of rely-guarantee reasoning proposed in
SAGL~\cite{sagl} and RGSep~\cite{rgsep}---logics for reasoning about concurrent
programs that combine rely-guarantee reasoning with separation logic. These
partition the program heap into several {\em thread-local} parts (each of which
can only be accessed by a given thread) and the {\em shared} part (which can be
accessed by all threads). The partitioning is defined by proofs in the logic: an
assertion in the code of a thread restricts its local state and the shared
state. Thus, while reasoning about a thread, we do not have to consider local
states of other threads. Additionally, the partitioning is dynamic, meaning that
we can use ownership transfer to move some part of the local state into the
shared state and vice versa. Rely and guarantee conditions are then specified as
relations {\em on the shared state} determining how the threads change it. This
is in contrast with the original rely-guarantee method, in which rely and
guarantee conditions are relations {\em on the whole program state}.  We use
RGSep~\cite{rgsep} as the basis for the logic presented in this section. Our
logic adds just enough temporal reasoning to RGSep to formalise the 
verification method for algorithms based on grace periods that we explained in
\S\ref{sec:informal}. 

%We note that our technical development could be carried out in a logic with a
%simpler metatheory. However, this would lead to more complex algorithm
%proofs---avoiding them is the main focus of this paper.

\input{setting}

\subsection{Assertion Language}\label{sec:asslang}

Assertions in the logic describe sets of \emph{worlds}, comprised of the
\emph{local state} of a thread and a \emph{history} of the \emph{shared}
  state. Local states are represented by elements of a separation
algebra (\S\ref{sec:setting}), and histories, by sequences of those. Our
assertion language thus includes three syntactic categories, for
assertions describing states, histories and worlds.  

%This structure is somewhat complicated, but it simplifies proofs of algorithms,
%which are the focus of this paper.

\paragraph{Logical variables.}
Our logic includes logical variables from a set $\LVar = \LIVar \uplus \LSVar$;
variables from $\LIVar = \{x, y, \ldots\}$ range over integers, and those
from $\LSVar = \{X, Y, \ldots\}$, over memory states. 
Let $\LVal = \State \cup
\mathbb{Z}$ be the set of values of logical variables, and $\LInt \subseteq \LVar \to
\LVal$, the set of their type-respecting interpretations. %  respecting the types.

\paragraph{Assertions for states.}  We assume a language for denoting subsets of
$\State \times \LInt$:%, including at least the following connectives:
$$
p,q 
\ ::=\  \true \mid \neg p \mid p \Rightarrow q  \mid X \mid 
\exists x.\, p \mid \exists X.\, p \mid\emp \mid p * q \mid \ldots
$$ 
%The first three are propositional connectives with the standard meanings. 
The interpretation of interesting connectives is as follows:
$$
\begin{array}{@{}l@{\;\;}c@{\;\;}l@{}}
\theta, \intp \models \emp 
& \iff &
\theta = \varepsilon
\hfill \qquad\qquad
\theta, \intp \models X \iff
\theta = \intp(X)
\\[1pt]
% \theta, \intp \models \exists x.\, p 
% & \iff &
% \exists u \in \mathbb{Z}.\, (\theta, \intp[x : u] \models p)
% \\
% \theta, \intp \models \exists X.\, p 
% & \iff &
% \exists \theta' \in \State.\, (\theta, \intp[X : \theta'] \models p)
% \\
\theta, \intp \models p * q 
& \iff &
\exists \theta',\theta''.\,
(\theta' * \theta'' = \theta)
\wedge
(\theta',\intp \models p)
\wedge
(\theta'',\intp \models q)
\end{array}
$$
The assertion $\emp$ denotes an empty state; $X$, the state given by its
interpretation; and $p*q$, states that can be split into two pieces such that
one of them satisfies $p$ and the other, $q$. We assume that $*$ binds stronger
than the other connectives.

% \sparagraph{Example.}  For a particular instantiation of the separation algebra
% $\State$, the assertion language can be extended to denote its elements. For
% example, take $\State = \RAM$ (\S\ref{sec:setting}), and let $E, F$ range
% over expressions over integer-valued logical variables (such expressions are
% enough for our purposes).  Then we can extend the assertion language with $E
% \mapsto F$, which denotes states with the only allocated cell at the address $E$
% containing $F$: $[\db{E}_{\intp} : \db{F}_{\intp}],\intp \models E \mapsto F$,
% where $\db{E}_{\intp}$ and $\db{F}_{\intp}$ denote the values of the expressions
% $E$ and $F$, respectively, under the interpretation $\intp$.  For example, for
% $\cc \in \Loc$, the assertion $\exists x.\, \cc \mapsto x * x \mapsto
% \_$ denotes heaps with two memory cells, one at the address $\cc$ storing a
% pointer to the other.

\paragraph{Assertions for histories.}  A history is a non-empty sequence
recording all shared states that arise during the execution of a program: $\xi
\in \History = \State^+$.  We denote the length of a history $\xi$ by $|\xi|$,
its $i$-th element by $\xi_i$, and its $i$-th prefix, by $\xi|_i$ (so that
$\big|\xi|_i\big|=i$.)  We refer to the last state $\xi_{|\xi|}$ in a history
$\xi$ as the \emph{current} state.
We define assertions denoting subsets of $\History \times \LInt$:
$$
\begin{array}{@{}l@{\;}c@{\;}l@{}}
\multicolumn{3}{@{}c@{}}{
\tau, \Upsilon 
\ ::= \
\true \mid \neg\tau \mid \tau_1 \Rightarrow \tau_2 \mid
\exists x.\,\tau 
\mid \exists X.\,\tau \mid \shareds{p} \mid
\tau_1 \since \tau_2 \mid \tau \extend \shareds{p}
}
\\[1ex]
\xi, \intp \models \shareds{p} 
& \iff & 
\xi_{|\xi|}, \intp \models p
\\
\xi, \intp \models \tau_1 \since \tau_2  
& \iff &
\exists i \in \{1, ..., |\xi|\}.\, (\xi|_i, \intp \models \tau_2)  
\land
\forall j \in \{ i, ...,|\xi|\}.\, (\xi|_j, \intp \models \tau_1)\\
\xi, \intp \models \tau \extend \shareds{p} 
& \iff &
\exists \xi',\theta.\,
(\xi = \xi'\theta) \land (\xi', \intp \models \tau) \land
(\theta,\intp \models p)
\end{array}
$$
% Thus, an assertion $\pr$ describe both sets of shared states as well as 
% singleton histories. 
% 
%As a matter of convention, we conflate such histories with single states. 
The assertion $\shareds{p}$ denotes the set of histories of shared states, whose
last state satisfies $p$; the box signifies that the assertion
describes a shared state, as opposed to a thread-local one. The assertion
$(\tau_1 \since \tau_2)$ describes those histories where both $\tau_1$ and
$\tau_2$ held at some point in the past, and since then, $\tau_1$ has held
continuously.
%holds in any prefix of $\xi$, including $\xi$ itself, down to a (non empty)
%prefix $\xi|_i$ where \emph{both} $\tau_1$ and $\tau_2$ hold
% \footnote{Our interpretation of {\sf since} deviates from the standard one, which
%   does not require $\tau_1$ to hold at the point when $\tau_2$ does. This avoids
%   a proliferation of assertions of the form $\tau_1 \since (\tau_1 \land
%   \tau_2)$, with $\tau_1$ duplicated.}.  
The assertion $\tau \extend \shareds{p}$ ($\tau$ \emph{extended with}
$\shareds{p}$) describes histories obtained by appending a state satisfying $p$
to the end of a history satisfying $\tau$.  It is easy to check
that~(\ref{incons}) from \S\ref{sec:informal} is indeed a tautology.

% Also, consider the following assertion over $\RAM$: $\shareds{\HP+(\ltid-1)
%   \mapsto x * \true} \since \shareds{ \cc \mapsto x * x \mapsto \_ * \true}$,
% where $\HP$ and $\cc$ are constant addresses. This states that, at some point in
% the past, the cell at the address $x$ was pointed to by the one at the address
% $\cc$, and the hazard pointer of thread $\ltid$ pointed to $x$; since then, the
% hazard pointer has pointed to $x$ continuously.

\paragraph{Assertions for worlds.}
A world consists of a thread-local state and a history of shared
states such that the combination of the local state and the 
current shared state is defined: 
\be\label{world}
\omega \in \World  =  \{ (\theta,\xi) \in 
\State \times \History \mid {(\theta * \xi_{|\xi|})\fdef}\}.
\ee
We define assertions denoting subsets of $\World \times \LInt$:
$$
\begin{array}{@{}l@{\;}c@{\;}l@{}}
\multicolumn{3}{@{}c@{}}{
P, Q \ ::=\ p \mid \tau \mid \true \mid 
\neg P \mid P \Rightarrow Q \mid \exists x.\, P 
\mid \exists X.\, P  \mid P * Q
}
\\[1ex]
\theta, \xi, \intp \models p 
& \iff &
\theta, \intp \models p
\qquad\qquad\hfill
\theta, \xi, \intp \models \tau
\iff \xi, \intp \models \tau
\\[1pt]
\theta, \xi, \intp \models P * Q
& \iff &
\exists \theta', \theta''.\, 
(\theta = \theta' * \theta'') \wedge
%\qquad 
(\theta',  \xi, \intp \models P) \wedge 
(\theta'',  \xi, \intp \models Q)
\end{array}
$$
An assertion $P * Q$ denotes worlds in which the local state can be divided into
two parts such that one of them, together with the history of the shared
partition, satisfies $P$ and the other, together with the same history,
satisfies $Q$. Note that $*$ does not split the shared partition, $p$ does not
restrict the shared state, and $\tau$ does not restrict the thread-local one.

%because threads do not own it, but only have particular views of its
%state. Also note that

% For example, $n \mapsto \_ \wedge \shareds{\exists y.\, \cc \mapsto y * y
%   \mapsto \_ * \true}$ states that the local state has the only cell at the
% address $n$, and the shared state contains at least two cells, one at the
% address $\cc$ pointing to the other.

%To summarise, we have the following types of assertions: $p$---single states;
%$\tau$, $\Upsilon$---histories of the shared partition; and $P$---worlds,
%including the local partition and a history of the shared partition.  

%We write $\db{P}$ for the denotation of $P$ (and similarly for other
%assertions).

%: $\db{P} = \{(\theta,\xi,\intp) \,\mid\, (\theta,\xi,\intp)\models P \}$.

\subsection{Rely/Guarantee Conditions and the Temporal Invariant\label{sec:rely}}

\sparagraph{Actions.}
The judgements of our logic include {\em guarantee} $G$ and {\em rely} $R$
conditions, determining how a thread or its environment can change the shared
state, respectively. Similarly to RGSep~\cite{rgsep}, these are sets of
\emph{actions} of the form $l \mid p * X \leadsto q * X$, where $l$, $p$ and
$q$ are assertions over states, and $X$ is a logical variable over
states.  An action denotes a relation in $\power(\State \times \State \times \State)$:
$$
\db{l \mid p * X \leadsto q * X} = 
\{(\theta_l, \theta_p, \theta_q) \mid 
\exists \intp.\,
(\theta_l, \intp \models l) \land
(\theta_p, \intp \models p * X) \land
(\theta_q, \intp \models q * X)\},
$$
and a rely or a guarantee denotes the union of their action denotations. We
write $R \Rightarrow R'$ for $\db{R} \subseteq \db{R'}$.
Informally, the action $l \mid p * X \leadsto q * X$ allows a thread to change
the part of the shared state that satisfies $p$ into one that satisfies $q$,
while leaving the rest of the shared state $X$ unchanged.  The assertion $l$ is
called a {\em guard}: it describes a piece of state that has to be in the local
partition of the thread for it to be able to perform the action. 
We omit $l$ when it is $\emp$.
%, thus functioning
                                %as a permission to do so. 
Our actions refer explicitly to the
unchanged part $X$ of the shared state, as we
often need to check that a command performing an action preserves global
constraints on it (see \S\ref{sec:outlines}).
We require that $p$ and $q$ in $l \mid p * X \leadsto q
* X$ be precise. An assertion $r$ for states is {\em
  precise}~\cite{seplogic-concurrent}, if for every state $\theta$ and
interpretation $\intp$, there exists at most one substate $\theta_1$ satisfying
$r$, i.e., such that $\theta_1, \intp \models r$ and $\theta = \theta_1 *
\theta_2$ for some $\theta_2$. Informally, a precise assertion carves out a
unique piece of the heap.


%For example, $X \leadsto X$ allows reading the shared state, but not changing
%it, and ${\tt x} \mapsto \_ * X \leadsto {\tt x} \mapsto \_ * X$ allows changing
%the value of the location at the address {\tt x} in any way. 

% The action $\cc \mapsto x * x \mapsto \_ * X \leadsto \cc \mapsto y * y \mapsto
% \_ * X$ allows redirecting the pointer stored at $\cc$. The thread that makes
% the change gets the ownership of the cell $x$, which $\cc$ previously pointed
% to, and has to transfer the ownership of the cell $y$, which $\cc$ becomes
% pointing to, into the shared state.

%Our logic includes the conjunction and forall-quantification rules of Hoare
%logic (\textsc{Conj} and \textsc{Forall}$_1$ in Figure~\ref{fig:logic-rules}),
%which we use in our proofs. For these rules to be sound, 



\paragraph{Temporal invariant.}
Rely/guarantee conditions describe the set of actions that threads can perform
at any point, but do not say anything about temporal protocols that the actions
follow. We describe such protocols using a {\em temporal invariant}, which is an
assertion $\Upsilon$ over histories of the shared state. %that every thread must
                                %respect. 
Every change to the shared state that a thread performs using
one of the actions in its guarantee has to preserve $\Upsilon$; in return, a
thread can rely on the environment not violating the invariant.  
We require that $\Upsilon$ be insensitive to logical variables, i.e., $\forall
\xi, \intp, \intp'.\, (\xi,\intp \models \Upsilon) \iff (\xi,\intp' \models
\Upsilon)$.

%One can thus think of the pre- and postcondition of every action as being
%implicitly intersected with the temporal invariant.


\paragraph{Stability.} When reasoning about the code of a thread in our logic, we
take into account the interference from the other threads in the program,
specified by the rely $R$ and the temporal invariant $\Upsilon$, using the
concept of stability. An assertion over worlds $P$ is {\em stable} under an
action $l \mid p_s \leadsto q_s$ and a temporal invariant $\Upsilon$, if it is
insensitive to changes to the shared state permitted by the action that preserve
the invariant:
\be\label{stab}
\begin{array}{@{}c@{}}
\forall \theta, \theta_s, \theta'_s, \theta_l, \intp, \xi.\,
((\theta, \xi\theta_s, \intp \models P) \wedge 
(\xi\theta_s, \intp \,{\models}\,\Upsilon) \wedge 
(\xi\theta_s\theta'_s, \intp \,{\models}\,\Upsilon) \wedge 
\mbox{}
\\[1pt]
(\theta_l, \theta_s, \theta'_s) \in \db{l \mid p_s \leadsto q_s} \wedge {}
%\\[1pt]
%\qquad
{(\theta * \theta_l * \theta_s)\fdef} \wedge  {(\theta * \theta'_s )\fdef})
 \implies (\theta, \xi\theta_s\theta'_s, \intp \models P).
\end{array}
\ee 
This makes use of the guard $l$: we do not take into account
environment transitions when the latter cannot possibly own the guard, i.e.,
when $\theta_l$ is inconsistent with the current thread-local state $\theta$ and
the current shared state $\theta_s$.  An assertion is stable under $R$ and
$\Upsilon$, when it is stable under every action in $R$ together with
$\Upsilon$. We only consider assertions that
are closed under stuttering on histories: $(\theta, \xi\theta_s\xi',
\intp \models P) \Rightarrow (\theta, \xi\theta_s\theta_s\xi', \intp \models
P)$.
%We also assume that all assertions used in proofs, including $\Upsilon$, are
%closed under stuttering on the last state: $(\theta, \xi\theta_s, \intp \models
%P) \Rightarrow (\theta, \xi\theta_s\theta_s, \intp \models P)$.


\subsection{Proof System}  

The judgements of the logic are of the form $R, G, \Upsilon \vdash_\ltid
\{P\}\,C\,\{Q\} $. Here $P$ and $Q$ are the pre- and postcondition of
$C$, denoting sets of worlds; $G$ describes the set of atomic changes
that the thread $\ltid$ executing $C$ can make to the shared state; $R$, the
changes to the shared state that its environment can make; and $\Upsilon$, the
temporal invariant that both have to preserve. The judgement guarantees that the
command $C$ is safe, i.e., it does not dereference any invalid pointers when
executed in an environment respecting $R$ and $\Upsilon$.

The proof rules of our logic are given in Figure~\ref{fig:logic-rules}.  We have
omitted the more standard rules \tra{\ref{app:formal}}{\nformal}.  We have a
single axiom for primitive commands executing on the local state
(\textsc{Local}), which allows any pre- and postconditions consistent with their
semantics. The axiom uses the expected pointwise lifting of the transformers
$f_\alpha^t$ from \S\ref{sec:setting} to assertion denotations, preserving the
interpretation of logical variables. The \textsc{Conseq} rule looks as usual in
rely/guarantee, except it allows strengthening the pre- and postcondition with
the information provided by the temporal invariant $\Upsilon$.


%Instantiations of the abstract logic can specialise this axiom to several
%syntactic versions.


% $f_\alpha^t(\theta, \intp) = \{(\theta', \intp) \mid \theta' \in
% f_\alpha^t(\theta) \}$, if $f_\alpha^t(\theta)\not=\top$; and
% $f_\alpha^t(\theta,\intp) = \top$, otherwise.  We then lift the resulting
% transformers to state assertion denotations pointwise: $f_\alpha^t(p) = \bigcup
% \{ f_\alpha^t(\theta, \intp) \mid (\theta,\intp) \in p\}$, if $\forall
% (\theta,\intp) \in p.\, f_\alpha^t(\theta, \intp) \not= \top$; $f_\alpha^t(p) =
% \top$, otherwise.
 


% The conjunction rule (\textsc{Conj}) is useful
% for combining the results of two proofs, and the disjunction rule
% (\textsc{Disj}), for doing case splits. We also have standard rules for
% manipulating integer-valued \shortonly{\, and stated-valued \,} 
% logical variables\shortlong{.}{, $\textsc{Exists}_1$ and
% $\textsc{Forall}_1$, as well as their counterparts $\textsc{Exists}_2$ and
% $\textsc{Forall}_2$ for state-valued variables\longonly{~(elided)}.}
 

%This reasoning is sound because all the threads must preserve $\Upsilon$.

\begin{figure}[t]
{\figfontsize
\[
\begin{array}{@{}c@{}}
\infer[\textsc{Local}]{
R, G, \Upsilon \vdash_\ltid \{p\}\,\alpha\,\{q\}
}{
f_\alpha^{\ltid}(\db{p})\subseteq \db{q}
}
\longonly{
\\[5pt]
\infer[\textsc{Disj}]{
R, G, \Upsilon \vdash_\ltid \{P_1 \vee P_2\}\,C\,\{Q_1 \vee Q_2\}
}{
R, G, \Upsilon \vdash_\ltid \{P_1\}\,C\,\{Q_1\} 
&
R,G, \Upsilon \vdash_\ltid \{P_2\}\, C\,\{Q_2\}
}
\\[7pt]
\infer[\textsc{Conj}]{
R,G, \Upsilon \vdash_\ltid \{P_1 \land P_2\}\,C\,\{Q_1 \land Q_2\} \quad
}{
R,G, \Upsilon \vdash_\ltid \{P_1\}\,C\,\{Q_2\}
\quad
R,G, \Upsilon \vdash_\ltid \{P_2\}\,C\,\{Q_2\}
}
\\[7pt]
\infer{
R,G, \Upsilon \vdash_\ltid \{\exists x.\, P\}\,C\,\{\exists x.\, Q\}
}{
R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
}\quad
\infer{
R,G, \Upsilon \vdash_\ltid \{\forall x.\, P\}\,C\,\{\forall x.\, Q\}
}{
R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\} 
}
\\[2pt]
\multicolumn{1}{@{}r@{}}{
\textsc{Exists}_1 
\qquad \qquad 
\qquad \qquad 
\qquad 
\textsc{Forall}_1
\quad \,
}
% \\[7pt]
% \infer[\textsc{Exists}_2]{
% R,G, \Upsilon \vdash_\ltid \{\exists X.\, P\}\,C\,\{\exists X.\, Q\}
% }{
% R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
% }
% \\[7pt]
% \infer[\textsc{Forall}_2]{
% R,G, \Upsilon \vdash_\ltid \{\forall X.\, P\}\,C\,\{\forall X.\, Q\}
% }{
% R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\} 
% }
% \\[7pt]
% \infer[\textsc{Skip}]{
% R, G, \Upsilon \vdash_\ltid \{P\}\,C\,\{P\}
% }
% {
% \Upsilon ~ \mbox{is closed under stuttering}
% }
\\[5pt]
}
\qquad
\infer[\textsc{Conseq}]{
R, G,\Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
}{
\begin{array}{@{}c@{}}
P \wedge \Upsilon \Rightarrow P' \quad R \Rightarrow R' \quad
G' \Rightarrow G \quad Q' \wedge \Upsilon \Rightarrow Q
\\%[2pt]
 R', G',\Upsilon \vdash_\ltid \{P'\}\,C\,\{Q'\} 
\end{array}
}
\\[5pt]
\infer[\textsc{Frame}]{
R, G, \Upsilon \vdash_\ltid \{P*F\}\,C\,\{Q*F\}
}{
\begin{array}{@{}c@{}}
R, G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
\\ % \quad
F \mbox{ is stable under $R \cup G$ and $\Upsilon$}
\end{array}
}
\quad
\infer[\textsc{Shared-R}]{
R, G, \Upsilon \vdash_\ltid \{P\}\, 
\langle C\rangle_a \, 
\{ Q \} %Q \{q \wedge (\tau \extend \shareds{q_s})\}
}{
\begin{array}{c}
Q \Rightarrow \Upsilon \qquad
\text{$P$, $Q$ are stable under $R$ and $\Upsilon$}
\\%[2pt]
\emptyset,G,\true \vdash_\ltid \{ P \} \,\langle C\rangle_a\, \{ Q \}
\end{array}
}
\\[5pt]
\infer[\textsc{Shared}]{
\emptyset, G, \true \vdash_\ltid \{p \wedge  \tau \wedge \shareds{p_s}\}\, 
\langle C\rangle_a\, 
\{ q \wedge ((\tau \wedge \shareds{p_s}) \extend \shareds{q_s}) \}
}{
\begin{array}{c}
p \Rightarrow l * \true
\qquad
\{l \mid p_s \leadsto q_s\} \Rightarrow \{a\} 
\qquad
a \in G
\qquad
\emptyset,\emptyset,\true \vdash_\ltid \{ p * p_s \} \,C\, \{ q * q_s \}
\end{array}
}
\\[5pt]
\begin{array}{@{}r@{}}
\infer[\textsc{Par}]{
 \vdash \{P_1 * \ldots * P_n\}\,C_1 \parallel \ldots \parallel C_n\,\{Q_1 * \ldots * Q_n\}
}{
\begin{array}{@{}c@{}}
R_1,G_1,\Upsilon  \vdash_1 \{P_1\}\,C_1\,\{Q_1\} \quad
\ldots\quad
R_n,G_n,\Upsilon  \vdash_n \{P_n\}\,C_n\,\{Q_n\}\\%[2pt]
R_\ltid = \bigcup\{G_k \mid 1\leq k \leq n \land  k\neq \ltid\}
\qquad
P_1 * \ldots * P_n \Rightarrow \Upsilon
\qquad
P_k, Q_k \mbox{ stable under } R_k \mbox{ and } \Upsilon
\end{array}
}
\end{array}
\end{array}
\]
}
\vspace{-10pt}
\caption{\small Proof rules of the logic}
\label{fig:logic-rules}
\end{figure}





By convention, the only commands that can operate on the shared state are atomic
blocks, handled by the rules {\sc Shared-R} and {\sc Shared}.  The {\sc
  Shared-R} rule checks that the atomic block meets its specification in an
empty environment, and then checks that the pre- and postcondition are stable
with respect to the actual environment $R$, and that the postcondition implies
the invariant $\Upsilon$. Note that to establish the latter in practice, we can
always add $\Upsilon$ to the precondition of the atomic block using {\sc
  Conseq}.

{\sc Shared} handles the case of an empty rely condition, left by {\sc
  Shared-R}.  It is the key rule in the proof system, allowing an atomic command
$C$ to make a change to the shared state according to an action $l \mid p_s
\leadsto q_s$. The action has to be included into the {\em annotation} $a$ of
the atomic block, which in its turn, has to be permitted by the guarantee $G$.
The annotations are part of proofs in our logic.  For the logic to be sound, we
require that every atomic command in the program be annotated with the same
action throughout the proof.  {\sc Shared} also requires the thread to have a
piece of state satisfying the guard $l$ in its local state $p$. It combines the
local state $p$ with the shared state $p_s$, and runs $C$ as if this
combination were in the thread's local state. The rule then splits the resulting
state into local $q$ and shared $q_s$ parts. Note that {\sc Shared} allows the
postcondition of the atomic block to record how the shared state looked like
before its execution: the previous view $\shareds{p_s}$ of the shared state and
the assertion $\tau$ about its history are extended with the new shared state
$\shareds{q_s}$ with the aid of $\extend$ (\S\ref{sec:setting}).

%all the judgements used in a proof of a program have to agree on the treatment
%of the shared state. Thus,


The {\sc Frame} rule ensures that if a command $C$ is safe when run from states
in $P$, then it does not touch an extra piece of state described by $F$. Since
$F$ can contain assertions constraining the shared state, we require it to be
stable under $R \cup G$ and $\Upsilon$. 

%The stability under $G$ is needed to take into account the effect of commands in
%$C$ accessing the shared state.


{\sc Par} combines judgements about several threads.  Their pre- and
postconditions in the premisses of the rule are $*$-conjoined in the conclusion,
which composes the local states of the threads and enforces that they have the
same view of the shared state.

%Every thread must take into account the possible interference from the other
%threads specified by their guarantees.


%The resulting precondition has to imply the temporal invariant $\Upsilon$.

%%% Local Variables:
%%% TeX-master: "recycling"
%%% End:  
