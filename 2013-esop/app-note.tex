%!TEX root = ./recycling.tex
%
% note.tex

\section{Note}
\subsection{Logic}

Model of states: separation algebra $\Sigma$

Semantics of assertions: $\power(\Sigma^+) \times \LInt$ (finite sequences of states in
$\Sigma$ representing a history).

$\power((\Sigma \times \Sigma)^+) \times \LInt$

$\Sigma \times \power(\Sigma^+) \times \LInt$ - the local state and the history
over the shared state

Operations on assertions:

$\dlf{p}$ - projection to the present

$\dlf{p} = \{\sigma \mid \alpha\sigma \in p\}$

$p \circ q = \{\alpha \sigma \mid \exists \beta.\, \alpha \in p \wedge \beta\sigma \in q\}$

We assume an assertion language for denoting subsets of $\Sigma \times \LInt$, 
including at least the following connectives:
$$
p,q ::= {\sf true} \mid \exists X.\, p \mid \neg p \mid p \wedge q 
\mid  p \vee q \mid p \Rightarrow q  \mid 
\emp \mid p * q
$$

$$
P, Q :: = p \mid \shareds{p} \mid {\sf true} \mid {\sf false} \mid 
\exists X.\, P \mid \forall X.\, P \mid 
P * Q \mid P \wedge Q \mid P \vee Q \mid P \since Q
$$

We might need non-positive connectives

$$
\sigma_0\ldots\sigma_n \models  P \since Q \Leftrightarrow
\exists j.\, 0 \le j \le n \wedge
\sigma_j \in \db{Q} \wedge \forall i.\, j \le i \le n \Rightarrow
\sigma_i \in \db{P}.
$$

formulas in since need to refer only to the shared state

$R, G$ - on states, $\Sigma \times \Sigma$

$R, G, I \vdash \{P\}\,C\,\{Q\}$

$I$ - a usual assertion, possibly temporal

Stability: $P$ is stable under $R$ when
$$
\forall (\alpha, \intp) \in P.\, \forall (\sigma, \sigma') \in R.\,
\exists \beta.\, \alpha = \beta\sigma \Rightarrow (\alpha \sigma', \intp) \in P.
$$

May be also intersect with $I$.

In stability the relation is intersected with $I \times I$

$\dlf{P \since Q} \Rightarrow P$

$$
P \wedge Q \Rightarrow P \since Q
$$
$$
((P \since Q) \circ Q') \wedge (Q' \Rightarrow P) \Rightarrow 
(P \since Q)
$$

Where to put stability conditions (vs the problematic example)


Put thread identifier into judgements?

\begin{figure}[p]
$$
\begin{array}{@{}c@{}}
\infer[\textsc{Local}]{
R, G, I \vdash \{p\}\,c\,\{q\}
}{
f_c(\db{p})\sqsubseteq \db{q}
}
\\
\\
\infer[\textsc{Seq}]{
R, G, I \vdash \{P_1\}\,C_1; C_2\,\{P_3\}
}{
R, G, I \vdash \{P_1\}\,C_1\,\{P_2\} 
\\[2pt]
R,G, I \vdash \{P_2\}\,C_2\,\{P_3\}
}
\\
\\
\infer[\textsc{Choice}]{
 R, G,I \vdash \{P\}\,C_1+C_2\,\{Q\}
}{
R, G,I \vdash \{P\}\,C_1\,\{Q\} 
\\[2pt]
 R, G,I \vdash \{P\}\,C_2\,\{Q\}
}
\\
\\
\infer[\textsc{Loop}]{
 R, G,I \vdash \{P\}\,C^{*}\,\{P\}
}{
 R, G,I \vdash \{P\}\,C\,\{P\}
}
\\
\\
\infer[\textsc{Conseq}]{
R_1, G_1,I \vdash \{P_1\}\,C\,\{Q_1\}
}{
P_1 \Rightarrow P_2 \qquad R_1 \Rightarrow R_2 \qquad
G_2 \Rightarrow G_1 \qquad Q_2 \Rightarrow Q_1
\\[2pt]
 R_2,G_2,I \vdash \{P_2\}\,C\,\{Q_2\} \hfill
}
\\
\\
\infer[\textsc{Disj}]{
R, G, I \vdash \{P_1 \vee P_2\}\,C\,\{Q_1 \vee Q_2\}
}{
R, G, I \vdash \{P_1\}\,C\,\{Q_1\} 
\\[2pt]
R,G, I \vdash \{P_2\}\, C\,\{Q_2\}
}
\\
\\
\infer[\textsc{Exists}]{
R,G, I \vdash \{\exists x.\, P\}\,C\,\{\exists x.\, Q\}
}{
R,G, I \vdash \{P\}\,C\,\{Q\}
}
\\
\\
\infer{
R, G, I \vdash \{P*F\}\,C\,\{Q*F\}
}{
R, G, I \vdash \{P\}\,C\,\{Q\}
\qquad
F \mbox{ is stable under $R \cup G$}
}\\
\hfill\textsc{Frame}
\\
\\
\infer{
 \vdash \{P_1 * \ldots * P_n\}\,C_1 \parallel \ldots \parallel C_n\,\{Q_1 * \ldots * Q_n\}
}{
R_1, G_1,I \vdash \{P_1\}\,C_1\,\{Q_1\} \\[2pt]
\cdots \phantom{\Gamma}\\[2pt]
R_n, G_n,I \vdash \{P_n\}\,C_n\,\{Q_n\}
}
\\[2pt]
\mbox{(where $R_t = \bigcup\{G_k \mid 1 \le k \le n \wedge  k \not = t\}$)}
\\
\hfill\textsc{Par}
\\
\\
\infer[\textsc{Shared}]{
R, G,I \vdash \{p * P\}\,{\sf atomic}\, \{\,C\,\}\,
\{q * (P \circ q')\}
}{
\vdash_{\sf SL} \{p * \dlf{P}\}\,C\,\{q * q'\}
\quad
\dlf{P} \times q' \subseteq G
\\[2pt]
\mbox{$P$ only over the shared state}
\quad (P \circ q') \Rightarrow I
}
\end{array}
$$
\caption{Proof rules}
\label{fig:rules}
\end{figure}

\subsection{Logic instantiation}

We use only a limited number of tautologies involving $\since$. We can first
present a general logic, and then use the tautologies below to get derived rules
specialised for the particular forms of temporal invariants, etc. that we use.

$(A \wedge B) \Rightarrow (A \since B)$

$A \since B$ is stable if so is $A$

$(A \since B) \circ A \Rightarrow (A \since B)$

$\dlf{A \since B} \Rightarrow A$

$\neg(A \since B) \circ \neg B \Rightarrow \neg(A \since B)$

NB: We might need to use consistency with the local state when we check the
satisfaction of $I$ in the Shared rule. We might also need to tighten the
interpretation of assertions so that it checks the consistency of the local and
the shared state.

We can use a rule derived from Shared and specialised to the form of the
temporal invariant $(A \since B)\Rightarrow C$.

$$
\infer{
\{((A \since B) \Rightarrow C ) \wedge P\}\, \langle c \rangle\,
\{((A \since B) \Rightarrow C) \wedge Q\}
}{
\begin{array}{c}
\{A \wedge C \wedge P\}\, c\, \{((A \wedge C) \vee \neg(A \wedge B)) \wedge Q\}
\\[3pt]
\{(\neg B \vee (B \wedge \neg A)) \wedge P\}\, c\, 
\{\neg B \vee B \wedge \neg A \vee A \wedge B \wedge C) \wedge Q\}
\end{array}
}
$$

So, you can either preserve the validity of the since clause and $C$ or
invalidate it. Might also split this rule into several ones, for different cases.

May be the disjunctions $\neg B \vee (B \wedge \neg A)$ are not needed; a
stronger one would do, e.g., $\neg B$.

Note that it's too imprecise to apply the Shared rule straight on the
implication $(A \since B) \Rightarrow C$: you'll lose corellations with the next
state and the history. So, first you need to make a case split on whether the
since clause is true using the disjunction rule. Note that the assertions that
you get (like, the since clause) aren't stable in general (they are if we're in
the reclaimer, but not the a reader). So, we need to formulate the stability
constraints carefully to check the stability only before applying the
disjunction rule and after.

\subsection{Hazard pointers}

%	\newcommand{\HP}{\texttt{HP}}
%	\newcommand{\cc}{\texttt{C}}
%	\newcommand{\pp}{\texttt{p}}
%  \newcommand{\nthreads}{\texttt{N}}
%	\newcommand{\listp}{\texttt{list}}
%	\newcommand{\listpp}{\texttt{list2}}
%	\newcommand{\idx}{\texttt{idx}}
%	\newcommand{\idxx}{\texttt{idx2}}
%	\newcommand{\lsize}{\texttt{L}}
%	\newcommand{\rcu}{\texttt{rcu}}

$$
J = \exists y.\, 
(\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
$$

{\small
\begin{lstlisting}[style=nonumbers,language=C,escapeinside={(*}{*)}]
int *HP[NTHREADS] = {0};
int *C = new int(0);
int *list[NTHREADS][LSIZE];
int idx[NTHREADS] = {0};
int* list2[NTHREADS][LSIZE] = {0};

int inc() {
  int *x = new int;
  int *p, *p2;
  int v;
  (*$\{F_t * x \mapsto \_ * (\shared{\exists y.\, 
(\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) *
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  do {
    (*$\{F_t * x \mapsto \_ * (\shared{\exists y.\, 
(\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) *
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
    do {
      (*$\langle$*)p = C;(*$\rangle_{\sf Id}$*)
      (*$\{F_t * x \mapsto \_ * (\shared{\exists y.\, 
(\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * \cc \mapsto y * 
y \mapsto \_ * \true} \wedge I)\}$*)
      (*$\langle$*)HP[tid()] = p;(*$\rangle_{\textsf{HP}_t}$*)
      (*$\{F_t * x \mapsto \_ * (\shared{\exists y.\, 
(\bigast_{0 \le i \le \nthreads, i \not= t} \HP[i] \mapsto \_) * 
\HP[t] \mapsto \pp * \cc \mapsto y * 
y \mapsto \_ * \true} \wedge I)\}$*)
      (*$\langle$*)p2 = C(*$\rangle_{\sf Id}$*);
      // Establish A since B as both A and B are true now
      // Check stability by checking A
      // Then do MP on that and the temporal invariant
      (*$\{F_t * x \mapsto \_ * \left(\shared{
\begin{array}{l}
\exists y.\, (\bigast_{0 \le i \le \nthreads, i \not= t} \HP[i] \mapsto \_) * 
\HP[t] \mapsto \pp * \cc \mapsto y * y \mapsto \_ * \\
(({\tt p2} = \pp) \Rightarrow
(\HP[t] \mapsto \pp \since \cc \mapsto \pp)) * \true
\end{array}
} \wedge I\right)\}$*)
    } while (p != p2);
    (*$\{F_t * x \mapsto \_ * \left(\shared{
\begin{array}{l}
\exists y.\, (\bigast_{0 \le i \le \nthreads, i \not= t} \HP[i] \mapsto \_) * 
\HP[t] \mapsto \pp * \cc \mapsto y * y \mapsto \_ * \\
(\HP[t] \mapsto \pp \since \cc \mapsto \pp) * \true \wedge 
(\pp \mapsto_e \_ * \true)
\end{array}
} \wedge I\right)\}$*)
    (*$\langle$*)v = *p;(*$\rangle_{\sf Id}$*)
    *x = v+1;
    (*$\{F_t * x \mapsto \_ * \left(\shared{
\begin{array}{l}
\exists y.\, (\bigast_{0 \le i \le \nthreads, i \not= t} \HP[i] \mapsto \_) * 
\HP[t] \mapsto \pp * \cc \mapsto y * y \mapsto \_ * \\
(\HP[t] \mapsto \pp \since \cc \mapsto \pp) * \true \wedge 
(\pp \mapsto_e \_ * \true)
\end{array}
} \wedge I\right)\}$*)
  } while ((*$\langle$*)CAS(&C, p, x)(*$\rangle_{\textsf{Inc}}$*));
  HP[tid()] = NULL;
  (*$\{F_t * \pp \mapsto_m \_ * \left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true \wedge (\pp \mapsto_e \_ * \true)
} \wedge I\right)\}$*)
  retire(p);
  return v;
}

void retire(int* p) {  
  (*$\{F_t * \pp \mapsto_m \_ * \left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true \wedge (\pp \mapsto_e \_ * \true)
} \wedge I\right)\}$*)
  list[tid()][idx] = p;
  idx[tid()]++;
  if (idx[tid()] != LSIZE) {
    (*$\{F_t * \left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
} \wedge I\right)\}$*)
    return;
  }
  (*$\{
(\bigast_{i=0}^{\lsize} \listp[t][i] \mapsto x * x \mapsto_m \_ * \shared{x
  \mapsto_e \_ * \true}) * {}$*)
  (*$\phantom{\{}\left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
} \wedge I\right)\}$*)
  int idx2 = 0;
  for (int k = 0; k < LSIZE; k++) {
    (*$\{
(\bigast_{i=0}^{k-1} \listp[t][i] \mapsto \_)*
(\bigast_{i=k}^{\lsize} \listp[t][i] \mapsto x * x \mapsto_m \_ * \shared{x
  \mapsto_e \_ * \true}) * \mbox{}$*)
    (*$\phantom{\{}
(\bigast_{i=0}^{\idxx[t]-1} \listpp[t][i] \mapsto x * 
x \mapsto_m \_ * \shared{x \mapsto_e \_ * \true})*
(\bigast_{i=\idxx[t]}^{\lsize-1} \listpp[t][i] \mapsto \_) *{}$*)
    (*$\phantom{\{}\left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
} \wedge I\right)
\}$*)
    for (int t = 0; t < NTHREADS && list[tid()][k] != HP[t]; t++)
      ;
    // Establish A since B as usual: A and B are true
    if (t < NTHREADS) {
      list2[tid()][idx2] = list[tid()][k]; 
      idx2++;
    } else {
      (*$\{
(\bigast_{i=0}^{k-1} \listp[t][i] \mapsto \_)*
(\bigast_{i=k-1}^{\lsize} \listp[t][i] \mapsto x * x \mapsto_m \_ * \shared{x
  \mapsto_e \_ * \true}) * \mbox{}$*)
      (*$\phantom{\{}
(\bigast_{i=0}^{\idxx[t]-1} \listpp[t][i] \mapsto x * 
x \mapsto_m \_ * \shared{x \mapsto_e \_ * \true})*
(\bigast_{i=\idxx[t]}^{\lsize-1} \listpp[t][i] \mapsto \_) *{}$*)
    (*$\phantom{\{}\left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
} \wedge I\right)$*)
      (*$\phantom{\{}
\exists x.\, 
\listp[t][k] \mapsto x * x \mapsto_m \_ * \shared{x \mapsto_e \_ * \true}*$*)
      (*$\phantom{\{} (\bigwedge_{t=0}^{\nthreads}
\neg (\cc \mapsto x * \true) \since \neg (\HP[t] \mapsto x))
\}$*)
      // (*$\neg (\cc \mapsto x * \true) \since \neg (\HP[t] \mapsto x)
\Rightarrow \neg (\HP[t] \mapsto t * \true \since \cc \mapsto x * \true)$*)
      (*$\langle$*);(*$\rangle_{\sf Take}$*)
      // We get not I in the postcondition
      free(list[tid()][k]);
    }
  }
  (*$\{
(\bigast_{i=0}^{\lsize-1} \listp[t][i] \mapsto \_)* \mbox{}$*)
  (*$\phantom{\{}
(\bigast_{i=0}^{\idxx[t]-1} \listpp[t][i] \mapsto x * 
x \mapsto_m \_ * \shared{x \mapsto_e \_ * \true})*
(\bigast_{i=\idxx[t]}^{\lsize-1} \listpp[t][i] \mapsto \_) *{}$*)
  (*$\phantom{\{}\left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
} \wedge I\right)
\}$*)
  for (int j = 0; j < idx2; j++) {
    list[tid()][j] = list2[tid()][j]; 	  
  }
  idx[tid()] = idx2;
  (*$\{F_t * \left(\shared{
\exists y.\, (\bigast_{i=0}^\nthreads \HP[i] \mapsto \_) * 
\cc \mapsto y * y \mapsto \_ * \true
} \wedge I\right)\}$*)
}
\end{lstlisting}
}

We also need to check that all the actions, even ones of the reader, preserve
the invariant, using the derived rules below. Need to see how complicated it is
to spell it out.


$$
\begin{array}{c}
F_t = 
(\bigast_{i=0}^{\idx[t]} \listp[t][i] \mapsto x * x \mapsto_m \_ * \shared{x
  \mapsto_e \_ * \true}) * {}\\
(\bigast_{i=\idx[t]}^{\lsize} \listp[t][i] \mapsto \_) * 
(\bigast_{i=0}^{\lsize} \listpp[t][i] \mapsto \_)
\end{array}
$$

$$
I = \forall x.\, \forall t \in \{1,\ldots,\nthreads\}.\,
(\shared{\HP[t] \mapsto x * \true} \since \shared{\cc \mapsto x * \true}) 
\Rightarrow \shared{x \mapsto_e \_* \true}
$$

\be
\HP[t] \mapsto \_ \leadsto \HP[t] \mapsto \_
\tag{$\textsf{HP}_t$}
\ee
\be
\cc \mapsto x * x \mapsto \_ \leadsto 
\cc \mapsto y * y \mapsto \_ * x \mapsto_e \_
\tag{$\textsf{Inc}$}
\ee
\be
y \mapsto_m \_ \mid
\cc \mapsto x * x \mapsto \_ * y \mapsto_e \_
\leadsto
\cc \mapsto x * x \mapsto \_
\tag{$\textsf{Take}$}
\ee
\be
\emp
\leadsto
\emp
\tag{$\textsf{Id}$}
\ee


$G_t = \{\textsf{HP}_t, \textsf{Inc}, \textsf{Take}, \textsf{Id}\}$


Stuff everything into actions - then actions have to be over traces, and it gets
very complicated. Instead, we use invariants or Richard's idea of stable
assertions as relies/guarantees.

``I will be the one to remove it'' can be formulated using custodian states, or
permissions, or temporal formulas. Uniform approaches vs a combination better
suited for the algorithms.

Don't pitch it from the point of view of a temporal logic plus separation
logic. Exhibiting similarities between algorithms, really nice proofs.

\subsection{RCU}

{\small
\begin{lstlisting}[style=nonumbers,language=C,escapeinside={(*}{*)}]
int *C = new int(0);
bool rcu[NTHREADS] = {0};

int get(){
  (*$\{\rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  rcu_read_lock(); 
  (*$\{\rcu[t] \mapsto 1 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  int *c = C;
  (*$\{\rcu[t] \mapsto 1 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)*{}$*)
  (*$\phantom{\{}
(\shared{\rcu[t] * \true} \since \shared{\cc \mapsto {\tt c} * \true}) *
\shared{{\tt c} \mapsto_e \_ * \true}\}$*)
  int v = *c;
  (*$\{\rcu[t] \mapsto 1 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  rcu_read_unlock();
  (*$\{\rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  return v;
}

int inc(){
  int *x = new int;
  (*$\{x \mapsto \_ * \rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  rcu_write_lock();
  int* c = C;
  (*$\{x \mapsto \_ * \rcu[t] \mapsto 1 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)*{}$*)
  (*$\phantom{\{}
(\shared{\rcu[t] * \true} \since \shared{\cc \mapsto {\tt c} * \true}) *
\shared{{\tt c} \mapsto_e \_ * \true}\}$*)
  int v = *c;
  *x = v+1;
  (*$\{x \mapsto \_ * \rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true} \wedge I)\}$*)
  C = x;
  (*$\{{\tt c} \mapsto_m \_ * \rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true * {\tt c} \mapsto_e \_} \wedge I)\}$*)
  rcu_sync();
  (*$\{{\tt c} \mapsto \_ * \rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true * {\tt c} \mapsto_e \_} \wedge I)*{}$*)
  (*$\phantom{\{}\forall t.\, \neg (\rcu[t] * \true \since \cc \mapsto c * \true)\}$*)
  (*$\langle$*);(*$\rangle_{\sf Take}$*)
  (*$\{{\tt c} \mapsto_m \_ * \rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true * {\tt c} \mapsto_e \_} \wedge I)\}$*)
  free(c);
  (*$\{\rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true * {\tt c} \mapsto_e \_} \wedge I)\}$*)
  rcu_write_unlock();
  (*$\{\rcu[t] \mapsto 0 *
(\shared{\exists y.\, 
\cc \mapsto y * y \mapsto \_ * \true * {\tt c} \mapsto_e \_} \wedge I)\}$*)
  return v;
}
\end{lstlisting}
}


$$
\{P\}\, \sync\, \{\forall t.\, P \since \neg\rcu[t]\}
$$

$$
\{P\}\, \sync\, \{\forall t.\, \neg (\rcu[t] \since \neg P)\}
$$

$P = \neg(\cc \mapsto x * \true)$

$P$ is stable

$$
I = \forall t.\, (\rcu[t] * \true \since \cc \mapsto x * \true) \Rightarrow x \mapsto_e \_* \true
$$

What to do with sync? Axiomatising it or using an abstract implementation and
linearizing a given one to it.

$P \since Q$ stable under $G$ if $P$ is stable under $G$?

\subsection{Epoch-based reclamation}

{\small
\begin{lstlisting}[style=nonumbers,language=C,escapeinside={(*}{*)}]
struct Retired {
  int *p;
  Retired *n;
};

int Epoch = 0;
lock Elock;
int Tepoch[NTHREADS];
Retired* Limbo[NTHREADS][3];
 
int inc() {
  enter_epoch();
  int *x = new int;
  do {
    // Establishing the since clause is as usual and easy
    int* c = C;
    int v = *c;
    *x = v + 1;
   } while (!CAS(&C, c, x)); 
   epoch_free(c);
   return v;
}

void enter_epoch() {   
  int e = Epoch;
  if (Tepoch[tid] == e) {
    if (nondet())
      reclaim();
  } else {
    (*$\langle$*)Tepoch[tid] = Epoch;(*$\rangle$*)
  }
}

bool reclaim() {  
  lock(Elock);
  int e = Epoch;

  for (int t = 0; t < NTHREADS; t++) {
    if (e != Tepoch[tid()]) {
      unlock(Elock);
      return false;
    }
  }  
 
  int oldest = (e + 1) % 3;   
  // Since everyone is at e, the limbo lists for e-1 and e-2 are not taken
  // 'Since everyone is at e' is stable, as the only way to change local ones is
  // by copying from the global one, and I'm not changing it
  for (t = 0; t < NTHREADS; t++) {
    Retired *r = limbo[t][oldest];
    while (r != NULL){
      // Here we use the since clause generated at detach
      free(r.p)
      free(r);
    }
    limbo[t][oldest] = null;   
  }
  Epoch = oldest;
  unlock(Elock);
  return true;
}

void epoch_free(int *c) {
  // You always own your limbo list for the epoch you're in
  int e = Tepoch[tid()];
  Retired *x = new int;
  x->p = c;
  x->n = Limbo[tid()][e];
  Limbo[tid()][e] = x; 
  // Here we generate a since clause (see the proof below)
}
\end{lstlisting}
}

$$
I = \forall t.\, (\lep[t] = k \since \cc \mapsto x * \true) \Rightarrow x \mapsto_e \_* \true
$$
(note that the since clause is equivalent to $\lep[t] = k \since \lep[t] = k
\wedge \cc \mapsto x * \true$. So, if I saw something when I was in a certain
epoch, it will not disappear while I'm in the same epoch. In particular, you
might try to recast the invariant in terms of the global epoch.

This invariant is analogous to the ones in hazard/RCU algorithms, so the reader
doesn't have to do much to establish the since clause. However, it puts a lot of
proof burden on the reclaimer. It might be that there are other formulations
that spread the proof burden in a different way.

Inc: need to ensure the cell c is still there when I dereference it

Establish the premiss of $I$: requires establishing that the epoch can't change
more than 1 ahead of where you are

Actions:

copy global epoch Epoch into local one Tepoch[t] (only the corresponding thread) and take the
full ownership of Limbo[t][Tepoch[t]] (so, you can add nodes to it freely) and
put the previous limbo list back

get epoch lock (same as with RCU lock, no concurrent reclamation)

take: get the limbo lists for all threads for Epoch+1 (the check that everyone
is in the current epoch ensures that these are actually in the shared state)

release epoch lock

increment the global epoch: put the limbo list array element back

Notation: GEpoch, LEpoch - local and global epoch

\mypar{Why the reclaimer does not violate the invariant.} 
We rely on the following global invariant:
$$
\forall t.\, \gep \in \{\lep[t], \lep[t]+1\}.
$$
This is because the global epoch only changes when everyone is at the previous
epoch: need to guard the action accordingly.

Assume the reclaimer is reclaiming from the limbo list $k$. Then everyone is at
$k+2$. So, we need to check the following instantiation of the temporal
invariant:
$$
(\lep[t] = k+2 \since \cc \mapsto x \wedge \lep[t] = k+2) \Rightarrow x \mapsto \_
$$
We show this by showing
$$
\neg (\lep[t] = k+2 \since \cc \mapsto x \wedge \lep[t] = k+2)
$$

Consider the time when x is detached into the limbo list $k$ by thread $t'$ and
assume that the thread $t$ is at $k+2$. Then $\lep[t'] = k$ and $\lep[t] =
k+2$. Hence, $\gep \in \{k, k+1\}$ and $\gep \in \{k+2, k\}$. From this, $\gep = k$,
which implies
$$
(\lep[t] = k+2 \since \cc \mapsto x \wedge \lep[t] = k+2) \Rightarrow \gep = k
$$
If this is stable, then it will be true at the time of the reclaim. But at that
point $\gep = k+2$, so the since clause is false as required.

Let us show the stability of the above assertion. Consider a state where the
assertion is true, and a transition from that state. Assume the assertion is
false at the target state, so that the since clause is true, but $\gep\not= k$.
We have two cases.

1. The since clause is false. To make it true in the target state has to have
$\cc \mapsto x$, but this can't happen because the reclaimer holds the master
permission for the node.

2. The since clause is true and $\gep = k$. If $\gep = k$ in the source state
and $\gep \not= k$ in the next state, then in the next state $\gep=k+1$. Since
the since clause is true in the next state, there we have $\lep[t] = k+2$. But
this and $\gep= k+1$ contradict the invariant relating the two.

We also need to handle the case when the thread that detaches the node is the
one for which we need to check the invariant (easy).


\subsection{Repeated Offender Problem}

The code is simplified in the following manner:

1. The loop in procedure Liberate is unrolled.

2. The number of ``deployed'' guards and their assignments to threads is fixed.
(Thread t uses guard t.) Thus, the array GUARDS and the shared variable MG got removed. Also, the \texttt{while} loop was replaced by a \texttt{for} loop.
\textbf{Note: The condition in the while loop in \texttt{Liberate} is \texttt{i <= MG}. This seems a bit weird - i.e., condition \texttt{i < MG} seems to work. See if there is a hidden race.}


3. The names of the arrays is shortened: Post => P and HANDOFF => HO.

4. Procedure Liberate does not return a set because it modifies its parameter.  



{\small
\begin{lstlisting}[style=nonumbers,language=C,escapeinside={(*}{*)}]
int *C = new int(0);

Set *set[NTHREADS] = {new Set(), ..., new Set()};
typedef struct { value val; int ver } entry;
const int MG = NTHREADS;
value P[MG] = {0};  
entry HO[MG] = {<null,0>}; 

int inc() {
  int *p, *p2, *x = new int;
  int v;
  do {
    do {
      p = C;
      P[tid()] = p;
      p2 = C;
    } while (p != p2);
    v = *p;
    *x = v+1;
  } while ((*$\langle$*)CAS(&C, p, x)(*$\rangle_{\textsf{Inc}}$*));
  P[tid()] = null;
  retire(p);
  return v;
}

void retire(int* p) {  
  set[tid()].add(p);
  if (set[tid()].size() <= LSIZE) {
    return;
  }
  Liberate(set[tid()]);
  Set ret = set[tid()]; 
  set[tid()] = new Set();
  return ret;
}

Liberate(set *vs) {  
  for (int i = 0; i < MG; i++) {  
    int a = 0;
    entry <f = F[i]>;
    value v = POST[i];
    //if (v != null && vs.search(v)) 
    if (v == null || !vs.search(v)) {
      if (f.val != null && f.val != v) 
      if (CAS(&F[i], f, <null, h.ver+1>)) 
        vs.insert(h.val);
    } else {
      // (v != null && vs.search(v))       
      if (dCAS(&F[i],h, <v, f.ver+1>)) { 
        vs.delete(v);
        if (f.val != null) 
          vs.insert(f.val);
      } else { // a=1;
        entry <f1 = HANDOFF[i]>;
        if (v == POST[i]) {
          if (dCAS(&F[i], f1, <v, f1.ver+1>)) { 
            vs.delete(v);
            if (f1.val != null) 
              vs.insert(f1.val);
          } else { // a = 2
            entry <f2 = F[i]>;
            if (f2.val == null && v == POST[i]) {
              if (dCAS(&F[i], f2, <v, f2.ver+1>)) { 
                vs.delete(v);
                if (f2.val != null) 
                  vs.insert(f2.val);
  } } } } } } }

  return vs;
}

\end{lstlisting}
}

\subsection{To think}

\begin{itemize}
\item
Decomposition (non-relational and relational versions)
\item
Implementations of RCU, RCU over epochs and vice versa
\item 
Liveness
\item
Prophecy variables and PODC inside the same logic
\item
Automate it? (Need to figure out which since clauses to keep)
\item
Garbage collection
\item
Relativistic programming
\end{itemize}


Presentation:
\begin{itemize}
\item remove \texttt{P[tid()] = null;}?
\item replace array-based implementation of a set with an abstract set. 
\end{itemize}

For visionaries:
\begin{itemize}
\item
Aspects (Conjunction rule + refienment)
\item 
Cogability
\item
Coq: Theorem proving to show the theorems/tautologies are indeed valid
\end{itemize}


Deep philosophical insights:
\begin{itemize}
\item
Software disentangling
\item
Evocative, but incoherent (R. Bornat)
\item
Thinking doesn't scale
\item
Carpet publishing
\end{itemize}


\appendix 

\subsection{ROP code - Original}

{\small
\begin{lstlisting}[style=nonumbers,language=C,escapeinside={(*}{*)}]
int *C = new int(0);

Set *set[NTHREADS] = {new Set(), ..., new Set()};
typedef struct { value val; int ver } entry;
const int MG = NTHREADS;
bool GUARDS[MG] = {false}; 
value POST[MG] = {0};  
entry HANDOFF[MG] = {<null,0>}; 
int MAXG = 0;  // say it is volotile

int inc() {
  int *p, *p2, *x = new int;
  int g = HireGuard();
  int v;
  do {
    do {
      p = C;
      PostGuard(g,p);
      p2 = C;
    } while (p != p2);
    v = *p;
    *x = v+1;
  } while ((*$\langle$*)CAS(&C, p, x)(*$\rangle_{\textsf{Inc}}$*));
  FireGuard(g);
  retire(p);
  return v;
}

void retire(int* p) {  
  set[tid()].add(p);
  if (set[tid()].size() <= LSIZE) {
    return;
  }
  Set ret = Liberate(set[tid()]);
  set[tid()] = new Set();
  return ret;
}



int HireGuard() {
  int i=0,max;
  while (!CAS(&GUARDS[i],false,true))
    i++;
  while ((max = MAXG) < i)
    CAS(&MAXG,max,i); 
  return i;
}

void FireGuard(int i) {
  GUARDS[i] = false
}


void PostGuard(int i, value v) {
  POST[i] = v
}

value set Liberate(value set vs) {  
  int i=0;
  while (i <= MAXG) {
    int attempts = 0;
    entry h = HANDOFF[i];
    value v = POST[i];
    if (v != null && vs.search(v)) { 
      while (true) {
        if (CAS(&HANDOFF[i],h, <v, h.ver+1>)) { 
          vs.delete(v);
          if (h.val != null) vs.insert(h.val);
          break;
        }
        attempts++;
        if (attempts == 3) break;  
        h = HANDOFF[i];
        if (attempts == 2 && h.val != null) break;
        if (v != POST[i]) break;
      }
    } else {
      if (h.val != null && h.val != v) 
      if (CAS(&HANDOFF[i], h, <null, h.ver+1>)) 
      vs.insert(h.val);
    }
    i++;
  }
  return vs;
}

\end{lstlisting}
}



