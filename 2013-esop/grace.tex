%!TEX root = ./recycling.tex

\section{Logic Instantiation and Hazard Pointers}\label{sec:grace}

As explained in \S\ref{sec:informal}, proofs of algorithms based on grace
periods, use only a restricted form of temporal reasoning. In this section, we
describe an instantiation of the abstract logic of \S\ref{sec:logic} tailored to
such algorithms. 
This includes a particular form of the temporal invariant
(\S\ref{sec:hp:actions}) and a specialised version of the {\sc Shared} rule
(\textsc{Shared-I} below) that allows us to establish that the {\em temporal}
invariant is preserved using standard {\em state-based} reasoning.
We present the instantiation by the example of verifying the concurrent counter
algorithm with hazard pointers from \S\ref{sec:informal}.

\subsection{Assertion Language \label{sec:perm}}

\paragraph{Permissions.} We instantiate $\State$ to
\mbox{$
\RAM_\se
= \mathbb{N} \rightharpoonup_{\it fin} ((\mathbb{Z} \times \{1, \sm\}) \cup \{\se \}).
$}
A state thus consists of a finite partial function from
memory locations allocated in the heap to the values they store and/or permissions.
The permission $1$ is a
\emph{full} permission, which allows a thread to perform any action on
the cell; the permission $\sm$ is a \emph{master} permission, which allows
reading and writing the cell, but not deallocating it; and $\se$ is an {\em
  existential} permission, which only allows reading the cell and does not give
any guarantees regarding its contents. The transformers $f_\alpha^t$ 
over $\RAM_{\se}$ are given in~\tr{\ref{app:formal}}{\nformal}.


We define $*$ on cell contents as follows: $(u, \sm) * \se = (u, 1)$; undefined
in all other cases. This only allows a full permission to be split into a master
and an existential one, which is enough for our purposes.  For $\theta_1,
\theta_2 \in \RAM_\se$, $\theta_1*\theta_2$ is undefined, if for some $x$,
we have $\theta_1(x)\fdef$, $\theta_2(x)\fdef$, but
$(\theta_1(x)*\theta_2(x))\fundef$. Otherwise,
$$
\theta_1*\theta_2 \,{=}\, \{(x, w) \mid
(\theta_1(x) \,{=}\, w \wedge {\theta_2(x)\fundef})
\vee
(\theta_2(x) \,{=}\, w \wedge {\theta_1(x)\fundef})
\vee (w \,{=}\, \theta_1(x) * \theta_2(x))\}.
$$

\paragraph{State assertions.}
To denote elements of $\RAM_{\se}$, we extend the assertion language for
predicates over states given in \S\ref{sec:asslang}: $p \ ::=\ \ldots \mid E
\mapsto F \mid E \mapsto_{\sm} F \mid E \mapsto_{\se} \_$, where $E, F$ range
over expressions over integer-valued logical variables. The semantics is as
expected; e.g., $[\db{E}_{\intp} : (\db{F}_{\intp}, 1)],\intp \models E \mapsto F$
and $x \mapsto u \Leftrightarrow x \mapsto_\sm u * x \mapsto_\se \_$.

% $$
% \begin{array}{lcl}
% \theta,\intp \models E \mapsto F 
% & 
% \iff 
% & 
% \theta = [\db{E}_{\intp} : (\db{F}_{\intp},1)];
% \\
% \theta,\intp \models E \mapsto_{\sm} F
% &
% \iff 
% & 
% \theta = [\db{E}_{\intp} : (\db{F}_{\intp},\sm)];
% \\
% \theta,\intp \models E \mapsto_{\se} F 
% & 
% \iff
% & 
% \theta = {[}\db{E}_{\intp} : (\db{F}_{\intp},\se)].
% \end{array}
% $$


\paragraph{Conventions.}
We assume that logical variables $t, t', \ldots$ range over
thread identifiers in $\{1, \ldots, \nthreads\}$. We write ${\tt A}[k]$ for
${\tt A}+k$, and $\true_\se$ for $\exists A.\,\bigast\nolimits_{x \in
  A}x\mapsto_{\se}\_$, where $\bigast$ is the iterated version of $*$. We adopt
the convention that global variables are constants, and local variables are
allocated at fixed addresses in memory.  For a local variable {\tt var} of
thread $\ltid$, we write $\mathit{var} \Vdash P$ for $\exists \mathit{var}.\,
(\&{\tt var}+\ltid-1) \mapsto \mathit{var} * P$, where $\&\mathtt{var}$ is the address
of the variable. Note that here {\tt var} is a program variable, whereas ${\it
  var}$ is a logical one. We use a similar notation for lists of variables $V$.



\subsection{Actions and the Temporal Invariant \label{sec:hp:actions}}

The actions used in the proof of the running example and the rely/guarantee
conditions constructed from them are given in Figure~\ref{fig:HazardRG}.
\textsf{Id} allows reading the contents of the shared state, but not modifying
it, and \textsf{HP}$_\ltid$ allows modifying the contents of the $t$-th
entry in the hazard
pointer array. The rely $R_\ltid$ and the guarantee $G_\ltid$ are set up in such a way
that only thread $\ltid$ can execute \textsf{HP}$_\ltid$.

\textsf{Inc} allows a thread to change the node pointed to by $\cc$ from $x$ to
$y$, thus detaching the old node $x$. Note that $y \mapsto \_$ occurs on the
right-hand side of \textsf{Inc}, but not on its left-hand side. Hence, the
thread executing the action transfers the ownership of the node $y$ (in our
example, initially allocated in its local state) into the shared state. Since $x
\mapsto \_$ occurs on the left-hand side of \textsf{Inc}, but only $x
\mapsto_\se \_$ occurs on its right-hand side, the thread gets the ownership of 
$x \mapsto_\sm \_$. This is used to express the protocol that the thread 
detaching the node will be the one to deallocate it. Namely,
\textsf{Take} allows a thread to take the remaining existential
permission from the shared state only when it has the corresponding master
permission in its local state. The existential permission left in the shared
state after a thread executes \textsf{Inc} lets concurrently running threads 
access the detached node until it is deallocated.


% Note, however, that \textsf{Write} allows a thread that has the master
% permission of a cell to change the cell contents without any restrictions.

% \nr{Add action \textsf{Write} which allows to modify a cell in the shared using
%   the master permission }

\begin{figure}[t]
{\small
\begin{align*}
& \qquad \qquad X \leadsto X \qquad (\textsf{Id})
\qquad\qquad\quad
x \mapsto_\sm \_ \ \mid\ x \mapsto_\se \_ * X \leadsto\ X \quad\ (\textsf{Take})
\\[1pt]
&\qquad \qquad 
\HP[\ltid {-} 1] \mapsto \_ * X \leadsto \HP[\ltid {-} 1] \mapsto \_ * X 
\qquad\qquad\qquad\qquad
(\textsf{HP}_\ltid)
\\[1pt]
&\qquad \qquad 
 \cc \mapsto x * x \mapsto \_ * X  \leadsto \cc \mapsto y * y \mapsto \_ * x \mapsto_\se \_ * X
\qquad \quad \ \ \ \, (\textsf{Inc})
\\[2pt]
&
\qquad G_\ltid = \{\textsf{HP}_\ltid, \textsf{Inc}, \textsf{Take}, \textsf{Id}\}; 
\qquad \qquad
R_\ltid = \bigcup \{G_k \mid {1 \le k \le \nthreads} \wedge {k \not= \ltid}\}
\\[2pt]
&
\Upsilon_{\textsf{HP}} \iff  
\forall x, t.\, ((\shareds{\HP[t - 1] \mapsto x * \true} 
\since {}
\shareds{\cc \mapsto x * x \mapsto \_ * \true}) \Rightarrow 
\shareds{x \mapsto_\se \_* \true})
\end{align*}
}
\vspace{-15pt}
\caption{\label{fig:HazardRG}\small Rely/guarantee conditions and the temporal
  invariant used in the proof of the counter algorithm with hazard pointers}
\end{figure}

%Of course, it is unsafe for a thread to execute \textsf{Take} at an arbitrary
%point.

Threads can only execute {\sf Take} and other actions when these do not violate
the temporal invariant $\Upsilon_{\sf HP}$ in Figure~\ref{fig:HazardRG}.
Temporal invariants used for proofs of algorithms based on grace periods are of
the form ``$\forall x, t.\, (\shareds{g} \since \shareds{r}) \Rightarrow
\shareds{c}$'', where
%  Here $I$ describes the shape of the shared data structure, 
``$\shareds{g} \since \shareds{r}$'' defines the duration of the grace period for
a thread $t$ and a location $x$, and $\shareds{c}$ gives the
property that has to be maintained during the grace period.  In
our example, the invariant formalises~(\ref{inf-inv}): if
a hazard pointer of $t$ has pointed to a node $x$ continuously since
$\cc$ pointed to $x$, then an existential permission for $x$ is present in the
shared state.

%This allows a thread inside the grace period specified by the ${\since}$ clause
%of $\Upsilon_{\textsf{HP}}$ to access $x$ safely.


\subsection{Proof Outlines and a Derived Rule for Grace Periods\label{sec:outlines}}


The proof outline for the running example is shown in
Figures~\ref{fig:Hazard:Inc} and~\ref{fig:Retire}.
In the figure, we write $\texttt{CAS}_{a, b}\texttt{(addr,v1,v2)}$ as a shorthand for the following,
where the {\sf assume} command ``assumes'' its parameter to be non-zero
\tra{\ref{app:formal}}{\nformal}:
%  \longonly{(This also  allows different annotations for CAS success or failure.)}
\begin{flushleft}
\small
\begin{lstlisting}[language=C,escapeinside={/*}{*/}]
  if (nondet()) {/*$\langle$*/assume(*addr == v1); *addr = v2/*$\rangle_{a}$*/; return 1; } 
  else { /*$\langle$*/assume(*addr != v1)/*$\rangle_{b}$*/; return 0; }
\end{lstlisting}
\end{flushleft}

The bulk of the proof employs standard state-based reasoning of the kind
performed in RGSep~\cite{rgsep}. Temporal reasoning
is needed, e.g., to check that every command changing the
shared state preserves the temporal invariant $\Upsilon_{\sf HP}$ (the premiss
$Q \Rightarrow \Upsilon$ in \textsc{Shared-R}).  We start by discussing the
proof outline of {\tt inc} in Figure~\ref{fig:Hazard:Inc} in general terms; we
then describe the handling of commands changing the shared state in detail. 
%\begin{wrapfigure}{r}{0.5\textwidth}

\begin{figure}[t]
\begin{center}
\begin{tabular}{@{\hspace{-37pt}}l@{\quad}|@{\qquad}l@{}}
{\figfontsize
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
int *C = new int(0), *HP[N] = {0}; 
Set detached[N] = {(*$\emptyset$*)};
int inc() {
  int v, *n, *s, *s2; 
  (*$\{V \Vdash F_{\ltid} \land I\}$ \label{pc:Hazard:Inc:stateinv}*) 
  n = new int; 
  do { 
    (*$\{V \Vdash n \mapsto \_ *  F_{\ltid} \land I\}$*)
    do { 
      (*$\{V \Vdash  n \mapsto \_ *  F_{\ltid} \land I\}$*)
      (*$\langle$*)s = C(*$\rangle_{\sf
        Id}  \label{pc:Hazard:Inc:readp} $*); 
      (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I\}$*)  
      (*$\langle$*)HP[tid-1] = s(*$\rangle_{\textsf{HP}_\ltid} \label{pc:Hazard:Inc:sethp}$*); 
      (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land {}$*)
      (*$\ph\shareds{\HP[\ltid-1] \mapsto s * \true}\}$*) 
      (*$\langle$*)s2 = C(*$\rangle_{\sf Id}$\label{pc:Hazard:Inc:readpp}*);
      (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land{}$*)
\end{lstlisting}}
&
{\figfontsize
\begin{lstlisting}[firstnumber=18,numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
      (*$\ph(\shareds{\HP[\ltid-1] \mapsto s * \true}$*)
      (*$\ph\since \shareds{\cc \mapsto {\it s2} * {\it s2} \mapsto \_ * \true})\}$*)
    } while (s != s2); (*\label{pc:Hazard:Inc:test}*)
    (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land \shareds{s \mapsto_\se
      \_ * \true} \land {}$*)
    (*$\ph (\shareds{\HP[\ltid-1] \mapsto s * \true} $*)
    (*$\ph\since \shareds{\cc \mapsto s * s \mapsto \_ * \true})\}$\label{pc:Hazard:Inc:Deref}*)
    (*$\langle$*)v = *s(*$\rangle_{\sf Id}$*); (*\label{pc:Hazard:Inc:access}*)
    *n = v+1;
    (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land \shareds{s \mapsto_\se
      \_ * \true} \land {}$\label{before-cas} *) 
    (*$\ph(\shareds{\HP[\ltid-1] \mapsto s * \true}$*)
    (*$\ph\since \shareds{\cc \mapsto s * s \mapsto \_ * \true})\}$*)
  } while (!CAS(*$_{\textsf{Inc}, \textsf{Id}}$*)(&C, s, n)(*\label{pc:Hazard:Inc:CAS}*));
  (*$\{V \Vdash s \mapsto_\sm \_ * F_{\ltid} \land I \land \shareds{s \mapsto_\se \_ * \true}\}$\label{after-cas}*)
  reclaim(s); 
  (*$\{V \Vdash F_{\ltid} \wedge I\}$*)   
  return v; }
\end{lstlisting}
}
\end{tabular}
\end{center}
\vspace{-7pt}
\caption{\label{fig:Hazard:Inc} \small Proof outline for {\tt inc} with hazard pointers.  Here $V$ is $v$, $n$, $s$, ${\it s2}$, ${\it my}$, ${\it in\_use}$, $i$.}
%\end{wrapfigure}
\end{figure}

%\begin{figure}[t]
%{\small
%\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
%int *C = new int(0), *HP[N] = {0}; Set detached[N] = {(*$\emptyset$*)};
%int inc() {
%  int v, *n, *s, *s2;
%  (*$\{ V \Vdash F_{\ltid} \land I \}$ \label{pc:Hazard:Inc:stateinv}*) 
%  n = new int; 
%  do {
%    (*$\{V \Vdash n \mapsto \_ *  F_{\ltid} \land I\}$*)
%    do {
%      (*$\{V \Vdash  n \mapsto \_ *  F_{\ltid} \land I \}$*)
%      (*$\langle$*)s = C(*$\rangle_{\sf Id}  \label{pc:Hazard:Inc:readp} \label{pc:Hazard:Inc:readp}$*);
%      (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land 
%               I\}$*)  
%      (*$\langle$*)HP[tid-1] = s(*$\rangle_{\textsf{HP}_\ltid} \label{pc:Hazard:Inc:sethp}$*);
%      (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land \shareds{\HP[\ltid-1] \mapsto s * \true} \}$*) 
%      (*$\langle$*)s2 = C(*$\rangle_{\sf Id} \label{pc:Hazard:Inc:readpp}$*);
%      (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land {}$*)             
%      (*$\ph (\shareds{\HP[\ltid-1] \mapsto s * \true} \since \shareds{\cc
%        \mapsto {\it s2} * {\it s2} \mapsto \_ * \true})\}$*)
%    } while (s != s2); (*\label{pc:Hazard:Inc:test}*)
%    (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land \shareds{s \mapsto_\se
%      \_ * \true} \land {}$*)
%    (*$\ph (\shareds{\HP[\ltid-1] \mapsto s * \true} \since \shareds{\cc \mapsto
%      s * s \mapsto \_ * \true})$ \label{pc:Hazard:Inc:Deref}*)
%    (*$\langle$*)v = *s(*$\rangle_{\sf Id}$*); (*\label{pc:Hazard:Inc:access}*)
%    *n = v+1;
%    (*$\{V \Vdash n \mapsto \_ * F_{\ltid} \land I \land \shareds{s \mapsto_\se
%      \_ * \true} \land {} \label{before-cas}$*)
%    (*$\ph (\shareds{\HP[\ltid-1] \mapsto s * \true} \since \shareds{\cc \mapsto
%      s * s \mapsto \_ * \true}) $*) 
%  } while (!CAS(*$_{\textsf{Inc}, \textsf{Id}}$*)(&C, s, n)(*\label{pc:Hazard:Inc:CAS}*));
%  (*$\{V \Vdash s \mapsto_\sm \_ * F_{\ltid} \land I \land \shareds{s \mapsto_\se \_ * \true}
%\label{after-cas}\}$*)
%  reclaim(s);
%  (*$\{V \Vdash F_{\ltid} \wedge I\} $*)   
%  return v; }
%\end{lstlisting}
%}
%\caption{\label{fig:Hazard:Inc} Proof outline for {\tt inc} with hazard pointers.  Here
%$V$ is $v$, $n$, $s$, ${\it s2}$, ${\it my}$, ${\it in\_use}$, $i$.}
%\end{figure}

\paragraph{Verifying {\tt inc}.} Let $H \Leftrightarrow
(\bigast\nolimits_{t} \HP[t-1] \mapsto \_)$ and $I \Leftrightarrow \shareds{H *
  \exists y.\, \cc \mapsto y * y \mapsto \_ * \true_\se}$.  The pre- and
postcondition of \texttt{inc} in Figure~\ref{fig:Hazard:Inc} thus state that
the shared state always contains the hazard pointer array, the pointer at the
address $\cc$ and the node it identifies. Additionally, we can have an arbitrary
number of existential permissions for nodes that threads leave in the shared
state in between executing \textsf{Inc} and \textsf{Take}. We also have an
assertion $F_{\ltid}$, defined later, which describes the thread-local {\tt
  detached} set.

At line~\ref{pc:Hazard:Inc:readp} of {\tt inc}, the current thread reads the
value of $\cc$ into the local variable \texttt{s}. For the postcondition of this
command to be stable, we do not maintain any correlation between the values of
$\cc$ and \texttt{s}, as other threads might change $\cc$ using \textsf{Inc} at
any time. The thread sets its hazard pointer to {\tt s} at
line~\ref{pc:Hazard:Inc:sethp}. The postcondition includes $\shareds{\HP[\ltid-1]
  \mapsto s * \true}$, which is stable, as $R_{\ltid}$ and
$G_{\ltid}$ (Figure~\ref{fig:HazardRG}) allow only the current thread to execute
${\sf HP}_{\ltid}$.


At line~\ref{pc:Hazard:Inc:readpp}, the thread reads the value of $\cc$ into
{\tt s2}. Right after executing the command, we have $\shareds{\HP[\ltid-1]
  \mapsto s * \true} \wedge \shareds{\cc \mapsto {\it s2} * {\it s2} \mapsto \_
  * \true}$. This assertion is unstable, as other threads may change $\cc$ at
any time using {\sf Inc}. We therefore weaken it to the postcondition shown by
using the tautology $(\eta \wedge \mu) \Rightarrow (\eta \since \mu)$. It is easy to check
that an assertion $(\eta \since \mu)$ is stable if $\eta$ is. Since
$\shareds{\HP[\ltid-1] \mapsto s * \true}$ is stable, so is the postcondition of
the command in line~\ref{pc:Hazard:Inc:readpp}.  After the test \verb|s != s2|
in line~\ref{pc:Hazard:Inc:test} fails, the {\sf since} clause in this assertion
characterises the grace period of the thread $\ltid$ for the location {\tt s}, as
stated by $\Upsilon_{\sf HP}$. This allows us to exploit
$\Upsilon_{\sf HP}$ at line~\ref{pc:Hazard:Inc:Deref} using \textsc{Conseq},
establishing $\shareds{s \mapsto_\se \_ * \true}$. 
% The resulting assertion is stable due to the following fact: if a temporal
% invariant $\Upsilon$ implies $(\eta \since \mu) \Rightarrow \lambda$ and $\eta
% \since \mu$ is stable, then so is $\lambda$. This is the case because
% in~(\ref{stab}), the history $\xi\theta_s\theta'_s$ of the shared state after an
% environment transition has to satisfy $\Upsilon$.
This assertion allows us to access the node at the address $s$ safely at
line~\ref{pc:Hazard:Inc:access}.

If the CAS in line~\ref{pc:Hazard:Inc:CAS} is successful, then the thread
transfers the ownership of the newly allocated node {\tt n} to the shared state,
and takes the ownership of the master permission for the node $s$; the
existential permission for $s$ stays in the shared state. The resulting
assertion $s \mapsto_\sm \_ \wedge \shareds{s \mapsto_\se \_ * \true}$ is stable,
because the only action that can remove $s \mapsto_\se \_$ from the shared
state, {\sf Take}, is guarded by $s \mapsto_\sm \_$. Since the current thread
has the ownership of $s \mapsto_\sm \_$ and $s \mapsto_\sm \_ * s \mapsto_\sm
\_$ is inconsistent, the condition $(\theta*\theta_l*\theta_s)\fdef$
in~(\ref{stab}), checking that the guard is consistent with the local state,
implies that the action cannot be executed by the environment, and thus, the
assertion is stable.

\paragraph{Derived rule for grace periods.} 
To check that the commands in lines~\ref{pc:Hazard:Inc:sethp}
and~\ref{pc:Hazard:Inc:CAS} of {\tt inc} preserve 
 $\Upsilon_{\sf HP}$, we use the following rule
 \textsc{Shared-I}, derived from \textsc{Shared} \tra{\ref{app:formal}}{\nformal}:
%\vspace{-3pt}
$$
\small
\infer{
\begin{array}{@{}l@{}}
\emptyset,G,\true \vdash_\ltid 
\{p \land \shareds{p_s} \land 
((\shareds{g} \since \shareds{r}) \Rightarrow \shareds{c})\} 
%\\[2pt]
%\qquad \qquad \qquad \qquad \qquad\ 
\langle C \rangle_a\,    \{ q  \land \shareds{q_s} \land 
((\shareds{g} \since \shareds{r}) \Rightarrow \shareds{c}) \}
\end{array}
}{
\begin{array}{@{}l@{}}
p \Rightarrow l * \true
\qquad
a = (l \mid p'_s \leadsto q'_s) \in G 
\qquad
p_s \Rightarrow p_s'
\qquad
q_s \Rightarrow q_s'
\\[2pt]
\emptyset,\emptyset,\true \vdash_\ltid 
\{ p * (p_s \land  \neg (g \land r)) \} 
\, C \,
\{ q * (q_s \land  (g \land r \Rightarrow c)) \}
\\[2pt]
\emptyset,\emptyset,\true \vdash_\ltid 
\{ p * (p_s  \land  g \land c) \} 
\, C\,
\{ q * (q_s \land  (g \Rightarrow c)) \}
\end{array}
}
%\vspace{-3pt}%
$$
This gives conditions under which $\langle C\rangle$ preserves the
validity of an assertion of the form
\be\label{form}
(\shareds{g} \since \shareds{r}) \Rightarrow \shareds{c}
\ee
and thus allows us to prove the preservation of a temporal invariant
of the form~(\ref{form}) using standard Hoare-style reasoning.
In the rule, $p_s$ describes the view of the shared
partition that the current thread has before executing $C$, and $q_s$, the state
in which $C$ leaves it. The rule requires that the change from $p_s$ to $q_s$
be allowed by the annotation $a = (l \mid p'_s
\leadsto q'_s)$, i.e., that $p_s \Rightarrow p'_s$ and $q_s \Rightarrow
q'_s$. It further provides two Hoare triples to be checked of $C$, which
correspond, respectively, to the two cases for why $(\shareds{g} \since
\shareds{r}) \Rightarrow \shareds{c}$ may hold before the execution of $C$:
$\neg(\shareds{g} \since \shareds{r})$ or $(\shareds{g} \since \shareds{r})
\wedge \shareds{c}$.

As in {\sc Shared}, the two Hoare triples in the premiss allow the command
inside the atomic block to access both local and shared state. Consider the
first one.  We can assume $\neg(g \wedge r)$ in the precondition, as it is
implied by $\neg(\shareds{g} \since \shareds{r})$. Since $\shareds{g} \since
\shareds{r}$ does not hold before the execution of $C$, the only way to
establish it afterwards is by obtaining $g \wedge r$. In this case, to
preserve~(\ref{form}), we have to establish $c$, which motivates the
postcondition. Formally: $
((\neg(\shareds{g} \since \shareds{r})) \extend 
\shareds{g \wedge r \Rightarrow c}) \Rightarrow 
((\shareds{g} \since \shareds{r}) \Rightarrow \shareds{c})
$.

Consider now the second Hoare triple. Its
precondition comes from the tautology $((\shareds{g} \since \shareds{r}) \wedge
\shareds{c}) \Rightarrow \shareds{g \wedge c}$. We only need to establish $c$ in
the postcondition when $\shareds{g} \since \shareds{r}$ holds there, which
will only be the case if $g$ continues to hold after $C$ executes:
$
(((\shareds{g} \since \shareds{r}) \wedge \shareds{c}) \extend 
\shareds{g \Rightarrow c}) \Rightarrow 
((\shareds{g} \since \shareds{r}) \Rightarrow \shareds{c})
$.

\paragraph{Preserving the temporal invariant.} We illustrate the use of
\textsc{Shared-I} on the command in line~\ref{pc:Hazard:Inc:CAS} of
Figure~\ref{fig:Hazard:Inc}; the one in line~\ref{pc:Hazard:Inc:sethp} is
handled analogously. We consider the case when the CAS succeeds, i.e., $C$
is \verb|{assume(C == s); C = n;}|.
Let $P$ and $Q$ be the pre- and postconditions of this command in
lines~\ref{before-cas} and~\ref{after-cas}, respectively. We thus need to prove
$R_\ltid, G_\ltid, \Upsilon \vdash_{\ltid} \{P\}\, \langle C \rangle_{\sf Inc}\, \{Q\}$.
We first apply \textsc{Conseq} to strengthen the precondition of the CAS with
$\Upsilon$, and then apply \textsc{Shared-R}. This rule,
in particular, requires us to show that the temporal invariant is preserved:
$\emptyset, G_\ltid, \true \vdash_{\ltid} 
\{P \wedge \Upsilon\} \ C\ \{Q \wedge \Upsilon\}$.
Let us first strip the quantifiers over $x$ and $t$ in $\Upsilon$ using
a standard rule of Hoare logic. We then apply \textsc{Shared-I} with
%\vspace{-3pt}
$$
\small
\begin{array}{@{}l@{\qquad \qquad \qquad\ \ }l@{}}
\multicolumn{2}{@{}l@{}}{
g = (\HP[t{-}1] \mapsto x * \true); 
\quad\;\,
r = (\cc \mapsto x * x \mapsto \_ * \true);
\quad\;\,
c = (x \mapsto_\se \_* \true)
};
\\
p_s = (H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true_\se);
&
p = n \mapsto \_;
\\
q_s = (H * \exists y.\, \cc \mapsto y * y \mapsto \_ * s \mapsto_\se \_ *
\true_\se);
&
q = s \mapsto_\sm \_.
\end{array}
%\vspace{-3pt}
$$
We consider only the first Hoare triple in the premiss of \textsc{Shared-I},
which corresponds to $\shareds{g} \since \shareds{r}$ being false before the
atomic block. The triple instantiates to
%\vspace{-3pt}
$$
\small
\begin{array}{@{}c@{}}
\{n \,{\mapsto}\, \_ \,{*}\, ((H \,{*}\, \exists y.\, \cc \,{\mapsto}\, y \,{*}\, y \,{\mapsto}\, \_ \,{*}\, \true_\se)
\wedge
\neg(\HP[t - 1] \,{\mapsto}\, x \,{*}\, \true \wedge \cc \,{\mapsto}\, x \,{*}\, x \,{\mapsto}\, \_ \,{*}\, \true))\}\\
\verb|assume(C == s); C = n;|\
\{s \mapsto_\sm \_ * 
(H * \exists y.\, \cc \mapsto y * y \mapsto \_ * s \mapsto_\se \_ * \true_\se) 
\wedge{}\\
\qquad\qquad\qquad\qquad\ 
\ph (((\HP[t {-} 1] \mapsto x \,{*}\, \true) \,{\wedge}\, (\cc \mapsto x \,{*}\, x \mapsto \_ \,{*}\, \true))
\,{\Rightarrow}\,  (x \mapsto_\se \_ \,{*}\, \true))\}
\end{array}
%\vspace{-3pt}
$$
Recall that when the CAS at line~\ref{pc:Hazard:Inc:CAS} inserts a node into the
shared data structure, we already might have a hazard pointer set to the
node (\S\ref{sec:informal}). The postcondition of the above triple states that,
in this case, we need to establish the conclusion of the temporal
invariant. This is satisfied, as $x \mapsto \_ \Leftrightarrow x \mapsto_\sm \_
* x \mapsto_\se \_$. 


% There is, however, a subtlety associated with this case: when the thread
% performs the CAS to insert the element $n$ into the shared data structure, we
% might already have a hazard pointer pointing to $n$! This situation may arise in
% the following scenario: a thread $\ltid_1$ reads $\cc$, which points to $n$; a
% thread $\ltid_2$ detaches $n$ from the shared state, finds out that none of the
% hazard pointers are equal to $n$ and thus deallocates it; thread $\ltid_1$ wakes up
% and sets its hazard pointer to $n$; a thread $\ltid_3$ allocates $n$ and inserts it
% into the shared data structure, while the hazard pointer of $\ltid_1$ points to $n$.
% In this case, $\Upsilon_{\sf HP}$ still holds, as the shared state has a full
% permission for $n$.

% The second Hoare triple in the premisses of \textsc{Shared-I} instantiates to
% $$
% \begin{array}{@{}l@{}}
% \{n \mapsto \_ * ((H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true_\se)
% \wedge {}\\
% \ph (\HP[t - 1] \mapsto x * \true) \wedge (x \mapsto_\se \_ * \true))\}\\
% \verb|assume(C == p); C = n;|\\
% \{p \mapsto_\sm \_ * 
% (H * \exists y.\, \cc \mapsto y * y \mapsto \_ * p \mapsto_\se \_ * \true_\se) 
% \wedge{}\\
% \ph (\HP[t - 1] \mapsto x * \true) \Rightarrow (x \mapsto_\se \_ * \true)\}
% \end{array}
% $$
% which is easy to check: $x \mapsto_\se \_$ in the precondition allows us to
% establish the implication in the postcondition.


\begin{figure}[t]
\begin{tabular}{@{\quad\ }l@{}}
{\figfontsize
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
void reclaim(int *s) {  (*$\{V \Vdash s \mapsto_\sm \_ * F_{\ltid}  \land \shareds{s \mapsto_\se \_ * \true} \land I\}$\label{pc:Retire:Pre}*) 
  insert(detached[tid-1], s); (*\label{pc:Retire:insert}*)
  if (nondet()) return;
  Set in_use = (*$\emptyset$*);
  while (!isEmpty(detached[tid-1])) {
    (*$\{V \Vdash \exists A.\,\rlist[\ltid-1] \mapsto A * \detached(A) * \detached(\tmplist) \land A \neq \emptyset  \land I\}$*) 
    bool my = true;
    Node *n = pop(detached[tid-1]); (*$\label{pc:Retire:pop}$*)
    (*$\{V \Vdash  \mathit{my} \land \exists A.\, \rlist[\ltid\,{-}\,1] \,{\mapsto}\, A * \detached(A) * \detached(\tmplist) *  n \,{\mapsto_\sm}\, \_ \land \shareds{n \,{\mapsto_\se}\, \_ * \true }  \land I\}$*)
    for (int i = 0; i < N && my; i++) {
      (*$\{V \Vdash \mathit{my} \land  \exists A.\, \rlist[\ltid\,{-}\,1] \mapsto A * \detached(A) * \detached(\tmplist) * n \mapsto_\sm \_ * \shareds{n \mapsto_\se \_ * \true } \,{\land} $*)
      (*$\ph 0 \leq i < \nthreads \land I \land \shareds{H * \exists y.\, y \neq n \land \cc \mapsto y * y \mapsto \_ * \true_\se} \land  \mbox{} $*)
      (*$\ph \forall 0 \leq j < i .\, (\shareds{\exists y.\, y \neq n \land \cc \mapsto y * y \mapsto \_ * \true_\se} {\since} \, \shareds{\exists x.\, x \neq n \land \HP[j] \mapsto x * \true})\}$ \label{pc:hazard:precheck}*)
      if ((*$\langle$*)HP[i] == n(*$\rangle_{\sf Id}$\label{pc:hazard:check}*)) my = false;
    }
    if (my) {
      (*$\{V \Vdash  \exists A.\, \rlist[\ltid-1] \mapsto A * \detached(A)  * \detached(\tmplist) * n \mapsto_\sm \_ \land \shareds{n \mapsto_\se \_ * \true }  \land I \land  \mbox{}$*)
      (*$\ph \forall t.\, \neg\,\shareds{\cc \mapsto n *  \true} \since \neg\,\shareds{\HP[t-1] \mapsto n * \true}\}$*)
      (*$\langle$ ; $\rangle_{\textsf{Take}}$ \label{pc:Retire:take}*) 
      (*$\{V \Vdash  \exists A.\, \rlist[\ltid-1] \mapsto A * \detached(A)  * \detached(\tmplist) * n \mapsto \_ \land I\}$*)
      free(n);
    } else { insert(in_use, n); }  
  } (*$\{V \Vdash  \rlist[\ltid-1] \mapsto \emptyset * \detached(\tmplist) \land I\}$*)   
  moveAll(in_use, detached[tid-1]); (*$\{V \Vdash F_{\ltid} \land I\}$*)
}
\end{lstlisting}
}
\end{tabular}
\caption{\label{fig:Retire}\small Proof outline for \texttt{reclaim} with hazard pointers.
$V$ is $v$, $n$, $s$, ${\it s2}$, ${\it my}$, ${\it in\_use}$, $i$.}
\end{figure}

\paragraph{Verifying {\tt reclaim}.}
We now explain the proof outline in Figure~\ref{fig:Retire}.  
The predicate
$F_\ltid$ describes the \texttt{detached} set of thread $\ltid$:
\be\label{ft-def}
\begin{array}{rcl}
\detached(A) 
& \iff &  
\bigast\nolimits_{x \in A} (x \mapsto_\sm \_ \wedge \shareds{x \mapsto_\se \_ * \true});
\\[1pt]
F_\ltid 
& \iff & 
\exists A.\, \rlist[\ltid-1] \mapsto A * \detached(A).
\end{array}
\ee
$F_\ltid$ asserts that thread $\ltid$ owns the $\ltid$-th entry of the \texttt{detached}
array, which stores the set $A$ of addresses of detached nodes;
$D(A)$ asserts that, for every $x \in A$, the thread has the master
permission for $x$ in its local state, and the shared state contains the
existential permission for $x$. The assertion $F_\ltid$ is stable, since, as we
explained above, so is $x \mapsto_\sm \_ \wedge \shareds{x \mapsto_\se \_ * \true}$.
We assume the expected specifications for set operations. %, such as {\tt insert}.

% For example:
% $$
% R, \emptyset, \Upsilon
% \vdash_\ltid
% \{ s \mapsto A \}\
% \verb|insert(s, p)|\
% \{ s \mapsto (A \cup \{p\}) \}
% $$


The core of \texttt{reclaim} is the loop following the \texttt{pop} operation in
line~\ref{pc:Retire:pop}, which checks that the hazard pointers do not point to
the node that we want to deallocate.  The assertion in
line~\ref{pc:hazard:precheck} formalises~(\ref{inf-neg}) and is established as
follows. If the condition on the pointer $\HP[i]$ in line~\ref{pc:hazard:check}
fails, then we know that $\shareds{\exists x.\, x \neq n \land \HP[i] \mapsto
  x * \true}$. Recall that, according to~(\ref{world}), \S\ref{sec:asslang}, the combination of the
local and the shared states has to be consistent. Then, since we have $n
\mapsto_\sm \_$ in our local state, we cannot have $\cc$ pointing to $n$: in
this case the full permission $n \mapsto \_$ would be in the shared state, and
$n \mapsto \_ * n \mapsto_\sm \_$ is inconsistent. Hence, $\shareds{\exists y.\,
  y \neq n \land \cc \mapsto y * y \mapsto \_ * \true}$. By the tautology $(\eta
\wedge \mu) \Rightarrow (\eta \since \mu)$, we obtain the desired assertion:
\be\label{neg-since}
\shareds{\exists y.\, y \neq n \land \cc \mapsto y * y \mapsto \_ * \true}
\since 
\shareds{\exists x.\, x \neq n \land \HP[i] \mapsto x * \true}.
\ee
%This states that $\cc$ has not pointed to $n$ since $\HP[i]$ did not point to
%it. Recall that $A \since B$ is stable when so is $A$. Thus, 
Since $n \mapsto_\sm \_\wedge \shareds{\exists y.\, y \neq n \land \cc \mapsto y * y
  \mapsto \_ * \true}$ is stable, so is the loop invariant.  At
line~\ref{pc:Retire:take}, we use~(\ref{neg-since}) and~(\ref{incons}) to show
that the existential permission for the node $n$ can be safely removed from the
shared state.
After this, we recombine it with the local master permission to obtain 
$n \mapsto \_$, which allows deallocating the node.

\paragraph{Absence of memory leaks.} According to Theorem~\ref{real:soundness},
the above proof establishes that the algorithm is memory safe. In fact, it also
implies that the algorithm does not leak memory. Indeed, let $\cp$ be the
program consisting of any number of {\tt inc} operations running in
parallel. From our proof, we get that $\cp$ satisfies the following triple:
$$
\small
\begin{array}{@{}l@{}}
\vdash
\{L * (\bigast\nolimits_{t} \rlist[t-1] \mapsto \emptyset) 
\wedge{}
\shareds{(\bigast\nolimits_{t}\HP[t-1] \mapsto 0) * 
\exists y.\, \cc \mapsto y * y \mapsto 0 }\}
\\[2pt]
\qquad\qquad\qquad\qquad\cp\
\{L * (\bigast\nolimits_{t} F_t) \wedge
\shareds{(\bigast\nolimits_{t} \HP[t-1] \mapsto \_) * \exists y.\,
  \cc \mapsto y * y \mapsto \_ * \true_\se}\},
\end{array}
$$
where $L$ includes the local variables of all threads. The assertion $\true_\se$
in the postcondition describes an arbitrary number of existential permissions
for memory cells. However, physical memory cells are denoted by full
permissions; an existential permission can correspond to one of these only when
the corresponding master permission is available. Every such master permission
comes from some $F_t$, and hence, the corresponding cell belongs to ${\tt
  detached}[t-1]$. Thus, at the end of the program, any allocated cell is
reachable from either $\cc$ or one of the {\tt detached} sets.

\paragraph{Extensions.} 
Even though we illustrated our proof technique using the idealistic example of a
counter, the technique is also applicable both to other algorithms based on
hazard pointers and to different ways of optimising hazard pointer
implementations. In \tr{\ref{sec:ProofsHazard}}{\nhazard}, we demonstrate this
on the example of a non-blocking stack with several optimisations of hazard
pointers used in practice~\cite{hazard}: e.g., the pointers are dynamically
allocated, \texttt{reclaim} scans the hazard list only once, and the {\tt
  detached} sets are represented by lists with links stored inside the detached
elements themselves. The required proof is not significantly more complex than
the one presented in this section.

%In \S\ref{sec:rcu} and \S\ref{sec:epoch} we also show that algorithms based on
%different notions of grace periods can also be proved using temporal invariants
%and of the form presented here and the {\sc Shared-I} rule.

In \tr{\ref{app:lin}}{\nlin}, we also present an adaptation of the above proof 
to establish the linearizability of the algorithm following the
approach in~\cite{rgsep} (we leave a formal integration of the two methods for
future work). The main challenge of proving linearizability of this and similar
algorithms lies in establishing that the ABA problem described in
\S\ref{sec:informal} does not occur, i.e., when the CAS in
line~\ref{pc:Hazard:Inc:CAS} of Figure~\ref{fig:Hazard:Inc} is successful, we
can be sure that the value of $\cc$ has not changed since we read it at
line~\ref{pc:Hazard:Inc:readpp}. In our proof this is easy to establish, as
between lines~\ref{pc:Hazard:Inc:readpp} and~\ref{pc:Hazard:Inc:CAS}, all
assertions are stable and contain $\shareds{s \mapsto_\se \_ * \true}$, which
guarantees that $s$ cannot be recycled.




%%% Local Variables:
%%% TeX-master: "recycling"
%%% mode: latex
%%% End:  
