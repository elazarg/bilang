%!TEX root = ./recycling.tex

\section{Additional Proofs of Hazard Pointer-based Algorithms}\label{sec:ProofsHazard}








%%%%
%  pop for stack.
%%%%

\begin{figure*}
\be
  X
  \leadsto
  X
  \tag{$\textsf{Id}$}
\ee
\be
\HP[t] \mapsto \_ * X
\ \leadsto \ 
\HP[t] \mapsto \_ * X
\tag{$\textsf{HP}_t$}
\ee
\be
\Top \mapsto x * X
\ \leadsto \
\Top \mapsto z * z \mapsto x,v * X
\tag{$\textsf{Push}$}
\ee
\be
\Top \mapsto x * x \mapsto y,v * X
 \leadsto \ 
\Top \mapsto y * x \mapsto_\se y,v * X
\tag{$\textsf{Pop}$}
\ee
\be
x \mapsto_\sm \_,\_ \ \mid\ 
x \mapsto_\se \_,\_ * X
\ \leadsto\ 
X
\tag{$\textsf{Take}$}
\ee
\be
x \mapsto_\sm \_,\_ \ \mid\ 
x \mapsto_\se \_,\_ * X
\ \leadsto\ 
x \mapsto_\se \_,\_ * X
\tag{$\textsf{Write}$}
\ee
$$
G_t = \{\textsf{HP}_t, \textsf{Push}, \textsf{Pop}, \textsf{Take}, \textsf{Id}\}; \quad
R_t = \bigcup\nolimits_{t \not= t'} G_{t'}
$$
\caption{\label{fig:HazardStackRG}The actions and rely/guarantee conditions used in
  the proof of the stack algorithm with hazard pointers}
\end{figure*}


\begin{figure*}
\[
\begin{array}{rcl}
  \Node(x)
  & \iff &
  x \mapsto \_,\_
  \\[2pt]
  x \mapsto_{p} a,b
  & \iff & 
  x\mapsto_{p}a * x+1\mapsto_{p}b
  \qquad
  \text{where} ~p \in \{1,\se,\sm \}
  \\[2pt]
  \true_{\se\se}
  & \iff & 
  \emp \lor (\exists x.\, x\mapsto_{\se}\_,\_ * \true_{\se\se})
  \\[2pt]
  H 
  & \iff &
  \bigast\nolimits_{t=0}^{\nthreads} \HP[t] \mapsto \_      
  \\[2pt]
  \stack(x) 
  & \iff &
  (\emp \land x = 0) \lor (\exists y,v.\, x \mapsto y,v * \stack(y))
  \\[2pt]
  \Upsilon^s_{\textsf{HP}} 
  & \iff &   
  \shared{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land  
  \mbox{}
  \\[2pt]
  & & 
  \forall x, t.\, ((\shareds{\HP[t] \mapsto x * \true} 
  \since \shareds{\Top \mapsto x * x \mapsto \_ * \true}) \Rightarrow  
  \shareds{x \mapsto_\se \_,\_ * \true})
% \\[2pt]
% \abs(x) 
% & = & 
% \begin{cases}
% 	\epsilon & x = 0\\
%	a \abs(y) & x \mapsto y,a * \stack(y)
%  \end{cases}
\end{array}
\]
\caption{Assertions used in the proof of \texttt{pop()} in a stack with hazard pointers.}  
\label{fig:HazardStackAssn}
\end{figure*}



\begin{figure*}
{\small
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
Set detached[N] = (*$\{\emptyset\}$*);
typedef struct Node {
  struct Node *next;
  int val;
} Node;
Node *Top = null;
Node *HP[N] = {0};

(*$\{ F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \}$ \label{pc:Hazard:pop:pre}*) 
int pop() {
  int v;
  Node *x, *p, *p2;
  (*$\{ V \Vdash F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \}$ \label{pc:Hazard:pop:stateinv}*) 
  do {
    (*$\{V \Vdash F_{\tid} \land\shareds{H  * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}}\}$*)
    do {
      (*$\{V \Vdash  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}}\}$*)
      (*$\langle$*)p = Top(*$\rangle_{\sf Id}  \label{pc:Hazard:pop:readp} \label{pc:Hazard:pop:readp}$*); 
      (*$\{V \Vdash F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land (\shareds{\true} \since \shareds{\Top = p * \true})\}$*)  
      if (p == NULL)
        return EMPTY;         
      (*$\{V \Vdash p \neq 0 \land F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}}\}$*)  
      (*$\langle$*)HP[tid] = p(*$\rangle_{\textsf{HP}_t} \label{pc:Hazard:pop:sethp}$*);
      (*$\{V \Vdash p \neq 0 \land  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land \shareds{\HP[\tid] \mapsto p * \true} \}$*) 
      (*$\langle$*)p2 = Top(*$\rangle_{\sf Id} \label{pc:Hazard:pop:readpp}$*);
      (*$\{V \Vdash p \neq 0 \land  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land 
          (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto {\it p2}  * \stack(\mathit{p2}) * \true_{\se\se}})\}$*)
    } while (p != p2); (*\label{pc:Hazard:pop:test}*)
    (*$\{V \Vdash p \neq 0 \land  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land 
        (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * \stack(p) * \true_{\se\se}})\}$*)
    (*$\{V \Vdash p \neq 0 \land  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land 
        (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * \exists y,w.\, p \mapsto y,w *  \stack(y) * \true_{\se\se}})\}$*)        
    (*$\{V \Vdash \exists x,w,x',w'.\,  p \neq 0 \land  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land \mbox{}$*)
    (*$ \qquad\qquad\qquad\qquad 
         (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * p \mapsto x,w *  \stack(x) * \true_{\se\se}}) \land  \mbox{} $*)
    (*$  \qquad\qquad\qquad\qquad 
          \shareds{p \mapsto_\se x',w' * \true \land (\Top = p \implies w = w' \land x = x')}  \}$*)       
    (*$\langle$*)n = p->next;(*$\rangle_{\sf Id}$*); (*\label{pc:Hazard:pop:access}*)
    (*$\{V \Vdash \exists x,w,x',w'.\,  p \neq 0 \land  F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land \mbox{}$*)
    (*$ \qquad\qquad\qquad\qquad 
         (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * p \mapsto x,w *  \stack(x) * \true_{\se\se}}) \land  \mbox{} $*)
    (*$  \qquad\qquad\qquad\qquad 
          \shareds{p \mapsto_\se x',w' * \true \land (\Top = p \implies n = x' \land w = w' \land x = x')}  \}$*)       
  } while (!CAS(*$_{\textsf{Pop}, \textsf{Id}}$*)(&Top, p, n)(*\label{pc:Hazard:pop:CAS}*));
  (*$\{V \Vdash\exists w.\,  p \mapsto_\sm n,w *   F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land \mbox{}$*)
    (*$ \qquad\qquad\qquad\qquad 
         (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * p \mapsto n,w *  \stack(n) * \true_{\se\se}}) \land \shareds{p \mapsto_\se n,w * \true } \land \mbox{} $*)
    (*$ \qquad\qquad\qquad\qquad 
           \shared{\true} \since (\shared{\Top \mapsto p  * p \mapsto n,w *  \stack(n) * \true_{\se\se}} \extend \shared{\Top \mapsto n *  \stack(n) * \true_{\se\se}}) 
          $*)          
  v = n->val;
  (*$\{V \Vdash p \mapsto_\sm n,v  *   F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land \mbox{}$*)
    (*$ \qquad\qquad\qquad\qquad 
         (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * p \mapsto n,v *  \stack(n) * \true_{\se\se}}) \land \shareds{p \mapsto_\se n,v * \true } \land \mbox{} $*)
    (*$ \qquad\qquad\qquad\qquad 
           \shared{\true} \since (\shared{\Top \mapsto p  * p \mapsto n,v *  \stack(n) * \true_{\se\se}} \extend \shared{\Top \mapsto n  *  \stack(n) * \true_{\se\se}}) 
          $*)          
  retire(p);
  (*$\{V \Vdash F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} \land \mbox{}$*)
    (*$ \qquad\qquad\qquad\qquad 
         (\shareds{\HP[\tid] \mapsto p * \true} \since \shareds{\Top \mapsto p  * p \mapsto n,v *  \stack(n) * \true_{\se\se}}) \land \shareds{p \mapsto_\se n,v * \true } \land \mbox{} $*)
    (*$ \qquad\qquad\qquad\qquad 
           \shared{\true} \since (\shared{\Top \mapsto p  * p \mapsto n,v *  \stack(n) * \true_{\se\se}} \extend \shared{\Top \mapsto n  *  \stack(n) * \true_{\se\se}}) 
          $*)          
  return v; 
}
(*$\{V \Vdash \mathit{pop}=a \land F_{\tid} \land \shareds{H * \exists y.\, \Top \mapsto y * \stack(y) * \true_{\se\se}} 
%\land (\shared{\true} \since (\shared{\abs(\Top) =a \overline{\alpha}}  \extend \shared{\abs(\Top) = \overline{\alpha}})) 
\}$*)          
\end{lstlisting}
}
\caption{Proof outline for {\tt pop} for a stack with hazard pointers.  Here
$V$ is $x$, $p$, $p2$, $n$, $v$.\label{fig:HazardPop}
}
\end{figure*}

\begin{figure*}
{\small
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
(*$\{s \mapsto x * \detached(x,A) * p \mapsto_m \_,\_ \land \shareds{p\mapsto_e \_,\_ * \true}  \} $*)
insert(s,p) {
  (*$\{\exists A.\, s \mapsto x * \ls(x,A)  * p \mapsto_m \_,\_ \land \shareds{p\mapsto_e \_,\_ * \true}  \} $*)
  (*$\{s \mapsto x * \ls(x,A)  * p \mapsto_m \_,\_ \land \shareds{p\mapsto_e \_,\_ * \true}  \} $*)
  (*$\langle$*) *p = x (*$\rangle_{\textsf{Write}}$*);
  (*$\{\exists x.\, s \mapsto x * \ls(x,A)  * p \mapsto_m x,\_ \land \shareds{p\mapsto_e x,\_ * \true}  \} $*)
  *s = p;
  (*$\{s \mapsto p * \ls(x,A)  * p \mapsto_m x,\_ \land \shareds{p\mapsto_e x,\_ * \true}  \} $*)
  (*$\{s \mapsto p * \ls(p,A  \uplus \{ p \})  \} $*)
}
(*$\{s \mapsto p * \detached(p,A \uplus \{ p \}) \}$*)

(*$\{s \mapsto x * \detached(x,A)\} $*)
isEmpty(s) {
  (*$\{s \mapsto x * \ls(x,A) \} $*)
  return *s == NULL;
  (*$\{s \mapsto x * \ls(x,A) \land (isEmpty \iff (x = 0))  \} $*)
}
(*$\{ s \mapsto x * \detached(x,A) \land (isEmpty \iff A = \emptyset) \}$*)

(*$\{s \mapsto x * \detached(x,A) \wedge A \neq \emptyset\} $*)
popd(s) {
  (*$\{s \mapsto x * \ls(x,A) \wedge A \neq \emptyset \} $*)
  (*$\{\exists y.\, s \mapsto x *  x \mapsto_m y,\_ \land \shareds{x\mapsto_e y,\_ * \true} * \ls(y, A \setminus \{ x\})  \} $*)
  Node p = *s;
  *s = s->next;
  (*$\{\exists y.\, s \mapsto y *  p \mapsto_m y,\_ \land \shareds{p\mapsto_e y,\_ * \true} * \ls(y, A \setminus \{ x\})  \} $*)
  return p;
}
(*$\{\exists y.\, s \mapsto y *  popd  \mapsto_m \_,\_ \land \shareds{popd\mapsto_e \_,\_ * \true} * \ls(y, A \setminus \{ x\}) \}$*)

(*$\{t \mapsto x * \detached(x,\emptyset)  * s \mapsto y * \detached(y,A)\} $*)
moveAll(t,s) {
  (*$\{t \mapsto 0 * \ls(0,\emptyset) * s \mapsto y * \ls(y,A) \} $*)
  *t = *s;
  *s = NULL
  (*$\{s \mapsto 0 * \ls(0,\emptyset) * t \mapsto y * \ls(y,A) \} $*)
}
(*$\{s \mapsto x * \detached(x,\emptyset)  * t \mapsto y * \detached(y,A)\} $*)
\end{lstlisting}
}
\caption{\label{fig:HazardSet}An implementation of a set with master permission to elements (nodes) in the shared state.
The set is implemented as a singly linked list, where the links are stored in the first cell of every detached node.
The only actions on the shared state that the set procedures are allowed to execute are $\textsf{Id}$ and $\textsf{Write}$.}
\end{figure*}

\nr{Rename pop in retire for stack}


\begin{figure*}
{\small
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
(*$
\begin{array}{@{}l@{}}  
  \{V \Vdash \nodepi{p}{m}{i} * F_{\tid}  \land  \shareds{\nodepi{p}{e}{i} * \true} \land \shareds{H * \true}  \}
\end{array}$
    \label{pc:RetireGen:Pre}*) 
void retire(int* p) {  
  (*$\begin{array}{@{}l@{}}  
    \{V \Vdash  \nodepi{p}{m}{i} * \exists x,A.\, \rlist[\tid]  \mapsto x * \detached(x,A)  \land \shareds{\nodepi{p}{e}{i} * \true} \land 
    \shareds{H * \true} \}
  \end{array}$*) 
  insert(&detached[tid],p); (*\label{pc:RetireGen:insert}*)
  (*$\begin{array}{@{}l@{}}
    \{V \Vdash  \exists x,A.\,  \rlist[\tid]  \mapsto x * \detached(x,A) \land  
      \shareds{H * \true} \}
   \end{array}$*) 
  if (nondet())
    return;

  (*$\begin{array}{@{}l@{}}
     \{V \Vdash  \exists x,A.\,  \rlist[\tid]  \mapsto x * \detached(x,A) \land  \shareds{H * \true} \}
     \end{array}$*) 
  int *h[1..N];
  (*$\begin{array}{@{}l@{}} 
    \{V \Vdash  \exists x,A.\, \rlist[\tid]  \mapsto x * \detached(x,A) \land  
    \shareds{H * \true} \land \forall x \in A.\, \neg\,\shared{\nodepi{x}{1}{i} * \true}\}
  \end{array}$
    \label{pc:RetireGen:precheck}*)  
  for (int i = 1 to N)
    (*$\begin{array}{@{}l@{}} 
      \{V \Vdash \exists x,A.\, \rlist[\tid]  \mapsto x * \detached(x,A) *  \mbox{}
      \\
      \ph
      \Big(\bigast\nolimits_{j \in \{1\ldots \nthreads \}}
      \big(\exists z.\, h[j] \mapsto z \land \big(j < i \implies\mbox{}
      (\forall x \in A.\,  \neg\,\shared{\nodepi{x}{1}{i} * \true}) 
       \since  \shareds{\HP[j] \mapsto z * \true}\big)\big)\Big) 
      \land
      \shareds{H * \true} \land \forall x \in A.\, \neg\,\shared{\nodepi{x}{1}{i} * \true}\}
    \end{array}$
      \label{pc:RetireGen:precheck}*)  
    (*$\langle$*)h[i] = HP[i](*$\rangle_{\textsf{Id}}$*);  
  Set used = null;
  while (!isEmpty(&detached[tid])) {
    (*$\begin{array}{@{}l@{}} 
      \{V \Vdash  \exists x,A,B.\, \rlist[\tid]  \mapsto x * \detached(x,A) * A \neq \emptyset* D(\texttt{used},B) * \mbox{}
        \\
        \ph
        \bigast\nolimits_{j \in \{1\ldots \nthreads \}}
        \big(\exists z.\, h[j] \mapsto z \land
        (\forall x \in A.\,  \neg\,\shared{\nodepi{x}{1}{i} * \true}) 
         \since  \shareds{\HP[j] \mapsto z * \true}\big) \land \shareds{H * \true}\}
      \end{array}$
      *)  
    bool my = true;
    Node *n = popd(&detached[tid]);    
    for (int i = 0; i < N && my; i++) {
      (*$\begin{array}{@{}l@{}} 
        \{V \Vdash  \mathit{my} \land \exists x,A,B.\, \rlist[\tid]  \mapsto x * \detached(x,A) * D(\texttt{used},B) * 
          (\nodepi{n}{\sm}{i} \land \shareds{\nodepi{n}{\se}{i} * \true}) * \mbox{}
          \\
          \ph \bigast\nolimits_{j \in \{1\ldots \nthreads \}}
          \big(\exists z.\, h[j] \mapsto z \land (j < i \implies z \neq n) \land \mbox{}
          \\
          \hfill
          (\forall x \in A \cup \{ n \}.\,  \neg\,\shared{\nodepi{x}{1}{i} * \true}) 
           \since  \shareds{\HP[j] \mapsto z * \true}\big) \land \shareds{H * \true}\}
        \end{array}$
        *)  
      if (h[i] == n)
        my = false;
    }
    
    if (my) {
      (*$\begin{array}{@{}l@{}} 
        \{V \Vdash  my \land \exists x,A,B.\, \rlist[\tid]  \mapsto x * \detached(x,A) * D(\texttt{used},B) * 
          (\nodepi{n}{\sm}{i} \land \shareds{\nodepi{n}{\se}{i} * \true}) * \mbox{}
          \\
          \ph 
          \bigast\nolimits_{j \in \{1\ldots \nthreads \}}
          \big(\exists z.\, h[j] \mapsto z \land z \neq n \land 
          ((\forall x \in A \cup \{ n \}.\,  \neg\,\shared{\nodepi{x}{1}{i} * \true}) 
           \since  \shareds{\HP[j] \mapsto z * \true})
           \land \mbox{}
           \\
           \qquad\qquad\qquad\qquad           
           \neg(\shareds{\HP[j] \mapsto n * \true} \since \shared{\nodepi{x}{1}{i} * \true})
           \big) 
           \land \shareds{H * \true}\}
        \end{array}$
        *)  
      (*$\langle$ ; $\rangle_{\textsf{Take}}$ \label{pc:RetireGen:take}*)
      (*$\begin{array}{@{}l@{}} 
        \{V \Vdash  my \land \exists x,A,B.\, \rlist[\tid]  \mapsto x * \detached(x,A) * D(\texttt{used},B) * 
          \nodepi{n}{1}{i}  * \mbox{}
          \\
          \ph 
          \bigast\nolimits_{j \in \{1\ldots \nthreads \}}
          \big(\exists z.\, h[j] \mapsto z  \land 
          (\forall x \in A .\,  \neg\,\shared{\nodepi{x}{1}{i} * \true}) 
           \since  \shareds{\HP[j] \mapsto z * \true}\big) \land \shareds{H * \true}  \}
        \end{array}$
        *)  
      free(n);
    } 
    else 
      insert(&used, n);
   }  
  (*$\{V \Vdash  \exists x,B.\, \rlist[\tid]  \mapsto x * \detached(x,\emptyset) * \detached(\texttt{used},B) \land \shareds{H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true} \}$*)   
  moveAll(&detached[tid], &used);   
  (*$\{V \Vdash  \exists x,A.\, \rlist[\tid]  \mapsto x * \detached(x,A) * \detached(\texttt{used},\emptyset) \land \shareds{H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true} \}$*)   
}
(*$\{V \Vdash F_{\tid} \land 
      \shareds{H * \exists y.\, \cc \mapsto y * y \mapsto \_ * \true} \}$*)
 \end{lstlisting}
}
\caption{\label{fig:RetireList}Proof outline for \texttt{retire}  
which uses a local copy of the hazard array.
The proof is for arbitrary algorithms where the notion of 
a cell being ``in the data structure'' is encoded by having the full permission for
the cell in the shared state.
$V=\{\texttt{used},\texttt{my},\texttt{n},\texttt{p},\texttt{n},\texttt{h}\}$.
The only actions \texttt{retire()} is allowed to execute are $\textsf{Id}$, $\textsf{Write}$ and $\textsf{Take}$.
The detached set is implemented using a linked list, where the links are stored in the first cell of a detached node).
We use $\nodepi{x}{p}{i} = x \mapsto_p \_ * \ldots * x + i-1 \mapsto_p \_ $ as a shorthand for an assertion denoting 
having  permission $p$ for $i$ consecutive cells starting at address $p$.}
\end{figure*}



