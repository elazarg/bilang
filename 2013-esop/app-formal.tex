%!TEX root = ./recycling.tex


\section{Additional Definitions\label{app:formal}}

\subsection{Operational Semantics}

We give a standard small-step operational semantics for our programming
language, omitted from \S\ref{sec:semantics}. Let us denote the set of commands
$C$ by $\Comm$.  The semantics is defined by in Figure~\ref{fig:sem}. The
definition uses an auxiliary relation $\longrightarrow_{\ltid} : \TConfig \times
\TConfig$ for $\ltid\in\ThreadID$ describing a single step by thread
$\ltid$. Here $\TConfig$ is defined like $\Config$ in
\S\ref{sec:semantics}, but with $\Comm$ instead of $\Prog$.
%Formally, the auxiliary relation is defined as a template where $\tid$ is replaced 
%by the thread identifier $t$ for every thread $t=1,\ldots,n$ in the program.
%A program does not have a thread identifier; it creates them for every command
%in the parallel composition.
%to semantics is given as a template  
We assume that atomic blocks in programs are annotated with the actions  used in their proofs. 
We annotate the arrows in transitions   pertaining to execution of atomic blocks with the actions annotating the block.
We annotate all other arrows with the special symbol $\ell$. 
%We use $-$ as a meta variable ranging over transitions labels.
We use $e$ as a meta variable ranging over transitions labels.
%(These annotations are used in the soundness proof of the conjunction rule.)


\subsection{Restrictions on Transformers for Primitive
  Commands}\label{sec:pcomm} 

For the logic to be sound, we have to require that the transformers $f^{\ltid}_ \alpha$
defining the semantics of primitive commands $ \alpha\in\PComm$ satisfy the standard
condition of {\em locality}~\cite{asl}.  Let us lift $*$ to $\State \cup
\{\top\}$ as follows:
$$
\forall \theta \in \State.\,\theta * \top = \top * \theta = \top * \top = \top.
$$
Then $f^{\ltid}_ \alpha$ is local when for any $\theta_1, \theta_2\in \State$
$$
{(\theta_1*\theta_2)\fdef} \wedge f^{\ltid}_ \alpha (\theta_1) \not= \top \Rightarrow
f^{\ltid}_ \alpha (\theta_1*\theta_2) = f^{\ltid}_ \alpha (\theta_1)*\{\theta_2\}.  
$$
Informally the condition states that:
\begin{itemize}
\item {\em Safety monotonicity:} if executing $ \alpha$ from a state
  $\theta_1*\theta_2$ results in an error, then so does executing $ \alpha$ from a
  smaller state $\theta_1$: $f^{\ltid}_ \alpha (\theta_1*\theta_2) = \top$ implies
  $f^{\ltid}_ \alpha (\theta_1) = \top$;
\item {\em Frame property:} if executing $ \alpha$ from a state $\theta_1$ does not
  produce an error, then executing $ \alpha$ from a larger state $\theta_1*\theta_2$,
  has the same effect and leaves $\theta_2$ unchanged.
\end{itemize}


\subsection{Additional definitions for $\RAM_{\se}$\label{sec:exist2}}

% According to our definition of $*$ on $\RAM_{\sf e}$, we have the following
% equivalences:
% \begin{gather*}
% E \xmapsto{n}_{\sf e} F \Longleftrightarrow 
% E \xmapsto{n+1}_{\sf e} F * E \hookrightarrow_{\sf e} \_; \qquad
% E \xhookrightarrow{n}_{\sf e} \_ * E \xhookrightarrow{n'}_{\sf e} \_ 
% \Longleftrightarrow 
% E \xhookrightarrow{n+n'}_{\sf e} \_;
% \notag\\
% E \xmapsto{0}_{\sf e} F * E \xmapsto{0}_{\sf e} F \Longleftrightarrow {\sf
%   false};
% \qquad
% E \xmapsto{0}_{\sf e} F * E \xhookrightarrow{n}_{\sf e} \_ \Longleftrightarrow
% {\sf false},
% \label{equiv}
% \end{gather*}
% where $n, n'> 0$.

We give transformers and axioms for standard primitive commands:
$$
\alpha  \::=\  [{\tt x}] = {\tt y} \mid [{\tt y}] = [{\tt x}] \mid \new([{\tt x}]) \mid 
 \delete([{\tt x}]) \mid {\sf assume}([{\tt x}])
$$
where {\tt x} and {\tt y} are constants. Here square brackets denote pointer
dereferencing. We give only simple cases of commands with constants as
expressions\footnote{For more complex cases see: A. Appel and
  S. Blazy. Separation logic for small-step Cminor, {\em TPHOLs}, 2007.}.  The
{\sf assume} command acts as a filter on the state space of programs and is used
to implement conditionals and loops. Its parameter is assumed to be non-zero
after the command is executed.  Using {\sf assume}, we can implement
conditionals and loops as follows:
$$
\begin{array}{@{}r@{\, }c@{\, }l@{}}
(\textsf{if}\ E\ \textsf{then}\ C_1\ \textsf{else}\ C_2)
& = &
({\sf assume}(E);C_{1}) + ({\sf assume}(!E);C_{2});
\\
(\textsf{while}\ E\ \textsf{do}\ C)
& = &
({\sf assume}(E);C)^*;\, {\sf assume}(!E).
\end{array}
$$

For a function $g$, we denote by $g[x:y]$ the function that has the same value
as $g$ everywhere, except for $x$, where it has the value $y$.
Transformers $f^{\ltid}_ \alpha: \RAM_{\se} \to \power(\RAM_{\se})^\top$ for the above
primitive commands $ \alpha$ are defined with the aid of the transition relation
$\leadsto$ in Figure~\ref{fig:transfer}: 
$$
f^{\ltid}_ \alpha (\theta)= \bigcup \{\theta' \mid  \alpha,\theta \leadsto \theta'\},
$$
if $ \alpha, \theta \not\leadsto \top$; otherwise, $f^{\ltid}_ \alpha (\theta)=\top$.  These
transformers are local~\cite{asl}. Figure~\ref{fig:prim} shows instantiations
of the {\sc Local} axiom of our logic for the above primitive commands.


\begin{figure}[t]
\begin{gather*}
\infer{
 \alpha, \theta \stackrel{\ell}{\longrightarrow}_\ltid \done, \theta'
}{
  \alpha \in \PComm
 & 
 f^{\ltid}_ \alpha (\theta) \neq \top
 &
 \theta' \in f^{\ltid}_ \alpha(\theta) 
}
\\[3pt]
\infer{
  \alpha, \theta \stackrel{\ell}{\longrightarrow}_\ltid \top
}{
  \alpha \in \PComm
 & 
 f^{\ltid}_ \alpha (\theta) = \top
}
\\[10pt]
\infer{
  \done; C_2, \theta \stackrel{\ell}{\longrightarrow}_\ltid C_2, \theta
}{}
\\[3pt]
\infer{
  C_1; C_2, \theta \stackrel{e}{\longrightarrow}_\ltid C'_1; C_2, \theta'
}{
  C_1, \theta \stackrel{e}{\longrightarrow}_\ltid C'_1, \theta'
}
\\[3pt]
\infer{
  C_1; C_2, \theta \stackrel{e}{\longrightarrow}_\ltid \top
}{
  C_1, \theta \stackrel{e}{\longrightarrow}_\ltid \top
}
\\[3pt]
\infer{
  C_1+C_2, \theta \stackrel{\ell}{\longrightarrow}_\ltid C_i, \theta
}{i \in \{1,2\}}
\\[10pt]
\infer{
  C^*, \theta \stackrel{\ell}{\longrightarrow}_\ltid C; C^*, \theta
}{}
\\[10pt]
\infer{
  C^*, \theta \stackrel{e}{\longrightarrow}_\ltid \done, \theta
}{}
\\[3pt]
\infer{\langle C \rangle_a, \theta \stackrel{a}{\longrightarrow}_\ltid \done,\theta'}
{C, \theta \stackrel{\ell}{\longrightarrow}_\ltid^* \done,\theta'}
\\[3pt]
\infer{\langle C \rangle_a, \theta \stackrel{a}{\longrightarrow}_\ltid \top}
{C, \theta \stackrel{\ell}{\longrightarrow}_\ltid^* \top}
\\[3pt]
\infer{
 C_1 \parallel \ldots \parallel C_\ltid \parallel \ldots \parallel C_n, \theta
 \stackrel{e}{\longrightarrow}
 \top
}{
 C_\ltid, \theta
 \stackrel{e}{\longrightarrow}_\ltid 
 \top
}
\\[3pt]
\infer {
 C_1 \parallel \ldots \parallel C_\ltid \parallel \ldots \parallel C_n, \theta
 \stackrel{e}{\longrightarrow}
 C_1 \parallel \ldots \parallel C'_\ltid \parallel \ldots \parallel C_n, \theta'
}{
 C_\ltid,\theta \stackrel{e}{\longrightarrow}_\ltid C'_\ltid, \theta'
}
\end{gather*}
\caption{\small Operational semantics of the programming language}
\label{fig:sem}
\end{figure}
\begin{figure}[t]
{\small
$$
\begin{array}{@{}l@{\ }l@{\ }l@{\ }l@{\ }l@{}}
[{\tt x}] = {\tt y}, &\theta[{\tt x} : (\_,\pi)] &\leadsto& \theta[{\tt x}: ({\tt y},\pi)]
\\{}
[{\tt y}] = [{\tt x}], &\theta[{\tt x} : (v,\pi)][{\tt y} : (\_,\pi')] &\leadsto&
\theta[{\tt x}:(v,\pi)][{\tt y}:(v,\pi')]
\\{}
[{\tt y}] = [{\tt x}], &\theta[{\tt x} : \se][{\tt y} : (\_,\pi)] &\leadsto&
\theta[{\tt x}:\se][{\tt y}: (\_,\pi)]
\\{}
%[Y] = [X], &\theta[Y : \se] &\leadsto&
%\top\\{}
\new([{\tt x}]), &\theta[{\tt x} : (\_,\pi)] &\leadsto&
\theta[{\tt x}: (u,\pi)][u : (\_,1)],
%\\ &&& \hspace{1.3cm}
\ \text{if}~{(\theta[{\tt x} : \_])(u)\fundef}
\\
\delete([{\tt x}]),&\theta[{\tt x} : (u,\pi)][u : (\_,1)] &\leadsto&
\theta[{\tt x}:(u,\pi)],
%\\ &&& \hspace{1.3cm}
\ \text{if}~{(\theta[{\tt x} : \_])(u)\fundef}
\\
%,
% \ \text{if}~{(\theta[X:\_])(u)\fundef}
%\\
%\delete([X]),&\theta[X : \sro(n, u)][u : \sm(0,0, \_)] &\leadsto&
%\theta[X:\sro(n,u)],
%\hspace{0.5cm}\text{if}~{(\theta[X:\_])(u)\fundef}
%\\
{\sf assume}([{\tt x}]), &\theta[{\tt x} : \se] &\leadsto& \theta[{\tt x} : \se]
\\
{\sf assume}([{\tt x}]), &\theta[{\tt x} : (u,\pi)] &\leadsto& \theta[{\tt x} : (u,\pi)],
\ \text{if}~u\not=0
\\
{\sf assume}([{\tt x}]), &\theta[{\tt x} :  (u,\pi)] &\not\leadsto&   \quad \text{if}~u=0
\\
%{\sf assume}([X]), &\theta[X : \sm(n,m, u)] &\not\leadsto&
%\hspace{2.6cm}\text{if}~u =0
%\\
%{\sf assume}([X]), &\theta[X : \sro(n, u)] &\not\leadsto&
%\hspace{2.6cm}\text{if}~u =0
%\\
\alpha, &\theta &\leadsto& \top,\ \text{otherwise}
\end{array}
$$
}
\caption{\label{fig:transfer}\small 
Transition relation for primitive commands over $\RAM_{\se}$. We assume that
${\tt x}\not={\tt y}$ in $[{\tt y}]=[{\tt x}]$.
$\top$ indicates that the command faults.
$\not\leadsto$ is used to denote that the command does not fault, but gets stuck.
We use $\pi$ and $\pi'$ to denote  a permission that is either 
$1$ or $\sm$.
}
\end{figure}
\begin{figure}[t]
$$
\begin{array}{c}
\\
\infer%[\textsc{Store}]
{\{{\tt x} \xmapsto{}_\pi \_\}\, [{\tt x}] = {\tt y}\, \{{\tt x} \xmapsto{}_\pi {\tt y}\}}{}
\\[10pt]
\infer%[\textsc{Load}_1]
{\{{\tt x} \xmapsto{}_\pi u *
{\tt y} \xmapsto{}_{\pi '} \_ \}\, [{\tt y}] = [{\tt x}]\, 
\{{\tt x} \xmapsto{}_\pi u*
{\tt y} \xmapsto{}_{\pi '} u \}}{}
\\[10pt]
%\infer%[\textsc{Load}_2]
%{\{X \hookrightarrow_{\sf e} \_*
%Y \xmapsto{\se:n} \_ \}\, 
%[Y] = [X]\, 
%\{X \hookrightarrow_{\sf e} \_*
%Y \xmapsto{\se:n} \_ \}}{}
%\\[10pt]
%\infer%[\textsc{Load}_2]
%{\{X \hookrightarrow_{\sf ro} u*
%Y \xmapsto{\se:n} \_ \}\, 
%[Y] = [X]\, 
%\{X \hookrightarrow_{\sf ro} u*
%Y \xmapsto{\se:n} u \}}{}
%\\[10pt]
\infer%[\textsc{New}]
{\{{\tt x} \xmapsto{}_\pi \_ \}\, \new({\tt x})\, \{\exists u.\, {\tt x} \xmapsto{}_\pi u*
u \mapsto_{1} \_\}}{}
\\[10pt]
\infer%[\textsc{Delete}]
{\{{\tt x} \xmapsto{}_\pi u * u \mapsto_1 \_\}\, \delete({\tt x})\, \{
{\tt x} \xmapsto{}_\pi u\}}{}
\\[10pt]
%\infer%[\textsc{Delete}]
%{\{X \hookrightarrow_{\sro} u * u \mapsto \_\}\, \delete(X)\, \{
%X \hookrightarrow_{\sro} u\}}{}
%\\[10pt] 
\infer
{\{{\tt x} \xmapsto{}_\pi u\}\, {\sf assume}([{\tt x}])\, \{{\tt x} \xmapsto{}_\pi u
  \wedge u \not= 0\}}{}
\\[10pt] 
\infer
{\{{\tt x} \mapsto_{\sf e} \_\}\, {\sf assume}([{\tt x}])\, 
\{{\tt x}\mapsto_{\sf e} \_\}}{}
\\[10pt] 
%\infer
%{\{X \hookrightarrow_{\sf ro} u\}\, {\sf assume}([X])\, 
%\{X \hookrightarrow_{\sf ro} u   \wedge u \not= 0\}}{}
\end{array}
$$
\caption{\small Instantiations of the {\sc Local} axiom for the $\RAM_{\se}$
  algebra; {\tt x} and {\tt y} are constants. 
  We use $\pi$ to denote  a permission that is either
$1$ or $\sm$.
}
\label{fig:prim}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Transformers $f^{\ltid}_c: \RAM_{\pi} \to \power(\RAM_{\pi})^\top$ for the above
%primitive commands $c$ are defined with the aid of the transition relation $\leadsto$ in
%Figure~\ref{fig:transfer}: 
%$$
%f^{\ltid}_c(\theta)= \bigcup \{\theta' \mid c,\theta \leadsto \theta'\},
%$$
%if $c, \theta \not\leadsto \top$; otherwise, $f^{\ltid}_c(\theta)=\top$.  These
%transformers are local~\cite{asl}. Figure~\ref{fig:prim} shows instantiations
%of the {\sc Local} axiom of our logic for the above primitive commands.
%\begin{figure}[h]
%$$
%\begin{array}{@{}l@{\ \ }l@{\quad}l@{\quad}l@{\quad}l@{}}
%[X] = Y, &\theta[X : \sm(n, 0,\_)] &\leadsto& \theta[X: \sm(n,0,Y)]
%\\{}
%[Y] = [X], &\theta[X : \sm(n, m,u)][Y : \sm(n', 0, \_)] &\leadsto&
%\theta[X:\sm(n,m, u)][Y:(n',0, u)]
%\\{}
%[Y] = [X], &\theta[X : \se(n)][Y : \sm(n',0, \_)] &\leadsto&
%\theta[X: \se(n)][Y:\sm(n',0, \_)]
%\\{}
%[Y] = [X], &\theta[X : \sro(n,u)][Y : \sm(n',0, \_)] &\leadsto&
%\theta[X: \sro(n,u)][Y:\sm(n',0, u)]
%\\
%\new([X]), &\theta[X : \sm(n, 0,\_)] &\leadsto&
%\theta[X: \sm(n,0, u)][u : \sm(0, 0,\_)],\\
%&&&
%\hspace{2.6cm}\text{if}~{(\theta[X : \_])(u)\fundef}
%\\
%\delete([X]),&\theta[X : \sm(n,m, u)][u : \sm(0,0, \_)] &\leadsto&
%\theta[X:\sm(n,m,u)],
% \ \text{if}~{(\theta[X:\_])(u)\fundef}
%\\
%\delete([X]),&\theta[X : \sro(n, u)][u : \sm(0,0, \_)] &\leadsto&
%\theta[X:\sro(n,u)],
%\hspace{0.5cm}\text{if}~{(\theta[X:\_])(u)\fundef}
%\\
%{\sf assume}([X]), &\theta[X : \se(n)] &\leadsto& \theta[X : \se(n)]
%\\
%{\sf assume}([X]), &\theta[X : \sm(n, m,u)] &\leadsto& \theta[X : \sm(n,m, u)],
%\  \text{if}~u\not=0
%\\
%{\sf assume}([X]), &\theta[X : \sro(n,u)] &\leadsto& \theta[X : \sro(n,u)],
%\hspace{0.5cm}\text{if}~u \not=0
%\\
%{\sf assume}([X]), &\theta[X : \sm(n,m, u)] &\not\leadsto&
%\hspace{2.6cm}\text{if}~u =0
%\\
%{\sf assume}([X]), &\theta[X : \sro(n, u)] &\not\leadsto&
%\hspace{2.6cm}\text{if}~u =0
%\\
%c, &\theta &\leadsto& \top,
%\hspace{2.2cm}\text{otherwise}
%\end{array}
%$$
%\caption{\label{fig:transfer}
%Transition relation for primitive commands over $\RAM_{\pi}$. We assume that
%$X\not=Y$ in $[Y]=[X]$.
%$\top$ indicates that the command faults.
%$\not\leadsto$ is used to denote that the command does not fault, but gets stuck.
%}
%\end{figure}
%\begin{figure}[h]
%$$
%\begin{array}{c}
%\\
%\infer%[\textsc{Store}]
%{\{X \xmapsto{\se:n} \_\}\, [X] = Y\, \{X \xmapsto{\se:n} Y\}}{}
%\\[10pt]
%\infer%[\textsc{Load}_1]
%{\{X \xmapsto{\se:n,\sro:m} u*
%Y \xmapsto{\se:n} \_ \}\, [Y] = [X]\, 
%\{X \xmapsto{\se:n,\sro:m} u*
%Y \xmapsto{\se:n} u \}}{}
%\\[10pt]
%\infer%[\textsc{Load}_2]
%{\{X \hookrightarrow_{\sf e} \_*
%Y \xmapsto{\se:n} \_ \}\, 
%[Y] = [X]\, 
%\{X \hookrightarrow_{\sf e} \_*
%Y \xmapsto{\se:n} \_ \}}{}
%\\[10pt]
%\infer%[\textsc{Load}_2]
%{\{X \hookrightarrow_{\sf ro} u*
%Y \xmapsto{\se:n} \_ \}\, 
%[Y] = [X]\, 
%\{X \hookrightarrow_{\sf ro} u*
%Y \xmapsto{\se:n} u \}}{}
%\\[10pt]
%\infer%[\textsc{New}]
%{\{X \xmapsto{\se:n} \_ \}\, \new(X)\, \{\exists u.\, X \xmapsto{\se:n} u*
%u \mapsto \_\}}{}
%\\[10pt]
%\infer%[\textsc{Delete}]
%{\{X \xmapsto{\se:n,\sro:m} u * u \mapsto \_\}\, \delete(X)\, \{
%X \xmapsto{\se:n,\sro:m} u\}}{}
%\\[10pt]
%\infer%[\textsc{Delete}]
%{\{X \hookrightarrow_{\sro} u * u \mapsto \_\}\, \delete(X)\, \{
%X \hookrightarrow_{\sro} u\}}{}
%\\[10pt] 
%\infer
%{\{X \xmapsto{\se:n,\sro:m} u\}\, {\sf assume}([X])\, \{X \xmapsto{\se:n,\sro:m} u
%  \wedge u \not= 0\}}{}
%\\[10pt] 
%\infer
%{\{X \hookrightarrow_{\sf e} \_\}\, {\sf assume}([X])\, 
%\{X \hookrightarrow_{\sf e} \_\}}{}
%\\[10pt] 
%\infer
%{\{X \hookrightarrow_{\sf ro} u\}\, {\sf assume}([X])\, 
%\{X \hookrightarrow_{\sf ro} u   \wedge u \not= 0\}}{}
%\end{array}
%$$
%\caption{Instantiations of the {\sc Prim} axiom for the $\RAM_{\pi}$
%  algebra; $X$ and $Y$ are constants}
%\label{fig:prim}
%\end{figure}


\subsection{Additional Proof Rules}

The proof rules of the logic omitted from Figure~\ref{fig:logic-rules}
are shown in Figure~\ref{fig:logic2}.
\begin{figure}[t]
$$
\begin{array}{c}
\infer[\textsc{Seq}]{
R, G, \Upsilon \vdash_\ltid \{P_1\}\,C_1; C_2\,\{P_3\}
}{
R, G, \Upsilon \vdash_\ltid \{P_1\}\,C_1\,\{P_2\} 
&
R,G, \Upsilon \vdash_\ltid \{P_2\}\,C_2\,\{P_3\}
}
\\[7pt]
%
\infer[\textsc{Choice}]{
 R, G,\Upsilon \vdash_\ltid \{P\}\,C_1+C_2\,\{Q\}
}{
R, G,\Upsilon \vdash_\ltid \{P\}\,C_1\,\{Q\} 
&
 R, G,\Upsilon \vdash_\ltid \{P\}\,C_2\,\{Q\}
}
\\[7pt]
%
\infer[\textsc{Loop}]{
 R, G,\Upsilon \vdash_\ltid \{P\}\,C^{*}\,\{P\}
}{
 R, G,\Upsilon \vdash_\ltid \{P\}\,C\,\{P\}
}
\\[7pt]
\infer[\textsc{Disj}]{
R, G, \Upsilon \vdash_\ltid \{P_1 \vee P_2\}\,C\,\{Q_1 \vee Q_2\}
}{
R, G, \Upsilon \vdash_\ltid \{P_1\}\,C\,\{Q_1\} 
&
R,G, \Upsilon \vdash_\ltid \{P_2\}\, C\,\{Q_2\}
}
\\[7pt]
\infer[\textsc{Conj}]{
R,G, \Upsilon \vdash_\ltid \{P_1 \land P_2\}\,C\,\{Q_1 \land Q_2\} \quad
}{
R,G, \Upsilon \vdash_\ltid \{P_1\}\,C\,\{Q_2\}
\quad
R,G, \Upsilon \vdash_\ltid \{P_2\}\,C\,\{Q_2\}
}
\\[7pt]
\infer[\textsc{Exists}_1 ]{
R,G, \Upsilon \vdash_\ltid \{\exists x.\, P\}\,C\,\{\exists x.\, Q\}
}{
R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
}
\\[7pt]
\infer[\textsc{Forall}_1 ]{
R,G, \Upsilon \vdash_\ltid \{\forall x.\, P\}\,C\,\{\forall x.\, Q\}
}{
R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\} 
}
\\[7pt]
\infer[\textsc{Exists}_2 ]{
R,G, \Upsilon \vdash_\ltid \{\exists X.\, P\}\,C\,\{\exists X.\, Q\}
}{
R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\}
}
\\[7pt]
\infer[\textsc{Forall}_2]{
R,G, \Upsilon \vdash_\ltid \{\forall X.\, P\}\,C\,\{\forall X.\, Q\}
}{
R,G, \Upsilon \vdash_\ltid \{P\}\,C\,\{Q\} 
}
%\\[7pt]
%\infer[\textsc{Done}]{
%R,G, \Upsilon \vdash_\ltid \{P\}\,\done\,\{P\}
%}{}
\end{array}
$$
\caption{\small Additional proof rules of the logic}
\label{fig:logic2}
\end{figure}




\subsection{Derivation of \textsc{Shared-I}}

The derivation of the \textsc{Shared-I} is given in
Figure~\ref{fig:SharedIDerivation}. 

% The derivation of the \textsc{Shared-S} rule appears below.
%  $$
%  \begin{array}{@{}r@{}}
%   \infer
%      {
%      \emptyset,G,\true \vdash_\ltid 
%      \{p \land \shareds{p_s} \land (\shareds{g} \since \shareds{r})\} \,
%     \langle C \rangle_a \,
%      \{ q  \land \shareds{q_s} \land (\shareds{g} \since \shareds{r}) \}
%      }
%  {
%  \begin{array}{@{}l@{}}
%  p \Rightarrow l * \true
%  \quad
%  a = (l \mid p'_s \leadsto q'_s) \in G 
%  \quad
%  p_s \Rightarrow p_s'
%  \quad
%  q_s \Rightarrow q_s'
%  \\[2pt]
%  \emptyset,\emptyset,\true \vdash_\ltid 
%  \{ p * (p_s \land  g) \}
%  \, C \,
%  \{ q * (q_s \land  g) \}
%  \end{array}
%  }
%  \\[5pt]
%   \textsc{Shared-S}
%  \end{array}
%  $$
%  The rule states that an atomic command preserves $\shareds{g}
%  \since \shareds{r}$ when it preserve $\shareds{g}$. This is justified by the
%  following tautology:
%  \[
%  (\shareds{a} \since \shareds{b}) \extend \shareds{a} \Rightarrow
%  (\shareds{a} \since \shareds{b}). 
%  \]

% The derivation of the \textsc{Shared-I} rule appears in Figure~\ref{fig:SharedIDerivation}.
% In our proofs, we only use a limited number of tautologies involving $\sinceop$ 
% and a particular form of a temporal invariant. We use these tautologies to 
% derive special proof rules, which are useful for establishing assertions involving $\sinceop$, 
% carrying them over atomic commands, or proving the preservation of an invariant.
% We now derive a specialised proof rule for establishing invariants $\Upsilon$ of the form.

% We use Tautologies~\ref{T:NegSinceExtend} and~\ref{T:ImpNegSince} 
% in the derivation of the first  proof obligation
% of the \textsc{Shared-I} rule and Tautologies~\ref{T:NegSinceIntroFormal} and~\ref{T:SinceImp} in the proof of the second obligation.
% (See Figure~\ref{fig:SharedIDerivation}.)

% \begin{eqnarray}
% (\neg (\shared{a} \since \shared{b}) \extend \shared{\neg(a \land b)}) 
% &\implies& 
% \neg (\shared{a} \since \shared{b}) \label{T:NegSinceExtend} \\
% \neg(\shared{a} \since \shared{b})  & \implies &  \neg (\shared{a} \land \shared{b}) \label{T:ImpNegSince}
% \end{eqnarray}


% \begin{eqnarray}
% (\shared{a} \implies \shared{c}) &\implies& 
% ((\shared{a} \since \shared{b}) \implies \shared{c}) \label{T:NegSinceIntroFormal}\\
% (\shared{a} \since \shared{b}) &\implies& \shared{a} \label{T:SinceImp}
% \end{eqnarray}

% \ignore{
% \subsection{Tautologies}
% We use the following tautologies to establish and carry temporal assertions involving $\sinceop$.
% \begin{compactenum}
% % \item \label{T:SinceIntro}  
% % $(A \wedge B) \implies (A \since B)$  
% \item \label{T:SinceExtend} 
% $((\shared{p} \since B) \extend \shared{p}) \implies (\shared{p} \since B)$  
% \item \label{T:SinceImp} \label{T:NegSinceIntro} 
% $((A \since B) \implies A)$ and 
% $(\neg A \implies \neg (A \since B))$
%  %$(\neg A \wedge \neg B) \implies \neg (A \since B)$
% %\item  \label{T:NegSinceExtend} 
% % $(\neg (\shared{p} \since \shared{q}) \extend \shared{\neg(p \land q)}) 
% % \implies \neg (\shared{p} \since \shared{q})$
% \item 
% $(\neg A \lor C) \implies ((A \since B) \implies C)$.
% \item \label{T:TrueImpImp}
% $A \implies (B \implies A)$
% \item \label{T:SinceInconsistent}
% $(A \since B) \land (\neg B \since \neg A) \implies \false$ 
% \item \label{T:SinceWeaken}
% $((A' \Rightarrow A) \land (B' \Rightarrow B) \land (A' \since B')) \implies (A \since B) $

% \end{compactenum}
% }
% \ignore{
% To this end, we first apply \textsc{Shared-R} as usual, and then establish that
% the command preserves~(\ref{neg-since}) for all $i$ using the \textsc{Shared-S}
% rule shown in Figure~\ref{fig:SharedSI}.  Then~(\ref{neg-taut}) allows us to
% discharge the obligation $Q \Rightarrow \Upsilon$ in \textsc{Shared-R}.  
% }


\begin{figure*}
%{\small
\footnotesize
\[
\begin{array}{@{}c@{}}
\infer
{
\emptyset,G,\true \vdash_\ltid 
\{p  \land \shared{p_s} \land\neg(\shared{g} \since \shared{r}) \} \,
\langle C\rangle_a \,
\{ q \land \shared{q_s}  \land ((\shared{g} \since \shareds{r}) \Rightarrow \shareds{c} ) \}    
}
{
\begin{array}{c}
p \Rightarrow l * \true
\qquad
p_s \Rightarrow p'_s
\qquad
q_s \Rightarrow q'_s
\qquad
a = (l \mid p'_s \leadsto q'_s) \in G 
\\[2pt]
(p  \land \shared{p_s} \land \neg(\shared{g} \since \shared{r})) 
\Rightarrow 
(p  \land \neg(\shared{g} \since \shared{r}) \land 
\shared{
 p_s 
 \land 
 \neg (g  \land r)
})
\\[2pt]
\emptyset,\emptyset,\true \vdash_\ltid 
\{ p * (p_s \land  \neg(g  \land r)) \}
\, C \,
\{ q * (q_s \land  (g \land r \Rightarrow c)) \}
\\[2pt]
(q \land (
(\neg(\shared{g} \since \shared{r}) \wedge 
\shared{p_s \land \neg(g  \land r)})
\extend 
\shared{q_s \land  (g \land r \Rightarrow c)}))
\Rightarrow 
(q \land \shared{q_s} \land  ((\shared{g} \since \shareds{r}) \Rightarrow \shareds{c}))
\end{array}
}
%
\\[5pt]
\hfill (\textsc{Shared, Conseq})
\\[4ex]
%
\infer
{
\emptyset,G,\true \vdash_\ltid 
\{p   \land \shared{p_s} \land (\shared{g} \since \shared{r}) \land  \shareds{c} \} \,
    \langle C \rangle_a\,
\{ q  \land \shared{q_s} \land ((\shared{g} \since \shared{r}) \Rightarrow \shareds{c})  \}    
}
{
\begin{array}{c}
p \Rightarrow l * \true
\qquad
p_s \Rightarrow p'_s
\qquad
q_s \Rightarrow q'_s
\qquad
a = (l \mid p'_s \leadsto q'_s)
\in G
\\[2pt]
(p  \land \shared{p_s} \land (\shared{g} \since \shared{r}) \land \shareds{c})
\Rightarrow 
(p  \land 
\shared{
 p_s 
 \land 
 g
\land
 c
})
\\[2pt]
\emptyset,\emptyset,\true \vdash_\ltid 
\{ p  * (p_s \land  g \land c) \}
\, C \,
\{ q * (q_s \land  (g \Rightarrow c)) \}
\\[2pt]
(q \wedge 
(\shared{p_s \land g \land c} 
\extend 
\shared{q_s \land (g \Rightarrow c)}))
\Rightarrow 
(q \wedge \shared{q_s} \land ((\shared{g} \since \shareds{r}) \Rightarrow \shareds{c}))
\end{array}
}
%
\\[5pt]
\hfill (\textsc{Shared, Conseq})
\\[4ex]
%
  \infer
    {
    \emptyset,G,\true \vdash_\ltid 
    \{p  \land \shared{p_s} \land ((\shared{g} \since \shareds{r}) \Rightarrow \shareds{c})\} \,
    \langle C \rangle_a \,
    \{ q  \land \shared{q_s} \land ((\shared{g} \since \shareds{r}) \Rightarrow \shareds{c}) \}
    }
    { % \land (\shared{g} \since \shared{n})
    \infer
    {
    \begin{array}{c}  
    \emptyset,G,\true \vdash_\ltid 
    \{p  \land \shared{p_s} \land (\neg(\shared{g} \since \shared{r}) \lor ((\shared{g} \since \shared{r}) \land \shared{c}))\} 
\,    \langle C \rangle_a \,
    \{ q \land \shared{q_s} \land ((\shared{g} \since \shareds{r}) \Rightarrow \shareds{c})  \}    
    \end{array}
    }
    {
    \begin{array}{c}  
    \emptyset,G,\true \vdash_\ltid 
    \{p \land \shared{p_s}  \land \neg(\shared{g} \since \shared{r}) \} 
    \,    \langle C \rangle_a \,
    \{ q \land \shared{q_s} \land ((\shared{g} \since
    \shareds{r}) \Rightarrow \shareds{c})  \}    
    \\[2pt]
    \emptyset,G,\true \vdash_\ltid 
    \{p  \land \shared{p_s} \land ((\shared{g} \since \shareds{r}) \land \shareds{c})\} 
    \,    \langle C \rangle_a \,
    \{ q \land \shared{q_s} \land  ((\shared{g} \since \shared{r}) \Rightarrow \shareds{c}) \}    
    \end{array}
   }
   }
\\[5pt]
\hfill (\textsc{Disj}, \textsc{Conseq})
\end{array}
\]
%}
\caption{\small \label{fig:SharedIDerivation}Derivation of {\sc Shared-I}}
\end{figure*}


%%% Local Variables:
%%% TeX-master: "recycling"
%%% End:  
