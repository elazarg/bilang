%!TEX root = ./recycling.tex

\begin{figure}
{\figfontsize
\be
\cc \mapsto x * x \mapsto \_  * X
\leadsto 
\cc \mapsto y * y \mapsto \_ * x \mapsto_e \_ * X
\tag{$\textsf{Inc}$}
\ee
\begin{multline}
\GE \mapsto e * \LE[\ltid-1] \mapsto l * C(\ltid, e) * X
\leadsto {}\\
\GE \mapsto e * \LE[\ltid-1] \mapsto e * C(\ltid, l) * X
\tag{$\textsf{UpdateLE}_\ltid$}
\end{multline}
\be
\Elock \mapsto 0 \leadsto \Elock \mapsto \ltid * X
\tag{$\textsf{Lock}_\ltid$}
\ee
\be
\Elock \mapsto \ltid \leadsto \Elock \mapsto 0 * X
\tag{$\textsf{Unlock}_\ltid$}
\ee
\begin{multline}
\Elock \mapsto \ltid * 
\GE \mapsto e * {}\\
\rlist[t-1][e \oplus 1] \mapsto A \uplus \{x\} * x \mapsto \_
\leadsto{}\\
\GE \mapsto e*
\rlist[t-1][e \oplus 1] \mapsto A
\tag{$\textsf{Pop}_\ltid$}
\end{multline}
\begin{multline}
\Elock \mapsto \ltid * 
\GE \mapsto e * (\bigast\nolimits_t \LE[t-1] \mapsto e)
\leadsto{}\\
\Elock \mapsto \ltid * 
\GE \mapsto e\oplus1 * (\bigast\nolimits_t \LE[t] \mapsto e)
\tag{$\textsf{NextEpoch}_\ltid$}
\end{multline}
\be
X
\leadsto
X
\tag{$\textsf{Id}$}
\ee
$$
G_\ltid \,{=}\, \{\textsf{Inc}, \textsf{UpdateLE}_\ltid, \textsf{Lock}_\ltid, 
\textsf{Unlock}_\ltid, \textsf{Pop}_\ltid, \textsf{NextEpoch}_\ltid, 
\textsf{Id}\};
$$
$$
R_\ltid = \bigcup \{G_k \mid {1 \le k \le \nthreads} \wedge {k \not= \ltid}\}
$$
$$
\begin{array}{@{}l@{}}
\Upsilon_{\sf E} \iff
(\forall t, l, x.\, (\shared{\LE[t-1] \mapsto l * \true} \since \shared{\cc \mapsto x
  * x \mapsto \_ * \true}) 
\\
\hspace{5cm} {} \implies \shared{x \mapsto_e \_* \true})
\wedge{}
\\[3pt]
(\forall t, t', e, A.\,
\shared{\exists y.\, \GE \mapsto e * 
\rlist[t-1][e \oplus 1] \mapsto A * \true} \implies {}
\\[3pt]
\forall x \in A.\, 
(\neg \shared{\cc \mapsto x * x \mapsto \_ * \true} \since 
\neg \shared{\LE[t'-1] \mapsto e * \true})
\end{array}
$$
$$
C(t, l)  \iff \exists A.\, \rlist[t-1][l] \mapsto A * (\bigast\nolimits_{x \in A}   x \mapsto_m \_)
$$
$$
L(t, l) \iff \exists A.\, \rlist[t-1][l] \mapsto A * 
(\bigast\nolimits_{x \in A}   x \mapsto_m \_ * \shared{x \mapsto_e \_ * \true}) 
$$
$$
\begin{array}{@{}l@{}}
I(l, t)  \iff 
\exists e, y.\, \LE[t-1] \mapsto l * \GE \mapsto e * \cc \mapsto y * y \mapsto \_ *{}
\\
 \bigast\nolimits_{t' \not= t} (\exists l.\, 
\LE[t'-1] \mapsto l * C(t', l\oplus 1) * C(t', l\oplus 2) \wedge {}
\\
e \in \{l, l \oplus 1\})* 
\exists l.\, C(t, l\oplus 1) * C(t, l\oplus 2) \wedge e \in \{l, l \oplus 1\}
\end{array}
$$
}
\caption{\label{fig:act-epoch}\small Rely/guarantee conditions, the temporal invariant
  and auxiliary assertions used in the proof of the counter algorithm with
  epoch-based reclamation}
\end{figure}

\begin{figure}
{\figfontsize
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
int GE = 0;
int LE[N] = {0};
Set detached[N][3] = {(*$\emptyset$*)};
Lock Elock;

int inc() {
  int v, *s, *n;
  (*$\{V \Vdash \exists l.\,
L(\ltid, l) \wedge \shareds{\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$\label{pce-init}*)
  n = new int;
  (*$\{V \Vdash \exists l.\, n \mapsto \_ *
L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$*)
  (*$\langle$*)LE[tid-1] = GE;(*$\rangle_{\textsf{UpdateLE}_\ltid}$\label{pce-update}*)
  (*$\{V \Vdash \exists l.\, n \mapsto \_ *
L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$*)
  do {
    (*$\{V \Vdash \exists l.\, n \mapsto \_ *
L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$*)
    s = C;
    (*$\{V \Vdash \exists l.\, n \mapsto \_ *
L(\ltid, l) \wedge \shareds{
I(l,\ltid) * \true_\se} *\mbox{}$\label{pce-establish-since}*)
    (*$\ph(\shared{\LE[\ltid-1] \mapsto l * \true} \since 
\shared{\cc \mapsto s * s \mapsto \_  * \true})\}$*)
    (*$\{V \Vdash \exists l.\, n \mapsto \_ *
L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} *\mbox{}$ \label{pce-mp}*)
    (*$\ph(\shared{\LE[\ltid-1] \mapsto l * \true} \since \shared{\cc \mapsto s
      * s \mapsto \_  * \true}) \wedge {}$*)
    (*$\ph \shared{s \mapsto_e \_ * \true}\}$*)
    (*$\langle$*)v = *s;(*$\rangle_{\textsf{Id}}$*)
    *n = v+1;
    (*$\{V \Vdash \exists l.\, n \mapsto \_ *
L(\ltid, l) \wedge \shareds{\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \wedge
{}$*)
    (*$\ph(\shared{\LE[\ltid-1] \mapsto l * \true} \since \shared{\cc \mapsto s
      * s \mapsto \_  * \true}) \wedge {}$*)
    (*$\ph \shared{s \mapsto_e \_ * \true}\}$*)
  } while (!(*$\langle$*)CAS(&C, s, n)(*$\rangle_{\textsf{Inc}}$*));
  (*$\{V \Vdash \exists l.\, s \mapsto_m \_ *
L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * 
\true_\se}\}$ \label{pce-establish-since-neg}*)
  reclaim(s);
  (*$\{V \Vdash L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$*)
  return v;
}
\end{lstlisting}
}
\caption{\small Proof outline for {\tt inc} with epoch-based reclamation.  Here
$V$ is $v$, $n$, $s$, ${\it s2}$, ${\it my}$, ${\it in\_use}$, $i$.}
\label{fig:epoch1}
\end{figure}

\begin{figure}
{\figfontsize
\begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}] 
void reclaim(int *s) {
  (*$\{V \Vdash \exists l.\, s \mapsto_m \_ *
L(\ltid, l) \wedge \shareds{\Elock \mapsto \_ * I(l, \ltid) * \true_\se} \}$*)
  insert(detached[tid-1][LE[tid-1]], p);
  (*$\{V \Vdash \exists l.\, L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$*)
  if (nondet()) return;
  (*$\{V \Vdash \exists l.\, L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se} \}$*)
  (*$\langle$*)lock(Elock);(*$\rangle_{\textsf{Lock}_{\sf tid}}$*)
  (*$\{V \Vdash \exists l.\, L(\ltid, l) \wedge \shareds{
\Elock \mapsto \ltid * I(l,\ltid) * \true_\se}$ \label{pce-after-lock}*)
  (*$\{V \Vdash \exists l.\, L(\ltid, l) \wedge \shareds{
\Elock \mapsto \ltid * I(l,\ltid) * \true_\se}$*)
  for (int i = 0; i < N; i++) {
    if (GE != LE[i]) {
      (*$\langle$*)unlock(Elock);(*$\rangle_{\textsf{Unlock}_{\sf tid}}$*)
      (*$\{V \Vdash \exists l.\, L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se}$*)
      return;
    }
  }
  (*$\{V \Vdash \exists l, e.\, L(\ltid, e) \wedge {}$*)
  (*$\ph\shareds{\exists y.\, 
\GE \mapsto e * 
\cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *\ldots}$*)
  (*$\ph\shared{\ldots\bigast\nolimits_{t} (\LE[t] \mapsto e * C(t, e\oplus 1) * C(t, e\oplus
  2))* \true_\se }\}$*)
  for (int i = 0; i < N; i++) {
    while (!(*$\langle$*)isEmpty(detached[i][(GE+1)%3])(*$\rangle_{\sf Id}$*)) {
      (*$\{V \Vdash \exists l, e.\, L(\ltid, e) \wedge {}$*)
      (*$\ph\shareds{\exists y.\, \GE \mapsto e * 
\cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *\ldots}$*)
      (*$\ph\shared{\ldots 
\bigast\nolimits_{t} (\LE[t] \mapsto e * C(t, e\oplus 1) * C(t, e\oplus 2))* \true_\se
}\}$*)
      free((*$\langle$*)pop(detached[i][(GE+1)%3])(*$\rangle_{\sf Pop}$\label{pce-pop}*));
    }
  }
  (*$\{V \Vdash \exists l,e.\, L(\ltid, e) \wedge {}$*)
  (*$\ph\shareds{\exists y.\, 
\GE \mapsto e * 
\cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *\ldots}$*)
  (*$\ph\shared{\ldots\bigast\nolimits_{t} (\LE[t] \mapsto e * C(t, e\oplus 1) * C(t, e\oplus
  2))* \true_\se }\}$*)
  (*$\langle$*)GE = (GE+1)%3;(*$\rangle_{\textsf{NextEpoch}_{\sf tid}}$\label{pce-incg}*)
  (*$\langle$*)unlock(Elock);(*$\rangle_{\textsf{Unlock}_{\sf tid}}$*)
  (*$\{V \Vdash \exists l.\, L(\ltid, l) \wedge \shareds{
\Elock \mapsto \_ * I(l,\ltid) * \true_\se)} \}$*)
  return;
}
\end{lstlisting}
}
\caption{\small Proof outline for {\tt inc} with epoch-based reclamation.  Here
$V$ is $v$, $n$, $s$, ${\it s2}$, ${\it my}$, ${\it in\_use}$, $i$.}
\label{fig:epoch2}
\end{figure}

\paragraph{Formal proof.}
The proof outline for the algorithm in Figure~\ref{fig:epoch} is given in
Figures~\ref{fig:epoch1} and~\ref{fig:epoch2}, and the auxiliary assertions, in
Figure~\ref{fig:act-epoch}. 

The key places in the proof are as follows. When a thread updates its local
epoch to the global one at line~\ref{pce-update}, it transfers the {\tt
  detached} set for the old epoch to the shared state. The second conjunct of
$\Upsilon_{\sf E}$ is trivially satisfied for this {\tt detached} set, as the
global epoch is one step ahead of the old one, not one step behind.  The safety
of {\sf Pop} at line~\ref{pce-pop} is ensured by the second conjunct in the
temporal invariant. Finally, when the global epoch is incremented from $e\ominus
1$ to $e$ at line~\ref{pce-incg}, all the threads are at epoch $e\ominus 1$,
which implies the second conjunct of $\Upsilon_{\sf E}$.


% Main invariant: If I saw something when I was in a certain
% epoch, it will not disappear while I'm in the same epoch. 
% This invariant is analogous to the ones in hazard/RCU algorithms, so the reader
% doesn't have to do much to establish the since clause. However, it puts a lot of
% proof burden on the reclaimer. It might be that there are other formulations
% that spread the proof burden in a different way.
% %You might try to recast the invariant in terms of the global epoch.



% \mypar{Why the reclaimer does not violate the invariant.} 
% We rely on the following global invariant:
% $$
% \forall t.\, \gep \in \{\lep[t], \lep[t]+1\}.
% $$
% This is because the global epoch only changes when everyone is at the previous
% epoch: need to guard the action accordingly.

% Assume the reclaimer is reclaiming from the limbo list $k$. Then everyone is at
% $k+2$. So, we need to check the following instantiation of the temporal
% invariant:
% $$
% (\lep[t] = k+2 \since \cc \mapsto x \wedge \lep[t] = k+2) \Rightarrow x \mapsto \_
% $$
% We show this by showing
% $$
% \neg (\lep[t] = k+2 \since \cc \mapsto x \wedge \lep[t] = k+2)
% $$

% Consider the time when x is detached into the limbo list $k$ by thread $t'$ and
% assume that the thread $t$ is at $k+2$. Then $\lep[t'] = k$ and $\lep[t] =
% k+2$. Hence, $\gep \in \{k, k+1\}$ and $\gep \in \{k+2, k\}$. From this, $\gep = k$,
% which implies
% $$
% (\lep[t] = k+2 \since \cc \mapsto x \wedge \lep[t] = k+2) \Rightarrow \gep = k
% $$
% If this is stable, then it will be true at the time of the reclaim. But at that
% point $\gep = k+2$, so the since clause is false as required.

% Let us show the stability of the above assertion. Consider a state where the
% assertion is true, and a transition from that state. Assume the assertion is
% false at the target state, so that the since clause is true, but $\gep\not= k$.
% We have two cases.

% 1. The since clause is false. To make it true in the target state has to have
% $\cc \mapsto x$, but this can't happen because the reclaimer holds the master
% permission for the node.

% 2. The since clause is true and $\gep = k$. If $\gep = k$ in the source state
% and $\gep \not= k$ in the next state, then in the next state $\gep=k+1$. Since
% the since clause is true in the next state, there we have $\lep[t] = k+2$. But
% this and $\gep= k+1$ contradict the invariant relating the two.

% We also need to handle the case when the thread that detaches the node is the
% one for which we need to check the invariant (easy).


% \begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}]
% int GE = 0;
% int LE[NTHREADS];
% Set detached[NTHREADS][3];
% lock Elock;

% int inc() {
%   (*$\{V \Vdash \exists l.\,
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$\label{pce-init}*)
%   int *x = new int;
%   int *p;
%   (*$\{V \Vdash \exists l.\, x \mapsto \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   (*$\langle$*)LE[tid()] = GE;(*$\rangle_{\textsf{UpdateLE}_\ltid}$\label{pce-update}*)
%   (*$\{V \Vdash \exists l.\, x \mapsto \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   do {
%     (*$\{V \Vdash \exists l.\, x \mapsto \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%     int *p = C;
%     (*$\{V \Vdash \exists l.\, x \mapsto \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * 
% I(g) * \true)} *{}$\label{pce-establish-since}*)
%     (*$\ph(\shared{\LE[\ltid] \mapsto l * \true} \since \shared{\cc \mapsto p * p \mapsto \_  * \true})
% \}$*)
%     (*$\{V \Vdash \exists l.\, x \mapsto \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} *{}$ \label{pce-mp}*)
%     (*$\ph(\shared{\LE[\ltid] \mapsto l * \true} \since \shared{\cc \mapsto p * p \mapsto \_  * \true})
% \wedge \shared{p \mapsto_e \_}\}$*)
%     (*$\langle$*)*x = *p + 1;(*$\rangle_{\textsf{Id}}$*)
%     (*$\{V \Vdash \exists l.\, x \mapsto \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   } while (!(*$\langle$*)CAS(&C, p, x)(*$\rangle_{\textsf{Inc}}$*));
%   (*$\{V \Vdash \exists l.\, p \mapsto_m \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * 
% \true)} *{}$ \label{pce-establish-since-neg}*)
%   (*$\ph\forall s.\,
% ((\shared{\LE[s] \mapsto l\oplus2 * \true} \since \shared{\cc \mapsto p * p \mapsto \_ * \true}) \implies
% \shared{\GE \mapsto l * \true}) \}$*)
%   epoch_free(c);
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   return v;
% }

% void epoch_free(int *p) {
%   (*$\{V \Vdash \exists l.\, p \mapsto_m \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} *{}$*)
%   (*$\ph\forall s.\,
% ((\shared{\LE[s] \mapsto l\oplus2 * \true} \since \shared{\cc \mapsto x * x \mapsto \_ * \true}) \implies
% \shared{\GE \mapsto l * \true}) \}$*)
%   int l = LE[tid()];
%   (*$\{V \Vdash p \mapsto_m \_ *
% L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} *{}$*)
%   (*$\ph\forall s.\,
% ((\shared{\LE[s] \mapsto l\oplus2 * \true} \since \shared{\cc \mapsto x * x \mapsto \_ * \true}) \implies
% \shared{\GE \mapsto l * \true}) \}$*)
%   insert(detached[tid()][l], p);
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   if (nondet())
%     reclaim();
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
% }
% \end{lstlisting}
% }
% \end{figure*}

% \begin{figure*}
% {\small
% \begin{lstlisting}[numbers=left, numberstyle=\tiny,language=C,escapeinside={(*}{*)}] 
% void reclaim() {
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   (*$\langle$*)lock(Elock);(*$\rangle_{\textsf{Lock}_{\sf tid}}$*)
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid * I(g) * \true)}$ \label{pce-after-lock}*)
%   int g = GE;
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid * I(g) * \true)}$*)
%   for (int t = 0; t < NTHREADS; t++) {
%     if (g != LE[tid()]) {
%       (*$\langle$*)unlock(Elock);(*$\rangle_{\textsf{Unlock}_{\sf tid}}$*)
%       (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)}$*)
%       return;
%     }
%   }
%   (*$\{V \Vdash L(\ltid, g) \wedge \shareds{\exists y.\, 
% \GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *
% \bigast\nolimits_{t} (\LE[t] \mapsto g * C(t, g\oplus 1) * C(t, g\oplus 2))* \true\}
% }$\label{pce-after-test}*)
%   (*$\{V \Vdash \exists \vec{A}.\, L(\ltid, g) \wedge \shareds{\exists y.\, 
% \GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *
% \bigast\nolimits_{t} (\LE[t] \mapsto g * C(t, g\oplus 2) *
% \rlist[t][g\oplus 1] \mapsto A_t * (\bigast\nolimits_{x \in A_t} x \mapsto \_)) * \true
% }$ \label{pce-use-neg}*)
%   (*$\ph 
% \forall t.\, \forall x \in A_t.\, \forall s.\,
% ((\shared{\LE[s] \mapsto g * \true} \since \shared{\cc \mapsto x * x \mapsto \_
%   * \true}) \implies \shared{\GE \mapsto g\oplus 1 * \true}))
% \}$*)
%   (*$\{V \Vdash \exists \vec{A}.\, L(\ltid, g) \wedge \shareds{\exists y.\, 
% \GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *
% \bigast\nolimits_{t} (\LE[t] \mapsto g * C(t, g\oplus 2) *
% \rlist[t][g\oplus 1] \mapsto A_t * (\bigast\nolimits_{x \in A_t} x \mapsto \_)) * \true
% }$ \label{pce-neg-contradiction}*)
%   (*$\ph 
% \forall t.\, \forall x \in A_t.\, \forall s.\,
% \neg(\shared{\LE[s] \mapsto g * \true} \since \shared{\cc \mapsto x * x \mapsto \_ * \true})
% \}$*)
%   for (t = 0; t < NTHREADS; t++) {
%     while (!(*$\langle$*)isEmpty(detached[t][(g + 1) % 3])(*$\rangle_{\sf Id}$*)) {
%       (*$\{V \Vdash \exists \vec{A}.\, L(\ltid, g) \wedge \shareds{\exists y.\, 
% \GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid *
% \bigast\nolimits_{t} (\LE[t] \mapsto g * C(t, g\oplus 2) *
% \rlist[t][g\oplus 1] \mapsto A_t * (\bigast\nolimits_{x \in A_t} x \mapsto \_)) * \true
% }$ \label{pce-neg-contradiction}*)
%       (*$\ph 
% \forall t.\, \forall x \in A_t.\, \forall s.\,
% \neg(\shared{\LE[s] \mapsto g * \true} \since \shared{\cc \mapsto x * x \mapsto \_ * \true})
% \}$*)
%       free((*$\langle$*)pop(detached[t][(g + 1) % 3])(*$\rangle_{\sf Pop}$*));
%     }
%   }
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid * I(g) * \true)}$*)
%   (*$\langle$*)GE = (g + 1) % 3;(*$\rangle_{\textsf{NextEpoch}_{\sf tid}}$*)
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g \oplus 1 * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \ltid * I(g) * \true)}$*)
%   (*$\langle$*)unlock(Elock);(*$\rangle_{\textsf{Unlock}_{\sf tid}}$*)
%   (*$\{V \Vdash L(\ltid, l) \wedge \shareds{\exists g, y.\, (\LE[\ltid] \mapsto l *\true)
% \wedge (\GE \mapsto g * 
% \cc \mapsto y * y \mapsto \_ * \Elock \mapsto \_ * I(g) * \true)} \}$*)
%   return;
% }
% \end{lstlisting}
% }
% \end{figure*}

% $L$ is stable, because: 1) removing $x \mapsto_e \_$ requires a full permission in
% the shared state, and the master permission is in the local state

% 2) The since clause is stable. If the since clause is true initially, then
% GE is not equal to the corresponding LE, and can't change, so it will stay
% true. If the since clause is false, then it can't become true because $x$ will
% not be in the shared state with a full permission - we have a master in our
% local state. 

% If someone removes a detached list, then we don't get an
% obligation. When someone inserts it, he will preserve the invariant, so we know
% the assertion will be stable.

% 3) $g \in \{l, l \oplus 1\}$ is stable because $g$ can be incremented only when $g=l$.

% $\Upsilon$ is stable: same as above, but the master for $x$ is not in the local
% state. It's in the shared state pointed to by detached, and disjoint from the
% head node. Perhaps we should just add a data structure invariant to $\Upsilon$.

% \ref{pce-update}.  The next detached list is in the shared state. When we put
% our list back, we have all the since clauses to establish $\Upsilon$.

% \ref{pce-establish-since}. Establish the since clause as usual: $A \wedge B
% \implies A \since B$.

% \ref{pce-mp}. Add the invariant and do MP. This guarantees the cell is allocated.

% \ref{pce-establish-since-neg}. $(B \wedge (A \implies C)) \implies ((A \since B)
% \implies C)$. $A \implies C$ is established from relations between $g$ and $l$:
% $g \in \{l \oplus 2, l\} \wedge g \in \{l, l \oplus 1\} \implies g = l$.

% \ref{pce-after-lock}. From here on, it's only us now who can do any relevant
% actions on the shared state.

% \ref{pce-after-test}. Everyone will stay at $g$ because NextEpoch can't fire.

% \ref{pce-use-neg}.  Use the invariant and do MP (note that we know that the list
% $g\uplus 1$ is in the shared state, which fires off the invariant).

% \ref{pce-neg-contradiction}. This gives a contradiction with the current $g$, so
% the since clause is false. This means that Take will not violate the
% invariant. We can now safely operate on the detached list, because LEs will stay
% where they are.


% Most likely, most of the formulas comprising the assertions in the outline can
% be packaged into special predicates, so that it didn't look that scary.

% \ag{May be we should just add a basic data structure invariant to the temporal
%   one.} 

% \ag{Actually, the current simplification relies on us being able to remove an
%   element from detached atomically.  CSL-style rules might not be directly
%   applicable. Is this is case for atomicity abstraction?  }


%%% Local Variables:
%%% TeX-master: "recycling"
%%% mode: latex
%%% End:  
