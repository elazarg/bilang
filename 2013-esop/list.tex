\section{Example: Using RCU for memory reclamation\label{sec:list}}

We first demonstrate how our logic can deal with the use of RCU for safe memory
deallocation, considering the list library presented in
Section~\ref{sec:rcu}. We prove the algorithm in the logic of
Section~\ref{sec:logic} instantiated with the algebra $\RAM_{\pi}$ of
Section~\ref{sec:perm}. We assume that in the program in Figure~\ref{fig:list},
global variables are constants and local variables are allocated at fixed
addresses in memory. For a local variable {\tt var} of thread $t$, we write
$\mathit{var} \Vdash P$ for $\exists \mathit{var}.\, (\&{\tt var}+t) \mapsto
\mathit{var} * P$ where $\&\mathtt{var}$ is the address of the variable. Note
that here {\tt var} is a program variable, whereas ${\it var}$ is a logical
one. We use a similar notation for a list of variables $V$.


The actions used in the proof of the algorithm and the guarantees constructed
from them are given in Figure~\ref{fig:act}. 
\begin{figure}[t]
$$
\begin{array}{r@{}l@{\ }l@{\ \ }l@{\ \ }l@{\ \ \ }r}
x \xmapsto{\se : n} y,u &;&  \emp   &\leadsto&
x \xmapsto{\se : n} z,u * z \mapsto y,\_   &(\textsf{Insert})
\\
\head \mapsto x, \_ * x \xmapsto{\se:n+1} y, u
&;& 
y\hookrightarrow_{\sf e} \_,\_   &\leadsto&
\head \mapsto x, \_ * x \xmapsto{\se:n+1} y, u
&(\textsf{Take-R1})
\\
\multicolumn{5}{l}{x \hookrightarrow_{\sf e} \_,\_ \ \ \mid\ \ 
x \xmapsto{\se : n, \sro:m} y,u * y \xmapsto{\se: n'+1, \sro:m'} z,v;\ 
y \hookrightarrow_{\sf e}\_,\_  \quad \leadsto 
}
\\
&&&&
x \xmapsto{\se : n, \sro:m} y,u * y \xmapsto{\se: n'+1, \sro:m'} z,v
& (\textsf{Take-R2})
\\
x \xmapsto{\se:n} z,u * z \xmapsto{\se:m} y,v &;& \emp  &\leadsto&
x \xmapsto{\se:n} y,u * z \xmapsto{\se:m, \sro:1} y,v  &(\textsf{Unlink})
\\
x \hookrightarrow_{\sf ro} \_,\_ \ \ \mid\ \  x \xmapsto{\sro:1} \_,\_ &;& \emp
&\leadsto& \emp \mid
\\
\multicolumn{5}{r@{\ \ \ }}{
\shared{
\exists y.\,\head \mapsto y, \_ * \lsin(y, 0) * 
\exists A. \bigast\nolimits_{z \in A} z \xmapsto{\sro:1} \_,\_
}}  &(\textsf{Take-W})
\end{array}
$$
$$
G_\rr = \{\textsf{Take-R1},\textsf{Take-R2}\}; \qquad 
G_\ww =\{\textsf{Insert}, \textsf{Unlink},\textsf{Take-W}\}
$$ 
%\vspace{-10pt}
\caption{Actions used in the proof of the list library. We omit the guard in an
  action when it is $\emp$.}
\label{fig:act}
\end{figure}
The actions define the operations performed by readers and writers following the
explanation in Section~\ref{sec:informal}. The \textsf{Insert} action allows a
writer to insert a node into the list with the full permission. As we have noted
before, in the list algorithm a reader takes existential permissions for nodes
in the shared state for the duration of its critical section. This is allowed by
the actions \textsf{Take-R1} and \textsf{Take-R2}, which also define the
protocol readers follow in traversing the data structure: a reader can get a
permission only for a node that either follows {\tt head} or another node the
reader already has a permission for. The proof of {\tt retire} relies crucially
on this protocol.  Note that $y \xmapsto{\se: n,\sro:m} z,u \Longleftrightarrow
y \xmapsto{\se:n+1,\sro:m} z,u * y \hookrightarrow_{\sf e} \_,\_$, so the
actions increase the count of existential permissions for the node.
% In the former case, we use a version of the list predicate parameterised by the
% set of its nodes to state the fact that the reader does not modify the list:
% $$
% \lsrest(A, x, y) \Longleftrightarrow \ls\ 
% (\lambda x,z,w.\, \exists n.\, x \xmapsto{n}_{\sf e} z, \_
% \wedge w = (x, n)) \ (A, x, y).
% $$
% In the case of \textsf{Take-R2}, the reader is required to hold an existential
% permission for a node $x$ pointing to the node $y$ he is taking a permission
% for: such a permission is needed to get a reference to $y$ at the {\tt ref}
% statement in {\tt search}. We can also assume that the count in the master
% permission of the node $x$ is at least $2$. One of the existential permissions
% is held by the reader executing the action. Another one is held by the writer
% that unlinked the element from the list. 

The \textsf{Unlink} action allows a writer to unlink a node from the main list,
even if readers still hold existential permissions for the node. In the
algorithm, the thread that unlinks the node will be the one to deallocate it. To
express this protocol, the \textsf{Unlink} action allows the writer to take a
read-only permission for the node being unlinked. This ensures that the node is
immutable and no other writer executes \textsf{Unlink} on it again.
Furthermore, the \textsf{Take-W} action lets the writer take the master
permission for a node outside the main list only when the writer holds a
read-only permission for it, thus expressing the desired protocol.  (Here
we use read-only counting permissions in $\RAM_{\pi}$ only in a restricted way;
the example in Section~\ref{sec:hash} uses their full power.) It is safe to
remove a node from the shared state using \textsf{Take-W} only when no reader
can reach it; this is the reason for executing $\sync$ in {\tt retire}. We
express this by restricting \textsf{Take-W} with a view on the shared state that
requires readers not to have any references to nodes outside the main list (the
predicate $\lsin$ describing the main list is defined below).  We implicitly
allow both readers and writers to use a special \textsf{Id} action that allows
accessing shared state without modifying it.

The proof of the list library in our logic is given in
Figures~\ref{fig:search}--\ref{fig:retire}.
\begin{figure}[t]
\noindent%
%\verb|struct Node { Node *next; int key; };|\\
%\verb|Node *head;|\\
%\verb| |\\
\verb|int search(int key) { |%
\textcolor{blue}{$\{V \Vdash \exists A.\, F(A) * \shared{I(A)}\}$}\\
\verb|  Node *curr;|\\
\verb|  rlock {|\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A.\, F(A) * \shared{I(A)}\}$}\\ 
\verb|    |$\langle$ \verb|curr = head->next;| $\rangle_{\textsf{Take-R1},\textsf{Id}}$\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A.\,
(\curr = 0  \wedge \emp \vee \lfloor \curr \hookrightarrow_{\sf e} \_,\_\rfloor ) * 
F(A) * \shareds{\inv(A, \curr)} \}$}\\
\verb|    while (curr != NULL) {|\\
\verb|      |\textcolor{blue}{$\{V \Vdash 
\exists A.\, \lfloor \curr \hookrightarrow_{\sf e} \_,\_ *  \true \rfloor *  F(A) * 
\shareds{\inv(A, \curr)}\}$}\\
\verb|      if (|$\langle$ \verb|curr->key == key| $\rangle$\verb|) return 1;|\\
\verb|      else|\\
\verb|ref:    |$\langle$ \verb|curr = curr->next;|
$\rangle_{\textsf{Take-R1}, \textsf{Take-R2},\textsf{Id}}$\\
\verb|        |\textcolor{blue}{$\{V \Vdash 
\exists A.\, (\curr = 0 \wedge \emp \vee \lfloor \curr \hookrightarrow_{\sf e}
\_,\_ \rfloor) * \lfloor \true
\rfloor *   F(A) * \shareds{\inv(A, \curr)}\}$}\\ 
\verb|    }|\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A.\, \lfloor \true \rfloor *  
F(A) * \shared{I(A)}\}$}\\ 
\verb|  }|\\
\verb|  |\textcolor{blue}{$\{V \Vdash \exists A.\,  F(A) * \shared{I(A)}\}$}\\
\verb|  return 0;|\\
\verb|}|
\caption{The proof of the {\tt search} method. Here $V$ is $\curr, \key, \prev, \block$.}
\label{fig:search}
\end{figure}
\begin{figure}[t]
\verb|void remove(int key) { |%
\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*\shared{I(A)}\}$}\\
\verb|  Node *prev, *curr;|\\
\verb|  wlock {|\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*\shared{I(A)}\}$}\\
\verb|    prev = head; |$\langle$ \verb|curr = head->next;| $\rangle_{\sf Id}$\\
\verb|    while (curr != NULL) {|\\
\verb|      |\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*\shared{
\exists y,m,n.\, ((\head = \prev \Rightarrow m=0) \wedge \emp)*
\lsin(\head, \prev) * {} \ldots\,}$}\\
\verb|      |\textcolor{blue}{$\phantom{\{}\shared{
\prev \xmapsto{\se:m} \curr,\_ {*} \lfloor \prev \xhookrightarrow{m}_{\sf e} \curr,\_\rfloor{*}
\curr \xmapsto{\se:n} y,\_ {*} \lfloor \curr \xhookrightarrow{n}_{\sf e} y,\_\rfloor
{*} \lsin(y, 0) {*} R(A)}\}$}\\
\verb|      if (|$\langle$ \verb|curr->key == key| $\rangle_{\sf Id}$\verb|) {|\\
\verb|        |$\langle$ \verb|prev->next = curr->next;| $\rangle _{\sf Unlink}$\\
\verb|        |\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*\curr
  \hookrightarrow_{\sf ro} \_,\_*{}$}\\ 
\verb|        |\textcolor{blue}{$\phantom{\{}\shared{\exists x, n.\, \head
    \mapsto x,\_ * \lsin(x, 0) *  
\curr \xmapsto{\se:n,\sro:1} \_,\_ * 
\lfloor \curr \xhookrightarrow{n}_{\sf e} \_,\_ \rfloor*R(A)}\}$}\\
\verb|        break;|\\
\verb|      } else {|\\
\verb|        prev = curr; |$\langle$ \verb|curr = curr->next;| $\rangle_{\sf Id}$\\
\verb|        |\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*
\shared{\exists x,n.\, \head \mapsto x,\_ * \lsin(x, \prev) * {}\ldots \,}$}\\
\verb|        |\textcolor{blue}{$\phantom{\{}
\shared{\prev
  \xmapsto{\se:n} \curr,\_ * \lfloor \prev \xhookrightarrow{n}_{\sf e} \_,\_
\rfloor * \lsin(\curr, 0) * R(A)}\}$}\\
\verb|      }|\\
\verb|    }|\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A.\, (\curr = 0 \wedge \emp) * F(A)*
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * R(A)} \vee  {}$}\\
\verb|    |\textcolor{blue}{$\ph 
F(A)*\curr \hookrightarrow_{\sf ro} \_,\_*\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * 
R(A\uplus \{\curr\})}
\}$}\\
\verb|    if (curr != NULL) retire(curr);|\\
\verb|  } |\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*\shared{I(A)}\}$}\\
\verb|}|
\caption{The proof of the {\tt remove} method. Here $V$ is $\curr, \key, \prev, \block$.}
\label{fig:remove}
\end{figure}
\begin{figure}
%\verb|struct Block { Block *next; Node *node; };|\\
%\verb|Block *freelist[NTHREADS];|\\
%\verb|  |\\
\verb|void retire(Node* curr) {|\\
\verb|  |\textcolor{blue}{$\{V \Vdash \exists A.\,F(A)*\curr \hookrightarrow_{\sf ro} \_,\_*
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) *R(A \uplus \{\curr\})}\}$}\\
\verb|  if (nondet()) {|\\
\verb|    block = new Block; block->node = curr;|\\
%\verb|    |$\{V \Vdash \exists A, y.\,
%(\freelist+t) \mapsto y * \freels(A, y, 0)*\curr \hookrightarrow_{\sf ro} \_,\_*
%\block \mapsto y,\curr *{}$\\
%\verb|    |$\phantom{\{}
%\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) 
%*R(A \uplus \{\curr\})}\}$\\
\verb|    block->next = freelist[tid()]; freelist[tid()] = block;|\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A.\, F(A)*
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * R(A)}\}$}\\
\verb|  } else {|\\
\verb|    sync;|\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A, y.\,
(\freelist+t) \mapsto y * \freels(A, y, 0)*\curr \hookrightarrow_{\sro}\_,\_*{}$}\\
\verb|    |\textcolor{blue}{$\phantom{\{}
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * 
\exists B.\, (\bigast\nolimits_{z \in A \uplus \{\curr\}\uplus B} z \xmapsto{\sro:1} \_,\_)}\}$}\\
\verb|    |$\langle$ \verb|;| $\rangle_\textsf{Take-W}$\\
\verb|    |\textcolor{blue}{$\{V \Vdash \exists A, y.\,
(\freelist+t) \mapsto y * \freels(A, y, 0)*
(\bigast\nolimits_{z\in A} z \xmapsto{\sro:1} \_,\_)*\curr \mapsto \_,\_*{}$}\\
\verb|    |\textcolor{blue}{$\phantom{\{}
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * 
\exists B.\, (\bigast\nolimits_{z\in B} z \xmapsto{\sro:1} \_,\_)}\}$}\\
\verb|    delete(curr);|\\
\verb|    while (freelist[tid()] != NULL) {|\\
\verb|      block = freelist[tid()]->next; delete(freelist[tid()]->node);|\\
\verb|      delete(freelist[tid()]); freelist[tid()] = block; }|\\
\verb|    |\textcolor{blue}{$\{V \Vdash  F(\emptyset)*
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * 
\exists B.\, (\bigast\nolimits_{z\in B} z \xmapsto{\sro:1} \_,\_)}\}$}\\
\verb|  } |\textcolor{blue}{$\{V \Vdash \exists A.\, F(A)*
\shared{\exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * R(A)}\}$}\\
\verb|}|
\caption{The proof of the {\tt retire} method. Here $V$ is $\curr, \key, \prev, \block$.}
\label{fig:retire}
\end{figure}
We have omitted the proof of {\tt insert} (see Appendix~\ref{app:list}). We annotate
each statement accessing the shared state with the action used in the
corresponding application of the {\sc Shared-R} or {\sc Shared-W} rule in the
proof.  To describe data structures arising in the execution of the algorithm,
we use the following inductive predicate
\begin{multline*}
\ls\ \Lambda\ (A, x, y) \Longleftrightarrow 
(x = y \wedge A = \emptyset \wedge \emp) \vee{}\\
(\exists A', z, w.\,  (x \not= y \wedge A = A' \uplus \{w\} \wedge \emp) *
\Lambda(x, z, w) * \ls\ \Lambda\ (A', z, y)),
\end{multline*}
which denotes a possibly empty list segment with the first node allocated at the
address $x$, the pointer stored in the last node equal to $y$, and the set of
values stored in the list equal to $A$. The parameter predicate $\Lambda(x, z,
w)$ describes a single node allocated at the address $x$, pointing to the next
node $z$ and storing the value $w$. We instantiate it in different ways
depending on the context. 

The preconditions and postconditions of the list methods are $V\Vdash\exists
A.\, F(A) * \shared{I(A)}$. Here $F(A)$ describes the thread-local free list of
nodes unlinked from the main list by the thread being verified, with the
set of their addresses $A$. The invariant of the shared state $I(A)$
describes the main list starting from {\tt head} and an arbitrary set of other
nodes including $A$. These are formally defined as follows:
\begin{gather*}
I(A) \Longleftrightarrow \exists x.\, \head \mapsto x,\_ * \lsin(x, 0) * R(A),
\\
R(A) \Longleftrightarrow \exists B.\,
(\bigast\nolimits_{z \in A \uplus B} \exists n.\,
z \xmapsto{\se:n,\sro:1} \_,\_ * \lfloor z \xhookrightarrow{n}_{\sf e} \_,\_
\rfloor),
\\
F(A) \Longleftrightarrow \exists x.\, ({\tt freelist}+t) \mapsto x * \freels(A, x, 0).
\end{gather*}
Here $t$ is the current thread identifier, and $\bigast$ is the iterated version
of $*$. The predicates
\begin{gather*}
\lsin(x, y) \Longleftrightarrow \exists A.\, \ls\ 
(\lambda x,z,w.\, \exists n.\, x \xmapsto{\se:n} z, \_
* \lfloor x \xhookrightarrow{n}_{\sf e} \_, \_ \rfloor) \ (A, x, y),
\\
\freels(A, x, y) \Longleftrightarrow \ls\ 
(\lambda x,z,w.\, x \mapsto z, w * w \hookrightarrow_{\sf ro} \_,\_) \ (A, x, y)
\end{gather*}
describe the main list and the thread-local free list, respectively.  Thus, the
nodes in the shared state might have existential permissions for them taken out
by readers, with the shadow state containing all the missing permissions. Each
node outside the main list, i.e., in $R(A)$, also has one read-only permission
issued to the writer that unlinked it from the list. This is stored inside $F(A)$
for the writer thread and ensures the stability of $V\Vdash\exists A.\, F(A) *
\shared{I(A)}$ with respect to {\sf Take-W}: only a writer having the only
read-only permission for the node can remove it from the shared state.

Consider the {\tt search} method. After a reader gets a reference {\tt curr} to
a node in the main list, e.g., when reading \verb|head->next|, the node might
get unlinked from the list by a concurrent writer (see the explanation in
Section~\ref{sec:rcu}). We take this into account using
$$
\begin{array}{@{}c@{}}
\inv(A, \curr) \Longleftrightarrow 
\exists x,y.\, 
\head \mapsto x,\_ * \lsin(x, y) * \lsin(y, 0) * 
\lsout(\curr,y) * R(A), 
\\
\lsout(x, y) \Longleftrightarrow 
\exists A.\, \ls\ 
(\lambda x,z,w.\,\exists n.\, x \xmapsto{\se:n,\sro:1} z, \_* 
\lfloor x \xhookrightarrow{n}_{\sf e} \_, \_ \rfloor)\ (A, x, y).
\end{array}
$$
Depending on whether the list $\lsout(\curr,y)$ is empty or not, the predicate
$\inv(A, \curr)$ describes cases when the {\tt curr} node is in the main list or
has been unlinked (Figure~\ref{fig:sc1}). The resulting assertions in the code
are stable, i.e., fully take into account the interference from concurrent
threads. In particular, note that the action {\sf Take-W} by the environment is
not applicable when {\tt search} is at {\tt ref}: it requires the readers to
have no permissions for nodes outside the main list, but {\tt search} has one
for {\tt curr}.

The proof of {\tt remove} is mostly straightforward. Since it executes within a
write section and RCU ensures mutual exclusion between writers, we do not have
to check the stability of assertions with respect to writer actions. Finally,
consider the proof of {\tt retire}. The $\sync$ command transfers all
existential permissions for nodes outside the main list from the shadow
partition to the real one. The resulting assertion in the code is stable: the
actions \textsf{Take-R1} and \textsf{Take-R2} allow readers to take permissions
only for nodes reachable from {\tt head} and nodes they already have
permissions for, and in this case, they do not have any permissions for nodes
outside the main list. This allows the writer to transfer the permissions for
these nodes from the shared state to its unrestricted local state (we have
inserted an empty command to make the transfer explicit). It thus obtains the
full permissions for these nodes, which allows their safe deallocation.

The proof establishes that the algorithm is safe. From the postcondition
$V\Vdash\exists A.\, F(A) * \shared{I(A)}$ of library methods, it also follows
that, if we sum up permissions for every node held in the shared partition and
local partitions of all threads, then all nodes with the full permission will be
reachable either from {\tt head} or from thread-local free lists. Therefore, the
algorithm does not leak memory.

%%% Local Variables:
%%% TeX-master: "rcu"
%%% End:  
