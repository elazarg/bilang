%!TEX root = ./recycling.tex

\subsection{Pass The Buck (Repeated Offender Problem)}\label{sec:proofs-pass}



The code is simplified in the following manner:

1. The loop in procedure Liberate is unrolled.

2. The number of ``deployed'' guards and their assignments to threads is fixed.
(Thread t uses guard t.) Thus, the array GUARDS and the shared variable MG got removed. Also, the \texttt{while} loop was replaced by a \texttt{for} loop.
\textbf{Note: The condition in the while loop in \texttt{Liberate} is \texttt{i <= MG}. This seems a bit weird - i.e., condition \texttt{i < MG} seems to work. See if there is a hidden race.}


3. The names of the arrays is shortened: Post => P and HANDOFF => HO.

4. Procedure Liberate does not return a set because it modifies its parameter.  


\begin{figure*}
{\small
\begin{lstlisting}[style=nonumbers,language=C,escapeinside={(*}{*)}]
int *C = new int(0);

Set *set[NTHREADS] = {new Set(), ..., new Set()};
typedef struct { value val; int ver } entry;
const int MG = NTHREADS;
value P[MG] = {0};  
entry HO[MG] = {<null,0>}; 

int inc() {
  int *p, *p2, *x = new int;
  int v;
  do {
    do {
      p = C;
      P[tid()] = p;
      p2 = C;
    } while (p != p2);
    v = *p;
    *x = v+1;
  } while ((*$\langle$*)CAS(&C, p, x)(*$\rangle_{\textsf{Inc}}$*));
  P[tid()] = null;
  retire(p);
  return v;
}

void retire(int* p) {  
  set[tid()].add(p);
  if (set[tid()].size() <= LSIZE) {
    return;
  }
  Liberate(set[tid()]);
  Set ret = set[tid()]; 
  set[tid()] = new Set();
  return ret;
}

Liberate(set *vs) {  
  for (int i = 0; i < MG; i++) {  
    int a = 0;
    entry <f = F[i]>;
    value v = POST[i];
    //if (v != null && vs.search(v)) 
    if (v == null || !vs.search(v)) {
      if (f.val != null && f.val != v) 
      if (CAS(&F[i], f, <null, h.ver+1>)) 
        vs.insert(h.val);
    } else {
      // (v != null && vs.search(v))       
      if (dCAS(&F[i],h, <v, f.ver+1>)) { 
        vs.delete(v);
        if (f.val != null) 
          vs.insert(f.val);
      } else { // a=1;
        entry <f1 = HANDOFF[i]>;
        if (v == POST[i]) {
          if (dCAS(&F[i], f1, <v, f1.ver+1>)) { 
            vs.delete(v);
            if (f1.val != null) 
              vs.insert(f1.val);
          } else { // a = 2
            entry <f2 = F[i]>;
            if (f2.val == null && v == POST[i]) {
              if (dCAS(&F[i], f2, <v, f2.ver+1>)) { 
                vs.delete(v);
                if (f2.val != null) 
                  vs.insert(f2.val);
  } } } } } } }

  return vs;
}

\end{lstlisting}
}
\end{figure*}
